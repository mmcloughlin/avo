// Code generated by command: go run asm.go -out allocfail.s -stubs stubs.go. DO NOT EDIT.

// +build !appengine
// +build !noasm
// +build gc

package allocfail

// encodeBlockAsm encodes a non-empty src to a guaranteed-large-enough dst.
// It assumes that the varint-encoded length of the decompressed bytes has already been written.
//
//go:noescape
func encodeBlockAsm(dst []byte, src []byte) int

// encodeBlockAsm14B encodes a non-empty src to a guaranteed-large-enough dst.
// It assumes that the varint-encoded length of the decompressed bytes has already been written.
//
//go:noescape
func encodeBlockAsm14B(dst []byte, src []byte) int

// encodeBlockAsm12B encodes a non-empty src to a guaranteed-large-enough dst.
// It assumes that the varint-encoded length of the decompressed bytes has already been written.
//
//go:noescape
func encodeBlockAsm12B(dst []byte, src []byte) int

// encodeBlockAsmAvx encodes a non-empty src to a guaranteed-large-enough dst.
// It assumes that the varint-encoded length of the decompressed bytes has already been written.
//
//go:noescape
func encodeBlockAsmAvx(dst []byte, src []byte) int

// encodeBlockAsm14BAvx encodes a non-empty src to a guaranteed-large-enough dst.
// It assumes that the varint-encoded length of the decompressed bytes has already been written.
//
//go:noescape
func encodeBlockAsm14BAvx(dst []byte, src []byte) int

// encodeBlockAsm12BAvx encodes a non-empty src to a guaranteed-large-enough dst.
// It assumes that the varint-encoded length of the decompressed bytes has already been written.
//
//go:noescape
func encodeBlockAsm12BAvx(dst []byte, src []byte) int

// emitLiteral writes a literal chunk and returns the number of bytes written.
//
// It assumes that:
//   dst is long enough to hold the encoded bytes
//   0 <= len(lit) && len(lit) <= math.MaxUint32
//
//go:noescape
func emitLiteral(dst []byte, lit []byte) int

// emitLiteralAvx writes a literal chunk and returns the number of bytes written.
//
// It assumes that:
//   dst is long enough to hold the encoded bytes
//   0 <= len(lit) && len(lit) <= math.MaxUint32
//
//go:noescape
func emitLiteralAvx(dst []byte, lit []byte) int

// emitRepeat writes a repeat chunk and returns the number of bytes written.
// Length must be at least 4 and < 1<<32
//
//go:noescape
func emitRepeat(dst []byte, offset int, length int) int

// emitCopy writes a copy chunk and returns the number of bytes written.
//
// It assumes that:
//   dst is long enough to hold the encoded bytes
//   1 <= offset && offset <= math.MaxUint32
//   4 <= length && length <= 1 << 24
//
//go:noescape
func emitCopy(dst []byte, offset int, length int) int

// matchLen returns how many bytes match in a and b
//
// It assumes that:
//   len(a) <= len(b)
//
//go:noescape
func matchLen(a []byte, b []byte) int
