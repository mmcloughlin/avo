// Code generated by command: avogen -output zctors.go ctors. DO NOT EDIT.

package x86

import (
	"errors"

	intrep "github.com/mmcloughlin/avo/ir"
	"github.com/mmcloughlin/avo/operand"
	"github.com/mmcloughlin/avo/reg"
)

// ADCB: Add with Carry.
//
// Forms:
//
// 	ADCB imm8 al
// 	ADCB imm8 m8
// 	ADCB imm8 r8
// 	ADCB m8   r8
// 	ADCB r8   m8
// 	ADCB r8   r8
func ADCB(imr, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(imr) && operand.IsAL(amr),
		operand.IsIMM8(imr) && operand.IsM8(amr),
		operand.IsIMM8(imr) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:   "ADCB",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{amr},
		}, nil
	case operand.IsM8(imr) && operand.IsR8(amr),
		operand.IsR8(imr) && operand.IsM8(amr),
		operand.IsR8(imr) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:   "ADCB",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{imr, amr},
			Outputs:  []operand.Op{amr},
		}, nil
	}
	return nil, errors.New("ADCB: bad operands")
}

// ADCL: Add with Carry.
//
// Forms:
//
// 	ADCL imm32 eax
// 	ADCL imm32 m32
// 	ADCL imm32 r32
// 	ADCL imm8  m32
// 	ADCL imm8  r32
// 	ADCL m32   r32
// 	ADCL r32   m32
// 	ADCL r32   r32
func ADCL(imr, emr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM32(imr) && operand.IsEAX(emr),
		operand.IsIMM32(imr) && operand.IsM32(emr),
		operand.IsIMM32(imr) && operand.IsR32(emr),
		operand.IsIMM8(imr) && operand.IsM32(emr),
		operand.IsIMM8(imr) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:   "ADCL",
			Operands: []operand.Op{imr, emr},
			Inputs:   []operand.Op{emr},
			Outputs:  []operand.Op{emr},
		}, nil
	case operand.IsM32(imr) && operand.IsR32(emr),
		operand.IsR32(imr) && operand.IsM32(emr),
		operand.IsR32(imr) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:   "ADCL",
			Operands: []operand.Op{imr, emr},
			Inputs:   []operand.Op{imr, emr},
			Outputs:  []operand.Op{emr},
		}, nil
	}
	return nil, errors.New("ADCL: bad operands")
}

// ADCQ: Add with Carry.
//
// Forms:
//
// 	ADCQ imm32 m64
// 	ADCQ imm32 r64
// 	ADCQ imm32 rax
// 	ADCQ imm8  m64
// 	ADCQ imm8  r64
// 	ADCQ m64   r64
// 	ADCQ r64   m64
// 	ADCQ r64   r64
func ADCQ(imr, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(imr) && operand.IsR64(mr),
		operand.IsR64(imr) && operand.IsM64(mr),
		operand.IsR64(imr) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "ADCQ",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{imr, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM32(imr) && operand.IsM64(mr),
		operand.IsIMM32(imr) && operand.IsR64(mr),
		operand.IsIMM32(imr) && operand.IsRAX(mr),
		operand.IsIMM8(imr) && operand.IsM64(mr),
		operand.IsIMM8(imr) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "ADCQ",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("ADCQ: bad operands")
}

// ADCW: Add with Carry.
//
// Forms:
//
// 	ADCW imm16 ax
// 	ADCW imm16 m16
// 	ADCW imm16 r16
// 	ADCW imm8  m16
// 	ADCW imm8  r16
// 	ADCW m16   r16
// 	ADCW r16   m16
// 	ADCW r16   r16
func ADCW(imr, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM16(imr) && operand.IsAX(amr),
		operand.IsIMM16(imr) && operand.IsM16(amr),
		operand.IsIMM16(imr) && operand.IsR16(amr),
		operand.IsIMM8(imr) && operand.IsM16(amr),
		operand.IsIMM8(imr) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:   "ADCW",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{amr},
		}, nil
	case operand.IsM16(imr) && operand.IsR16(amr),
		operand.IsR16(imr) && operand.IsM16(amr),
		operand.IsR16(imr) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:   "ADCW",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{imr, amr},
			Outputs:  []operand.Op{amr},
		}, nil
	}
	return nil, errors.New("ADCW: bad operands")
}

// ADCXL: Unsigned Integer Addition of Two Operands with Carry Flag.
//
// Forms:
//
// 	ADCXL m32 r32
// 	ADCXL r32 r32
func ADCXL(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "ADCXL",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"ADX"},
		}, nil
	}
	return nil, errors.New("ADCXL: bad operands")
}

// ADCXQ: Unsigned Integer Addition of Two Operands with Carry Flag.
//
// Forms:
//
// 	ADCXQ m64 r64
// 	ADCXQ r64 r64
func ADCXQ(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "ADCXQ",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"ADX"},
		}, nil
	}
	return nil, errors.New("ADCXQ: bad operands")
}

// ADDB: Add.
//
// Forms:
//
// 	ADDB imm8 al
// 	ADDB imm8 m8
// 	ADDB imm8 r8
// 	ADDB m8   r8
// 	ADDB r8   m8
// 	ADDB r8   r8
func ADDB(imr, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(imr) && operand.IsAL(amr),
		operand.IsIMM8(imr) && operand.IsM8(amr),
		operand.IsIMM8(imr) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:   "ADDB",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{amr},
		}, nil
	case operand.IsM8(imr) && operand.IsR8(amr),
		operand.IsR8(imr) && operand.IsM8(amr),
		operand.IsR8(imr) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:   "ADDB",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{imr, amr},
			Outputs:  []operand.Op{amr},
		}, nil
	}
	return nil, errors.New("ADDB: bad operands")
}

// ADDL: Add.
//
// Forms:
//
// 	ADDL imm32 eax
// 	ADDL imm32 m32
// 	ADDL imm32 r32
// 	ADDL imm8  m32
// 	ADDL imm8  r32
// 	ADDL m32   r32
// 	ADDL r32   m32
// 	ADDL r32   r32
func ADDL(imr, emr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM32(imr) && operand.IsEAX(emr),
		operand.IsIMM32(imr) && operand.IsM32(emr),
		operand.IsIMM32(imr) && operand.IsR32(emr),
		operand.IsIMM8(imr) && operand.IsM32(emr),
		operand.IsIMM8(imr) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:   "ADDL",
			Operands: []operand.Op{imr, emr},
			Inputs:   []operand.Op{emr},
			Outputs:  []operand.Op{emr},
		}, nil
	case operand.IsM32(imr) && operand.IsR32(emr),
		operand.IsR32(imr) && operand.IsM32(emr),
		operand.IsR32(imr) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:   "ADDL",
			Operands: []operand.Op{imr, emr},
			Inputs:   []operand.Op{imr, emr},
			Outputs:  []operand.Op{emr},
		}, nil
	}
	return nil, errors.New("ADDL: bad operands")
}

// ADDPD: Add Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	ADDPD m128 xmm
// 	ADDPD xmm  xmm
func ADDPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ADDPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("ADDPD: bad operands")
}

// ADDPS: Add Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	ADDPS m128 xmm
// 	ADDPS xmm  xmm
func ADDPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ADDPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("ADDPS: bad operands")
}

// ADDQ: Add.
//
// Forms:
//
// 	ADDQ imm32 m64
// 	ADDQ imm32 r64
// 	ADDQ imm32 rax
// 	ADDQ imm8  m64
// 	ADDQ imm8  r64
// 	ADDQ m64   r64
// 	ADDQ r64   m64
// 	ADDQ r64   r64
func ADDQ(imr, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(imr) && operand.IsR64(mr),
		operand.IsR64(imr) && operand.IsM64(mr),
		operand.IsR64(imr) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "ADDQ",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{imr, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM32(imr) && operand.IsM64(mr),
		operand.IsIMM32(imr) && operand.IsR64(mr),
		operand.IsIMM32(imr) && operand.IsRAX(mr),
		operand.IsIMM8(imr) && operand.IsM64(mr),
		operand.IsIMM8(imr) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "ADDQ",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("ADDQ: bad operands")
}

// ADDSD: Add Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	ADDSD m64 xmm
// 	ADDSD xmm xmm
func ADDSD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ADDSD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("ADDSD: bad operands")
}

// ADDSS: Add Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	ADDSS m32 xmm
// 	ADDSS xmm xmm
func ADDSS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ADDSS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("ADDSS: bad operands")
}

// ADDSUBPD: Packed Double-FP Add/Subtract.
//
// Forms:
//
// 	ADDSUBPD m128 xmm
// 	ADDSUBPD xmm  xmm
func ADDSUBPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ADDSUBPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE3"},
		}, nil
	}
	return nil, errors.New("ADDSUBPD: bad operands")
}

// ADDSUBPS: Packed Single-FP Add/Subtract.
//
// Forms:
//
// 	ADDSUBPS m128 xmm
// 	ADDSUBPS xmm  xmm
func ADDSUBPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ADDSUBPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE3"},
		}, nil
	}
	return nil, errors.New("ADDSUBPS: bad operands")
}

// ADDW: Add.
//
// Forms:
//
// 	ADDW imm16 ax
// 	ADDW imm16 m16
// 	ADDW imm16 r16
// 	ADDW imm8  m16
// 	ADDW imm8  r16
// 	ADDW m16   r16
// 	ADDW r16   m16
// 	ADDW r16   r16
func ADDW(imr, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM16(imr) && operand.IsAX(amr),
		operand.IsIMM16(imr) && operand.IsM16(amr),
		operand.IsIMM16(imr) && operand.IsR16(amr),
		operand.IsIMM8(imr) && operand.IsM16(amr),
		operand.IsIMM8(imr) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:   "ADDW",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{amr},
		}, nil
	case operand.IsM16(imr) && operand.IsR16(amr),
		operand.IsR16(imr) && operand.IsM16(amr),
		operand.IsR16(imr) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:   "ADDW",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{imr, amr},
			Outputs:  []operand.Op{amr},
		}, nil
	}
	return nil, errors.New("ADDW: bad operands")
}

// ADOXL: Unsigned Integer Addition of Two Operands with Overflow Flag.
//
// Forms:
//
// 	ADOXL m32 r32
// 	ADOXL r32 r32
func ADOXL(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "ADOXL",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"ADX"},
		}, nil
	}
	return nil, errors.New("ADOXL: bad operands")
}

// ADOXQ: Unsigned Integer Addition of Two Operands with Overflow Flag.
//
// Forms:
//
// 	ADOXQ m64 r64
// 	ADOXQ r64 r64
func ADOXQ(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "ADOXQ",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"ADX"},
		}, nil
	}
	return nil, errors.New("ADOXQ: bad operands")
}

// AESDEC: Perform One Round of an AES Decryption Flow.
//
// Forms:
//
// 	AESDEC m128 xmm
// 	AESDEC xmm  xmm
func AESDEC(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "AESDEC",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AES"},
		}, nil
	}
	return nil, errors.New("AESDEC: bad operands")
}

// AESDECLAST: Perform Last Round of an AES Decryption Flow.
//
// Forms:
//
// 	AESDECLAST m128 xmm
// 	AESDECLAST xmm  xmm
func AESDECLAST(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "AESDECLAST",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AES"},
		}, nil
	}
	return nil, errors.New("AESDECLAST: bad operands")
}

// AESENC: Perform One Round of an AES Encryption Flow.
//
// Forms:
//
// 	AESENC m128 xmm
// 	AESENC xmm  xmm
func AESENC(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "AESENC",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AES"},
		}, nil
	}
	return nil, errors.New("AESENC: bad operands")
}

// AESENCLAST: Perform Last Round of an AES Encryption Flow.
//
// Forms:
//
// 	AESENCLAST m128 xmm
// 	AESENCLAST xmm  xmm
func AESENCLAST(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "AESENCLAST",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AES"},
		}, nil
	}
	return nil, errors.New("AESENCLAST: bad operands")
}

// AESIMC: Perform the AES InvMixColumn Transformation.
//
// Forms:
//
// 	AESIMC m128 xmm
// 	AESIMC xmm  xmm
func AESIMC(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "AESIMC",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AES"},
		}, nil
	}
	return nil, errors.New("AESIMC: bad operands")
}

// AESKEYGENASSIST: AES Round Key Generation Assist.
//
// Forms:
//
// 	AESKEYGENASSIST imm8 m128 xmm
// 	AESKEYGENASSIST imm8 xmm  xmm
func AESKEYGENASSIST(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "AESKEYGENASSIST",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AES"},
		}, nil
	}
	return nil, errors.New("AESKEYGENASSIST: bad operands")
}

// ANDB: Logical AND.
//
// Forms:
//
// 	ANDB imm8 al
// 	ANDB imm8 m8
// 	ANDB imm8 r8
// 	ANDB m8   r8
// 	ANDB r8   m8
// 	ANDB r8   r8
func ANDB(imr, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(imr) && operand.IsAL(amr),
		operand.IsIMM8(imr) && operand.IsM8(amr),
		operand.IsIMM8(imr) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:   "ANDB",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{amr},
		}, nil
	case operand.IsM8(imr) && operand.IsR8(amr),
		operand.IsR8(imr) && operand.IsM8(amr),
		operand.IsR8(imr) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:   "ANDB",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{imr, amr},
			Outputs:  []operand.Op{amr},
		}, nil
	}
	return nil, errors.New("ANDB: bad operands")
}

// ANDL: Logical AND.
//
// Forms:
//
// 	ANDL imm32 eax
// 	ANDL imm32 m32
// 	ANDL imm32 r32
// 	ANDL imm8  m32
// 	ANDL imm8  r32
// 	ANDL m32   r32
// 	ANDL r32   m32
// 	ANDL r32   r32
func ANDL(imr, emr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM32(imr) && operand.IsEAX(emr),
		operand.IsIMM32(imr) && operand.IsM32(emr),
		operand.IsIMM32(imr) && operand.IsR32(emr),
		operand.IsIMM8(imr) && operand.IsM32(emr),
		operand.IsIMM8(imr) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:   "ANDL",
			Operands: []operand.Op{imr, emr},
			Inputs:   []operand.Op{emr},
			Outputs:  []operand.Op{emr},
		}, nil
	case operand.IsM32(imr) && operand.IsR32(emr),
		operand.IsR32(imr) && operand.IsM32(emr),
		operand.IsR32(imr) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:   "ANDL",
			Operands: []operand.Op{imr, emr},
			Inputs:   []operand.Op{imr, emr},
			Outputs:  []operand.Op{emr},
		}, nil
	}
	return nil, errors.New("ANDL: bad operands")
}

// ANDNL: Logical AND NOT.
//
// Forms:
//
// 	ANDNL m32 r32 r32
// 	ANDNL r32 r32 r32
func ANDNL(mr, r, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(mr) && operand.IsR32(r) && operand.IsR32(r1):
		return &intrep.Instruction{
			Opcode:           "ANDNL",
			Operands:         []operand.Op{mr, r, r1},
			Inputs:           []operand.Op{mr, r},
			Outputs:          []operand.Op{r1},
			ISA:              []string{"BMI"},
			CancellingInputs: true,
		}, nil
	case operand.IsM32(mr) && operand.IsR32(r) && operand.IsR32(r1):
		return &intrep.Instruction{
			Opcode:   "ANDNL",
			Operands: []operand.Op{mr, r, r1},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI"},
		}, nil
	}
	return nil, errors.New("ANDNL: bad operands")
}

// ANDNPD: Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	ANDNPD m128 xmm
// 	ANDNPD xmm  xmm
func ANDNPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "ANDNPD",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ANDNPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("ANDNPD: bad operands")
}

// ANDNPS: Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	ANDNPS m128 xmm
// 	ANDNPS xmm  xmm
func ANDNPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "ANDNPS",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ANDNPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("ANDNPS: bad operands")
}

// ANDNQ: Logical AND NOT.
//
// Forms:
//
// 	ANDNQ m64 r64 r64
// 	ANDNQ r64 r64 r64
func ANDNQ(mr, r, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(mr) && operand.IsR64(r) && operand.IsR64(r1):
		return &intrep.Instruction{
			Opcode:           "ANDNQ",
			Operands:         []operand.Op{mr, r, r1},
			Inputs:           []operand.Op{mr, r},
			Outputs:          []operand.Op{r1},
			ISA:              []string{"BMI"},
			CancellingInputs: true,
		}, nil
	case operand.IsM64(mr) && operand.IsR64(r) && operand.IsR64(r1):
		return &intrep.Instruction{
			Opcode:   "ANDNQ",
			Operands: []operand.Op{mr, r, r1},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI"},
		}, nil
	}
	return nil, errors.New("ANDNQ: bad operands")
}

// ANDPD: Bitwise Logical AND of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	ANDPD m128 xmm
// 	ANDPD xmm  xmm
func ANDPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ANDPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("ANDPD: bad operands")
}

// ANDPS: Bitwise Logical AND of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	ANDPS m128 xmm
// 	ANDPS xmm  xmm
func ANDPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ANDPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("ANDPS: bad operands")
}

// ANDQ: Logical AND.
//
// Forms:
//
// 	ANDQ imm32 m64
// 	ANDQ imm32 r64
// 	ANDQ imm32 rax
// 	ANDQ imm8  m64
// 	ANDQ imm8  r64
// 	ANDQ m64   r64
// 	ANDQ r64   m64
// 	ANDQ r64   r64
func ANDQ(imr, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(imr) && operand.IsR64(mr),
		operand.IsR64(imr) && operand.IsM64(mr),
		operand.IsR64(imr) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "ANDQ",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{imr, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM32(imr) && operand.IsM64(mr),
		operand.IsIMM32(imr) && operand.IsR64(mr),
		operand.IsIMM32(imr) && operand.IsRAX(mr),
		operand.IsIMM8(imr) && operand.IsM64(mr),
		operand.IsIMM8(imr) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "ANDQ",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("ANDQ: bad operands")
}

// ANDW: Logical AND.
//
// Forms:
//
// 	ANDW imm16 ax
// 	ANDW imm16 m16
// 	ANDW imm16 r16
// 	ANDW imm8  m16
// 	ANDW imm8  r16
// 	ANDW m16   r16
// 	ANDW r16   m16
// 	ANDW r16   r16
func ANDW(imr, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM16(imr) && operand.IsAX(amr),
		operand.IsIMM16(imr) && operand.IsM16(amr),
		operand.IsIMM16(imr) && operand.IsR16(amr),
		operand.IsIMM8(imr) && operand.IsM16(amr),
		operand.IsIMM8(imr) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:   "ANDW",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{amr},
		}, nil
	case operand.IsM16(imr) && operand.IsR16(amr),
		operand.IsR16(imr) && operand.IsM16(amr),
		operand.IsR16(imr) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:   "ANDW",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{imr, amr},
			Outputs:  []operand.Op{amr},
		}, nil
	}
	return nil, errors.New("ANDW: bad operands")
}

// BEXTRL: Bit Field Extract.
//
// Forms:
//
// 	BEXTRL r32 m32 r32
// 	BEXTRL r32 r32 r32
func BEXTRL(r, mr, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsM32(mr) && operand.IsR32(r1),
		operand.IsR32(r) && operand.IsR32(mr) && operand.IsR32(r1):
		return &intrep.Instruction{
			Opcode:   "BEXTRL",
			Operands: []operand.Op{r, mr, r1},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI"},
		}, nil
	}
	return nil, errors.New("BEXTRL: bad operands")
}

// BEXTRQ: Bit Field Extract.
//
// Forms:
//
// 	BEXTRQ r64 m64 r64
// 	BEXTRQ r64 r64 r64
func BEXTRQ(r, mr, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsM64(mr) && operand.IsR64(r1),
		operand.IsR64(r) && operand.IsR64(mr) && operand.IsR64(r1):
		return &intrep.Instruction{
			Opcode:   "BEXTRQ",
			Operands: []operand.Op{r, mr, r1},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI"},
		}, nil
	}
	return nil, errors.New("BEXTRQ: bad operands")
}

// BLENDPD: Blend Packed Double Precision Floating-Point Values.
//
// Forms:
//
// 	BLENDPD imm8 m128 xmm
// 	BLENDPD imm8 xmm  xmm
func BLENDPD(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "BLENDPD",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("BLENDPD: bad operands")
}

// BLENDPS:  Blend Packed Single Precision Floating-Point Values.
//
// Forms:
//
// 	BLENDPS imm8 m128 xmm
// 	BLENDPS imm8 xmm  xmm
func BLENDPS(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "BLENDPS",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("BLENDPS: bad operands")
}

// BLENDVPD:  Variable Blend Packed Double Precision Floating-Point Values.
//
// Forms:
//
// 	BLENDVPD xmm0 m128 xmm
// 	BLENDVPD xmm0 xmm  xmm
func BLENDVPD(x, mx, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM0(x) && operand.IsM128(mx) && operand.IsXMM(x1),
		operand.IsXMM0(x) && operand.IsXMM(mx) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "BLENDVPD",
			Operands: []operand.Op{x, mx, x1},
			Inputs:   []operand.Op{x, mx, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("BLENDVPD: bad operands")
}

// BLENDVPS:  Variable Blend Packed Single Precision Floating-Point Values.
//
// Forms:
//
// 	BLENDVPS xmm0 m128 xmm
// 	BLENDVPS xmm0 xmm  xmm
func BLENDVPS(x, mx, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM0(x) && operand.IsM128(mx) && operand.IsXMM(x1),
		operand.IsXMM0(x) && operand.IsXMM(mx) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "BLENDVPS",
			Operands: []operand.Op{x, mx, x1},
			Inputs:   []operand.Op{x, mx, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("BLENDVPS: bad operands")
}

// BLSIL: Isolate Lowest Set Bit.
//
// Forms:
//
// 	BLSIL m32 r32
// 	BLSIL r32 r32
func BLSIL(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "BLSIL",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"BMI"},
		}, nil
	}
	return nil, errors.New("BLSIL: bad operands")
}

// BLSIQ: Isolate Lowest Set Bit.
//
// Forms:
//
// 	BLSIQ m64 r64
// 	BLSIQ r64 r64
func BLSIQ(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "BLSIQ",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"BMI"},
		}, nil
	}
	return nil, errors.New("BLSIQ: bad operands")
}

// BLSMSKL: Mask From Lowest Set Bit.
//
// Forms:
//
// 	BLSMSKL m32 r32
// 	BLSMSKL r32 r32
func BLSMSKL(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "BLSMSKL",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"BMI"},
		}, nil
	}
	return nil, errors.New("BLSMSKL: bad operands")
}

// BLSMSKQ: Mask From Lowest Set Bit.
//
// Forms:
//
// 	BLSMSKQ m64 r64
// 	BLSMSKQ r64 r64
func BLSMSKQ(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "BLSMSKQ",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"BMI"},
		}, nil
	}
	return nil, errors.New("BLSMSKQ: bad operands")
}

// BLSRL: Reset Lowest Set Bit.
//
// Forms:
//
// 	BLSRL m32 r32
// 	BLSRL r32 r32
func BLSRL(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "BLSRL",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"BMI"},
		}, nil
	}
	return nil, errors.New("BLSRL: bad operands")
}

// BLSRQ: Reset Lowest Set Bit.
//
// Forms:
//
// 	BLSRQ m64 r64
// 	BLSRQ r64 r64
func BLSRQ(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "BLSRQ",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"BMI"},
		}, nil
	}
	return nil, errors.New("BLSRQ: bad operands")
}

// BSFL: Bit Scan Forward.
//
// Forms:
//
// 	BSFL m32 r32
// 	BSFL r32 r32
func BSFL(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "BSFL",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("BSFL: bad operands")
}

// BSFQ: Bit Scan Forward.
//
// Forms:
//
// 	BSFQ m64 r64
// 	BSFQ r64 r64
func BSFQ(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "BSFQ",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("BSFQ: bad operands")
}

// BSFW: Bit Scan Forward.
//
// Forms:
//
// 	BSFW m16 r16
// 	BSFW r16 r16
func BSFW(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "BSFW",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("BSFW: bad operands")
}

// BSRL: Bit Scan Reverse.
//
// Forms:
//
// 	BSRL m32 r32
// 	BSRL r32 r32
func BSRL(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "BSRL",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("BSRL: bad operands")
}

// BSRQ: Bit Scan Reverse.
//
// Forms:
//
// 	BSRQ m64 r64
// 	BSRQ r64 r64
func BSRQ(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "BSRQ",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("BSRQ: bad operands")
}

// BSRW: Bit Scan Reverse.
//
// Forms:
//
// 	BSRW m16 r16
// 	BSRW r16 r16
func BSRW(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "BSRW",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("BSRW: bad operands")
}

// BSWAPL: Byte Swap.
//
// Forms:
//
// 	BSWAPL r32
func BSWAPL(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "BSWAPL",
			Operands: []operand.Op{r},
			Inputs:   []operand.Op{r},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("BSWAPL: bad operands")
}

// BSWAPQ: Byte Swap.
//
// Forms:
//
// 	BSWAPQ r64
func BSWAPQ(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "BSWAPQ",
			Operands: []operand.Op{r},
			Inputs:   []operand.Op{r},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("BSWAPQ: bad operands")
}

// BTCL: Bit Test and Complement.
//
// Forms:
//
// 	BTCL imm8 m32
// 	BTCL imm8 r32
// 	BTCL r32  m32
// 	BTCL r32  r32
func BTCL(ir, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(ir) && operand.IsM32(mr),
		operand.IsR32(ir) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "BTCL",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{ir, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM8(ir) && operand.IsM32(mr),
		operand.IsIMM8(ir) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "BTCL",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("BTCL: bad operands")
}

// BTCQ: Bit Test and Complement.
//
// Forms:
//
// 	BTCQ imm8 m64
// 	BTCQ imm8 r64
// 	BTCQ r64  m64
// 	BTCQ r64  r64
func BTCQ(ir, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(ir) && operand.IsM64(mr),
		operand.IsR64(ir) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "BTCQ",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{ir, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM8(ir) && operand.IsM64(mr),
		operand.IsIMM8(ir) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "BTCQ",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("BTCQ: bad operands")
}

// BTCW: Bit Test and Complement.
//
// Forms:
//
// 	BTCW imm8 m16
// 	BTCW imm8 r16
// 	BTCW r16  m16
// 	BTCW r16  r16
func BTCW(ir, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR16(ir) && operand.IsM16(mr),
		operand.IsR16(ir) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "BTCW",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{ir, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM8(ir) && operand.IsM16(mr),
		operand.IsIMM8(ir) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "BTCW",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("BTCW: bad operands")
}

// BTL: Bit Test.
//
// Forms:
//
// 	BTL imm8 m32
// 	BTL imm8 r32
// 	BTL r32  m32
// 	BTL r32  r32
func BTL(ir, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(ir) && operand.IsM32(mr),
		operand.IsR32(ir) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "BTL",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{ir, mr},
			Outputs:  []operand.Op{},
		}, nil
	case operand.IsIMM8(ir) && operand.IsM32(mr),
		operand.IsIMM8(ir) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "BTL",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("BTL: bad operands")
}

// BTQ: Bit Test.
//
// Forms:
//
// 	BTQ imm8 m64
// 	BTQ imm8 r64
// 	BTQ r64  m64
// 	BTQ r64  r64
func BTQ(ir, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(ir) && operand.IsM64(mr),
		operand.IsR64(ir) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "BTQ",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{ir, mr},
			Outputs:  []operand.Op{},
		}, nil
	case operand.IsIMM8(ir) && operand.IsM64(mr),
		operand.IsIMM8(ir) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "BTQ",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("BTQ: bad operands")
}

// BTRL: Bit Test and Reset.
//
// Forms:
//
// 	BTRL imm8 m32
// 	BTRL imm8 r32
// 	BTRL r32  m32
// 	BTRL r32  r32
func BTRL(ir, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(ir) && operand.IsM32(mr),
		operand.IsR32(ir) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "BTRL",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{ir, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM8(ir) && operand.IsM32(mr),
		operand.IsIMM8(ir) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "BTRL",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("BTRL: bad operands")
}

// BTRQ: Bit Test and Reset.
//
// Forms:
//
// 	BTRQ imm8 m64
// 	BTRQ imm8 r64
// 	BTRQ r64  m64
// 	BTRQ r64  r64
func BTRQ(ir, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(ir) && operand.IsM64(mr),
		operand.IsR64(ir) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "BTRQ",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{ir, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM8(ir) && operand.IsM64(mr),
		operand.IsIMM8(ir) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "BTRQ",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("BTRQ: bad operands")
}

// BTRW: Bit Test and Reset.
//
// Forms:
//
// 	BTRW imm8 m16
// 	BTRW imm8 r16
// 	BTRW r16  m16
// 	BTRW r16  r16
func BTRW(ir, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR16(ir) && operand.IsM16(mr),
		operand.IsR16(ir) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "BTRW",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{ir, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM8(ir) && operand.IsM16(mr),
		operand.IsIMM8(ir) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "BTRW",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("BTRW: bad operands")
}

// BTSL: Bit Test and Set.
//
// Forms:
//
// 	BTSL imm8 m32
// 	BTSL imm8 r32
// 	BTSL r32  m32
// 	BTSL r32  r32
func BTSL(ir, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(ir) && operand.IsM32(mr),
		operand.IsR32(ir) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "BTSL",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{ir, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM8(ir) && operand.IsM32(mr),
		operand.IsIMM8(ir) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "BTSL",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("BTSL: bad operands")
}

// BTSQ: Bit Test and Set.
//
// Forms:
//
// 	BTSQ imm8 m64
// 	BTSQ imm8 r64
// 	BTSQ r64  m64
// 	BTSQ r64  r64
func BTSQ(ir, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(ir) && operand.IsM64(mr),
		operand.IsR64(ir) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "BTSQ",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{ir, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM8(ir) && operand.IsM64(mr),
		operand.IsIMM8(ir) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "BTSQ",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("BTSQ: bad operands")
}

// BTSW: Bit Test and Set.
//
// Forms:
//
// 	BTSW imm8 m16
// 	BTSW imm8 r16
// 	BTSW r16  m16
// 	BTSW r16  r16
func BTSW(ir, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR16(ir) && operand.IsM16(mr),
		operand.IsR16(ir) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "BTSW",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{ir, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM8(ir) && operand.IsM16(mr),
		operand.IsIMM8(ir) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "BTSW",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("BTSW: bad operands")
}

// BTW: Bit Test.
//
// Forms:
//
// 	BTW imm8 m16
// 	BTW imm8 r16
// 	BTW r16  m16
// 	BTW r16  r16
func BTW(ir, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR16(ir) && operand.IsM16(mr),
		operand.IsR16(ir) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "BTW",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{ir, mr},
			Outputs:  []operand.Op{},
		}, nil
	case operand.IsIMM8(ir) && operand.IsM16(mr),
		operand.IsIMM8(ir) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "BTW",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("BTW: bad operands")
}

// BZHIL: Zero High Bits Starting with Specified Bit Position.
//
// Forms:
//
// 	BZHIL r32 m32 r32
// 	BZHIL r32 r32 r32
func BZHIL(r, mr, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsM32(mr) && operand.IsR32(r1),
		operand.IsR32(r) && operand.IsR32(mr) && operand.IsR32(r1):
		return &intrep.Instruction{
			Opcode:   "BZHIL",
			Operands: []operand.Op{r, mr, r1},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("BZHIL: bad operands")
}

// BZHIQ: Zero High Bits Starting with Specified Bit Position.
//
// Forms:
//
// 	BZHIQ r64 m64 r64
// 	BZHIQ r64 r64 r64
func BZHIQ(r, mr, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsM64(mr) && operand.IsR64(r1),
		operand.IsR64(r) && operand.IsR64(mr) && operand.IsR64(r1):
		return &intrep.Instruction{
			Opcode:   "BZHIQ",
			Operands: []operand.Op{r, mr, r1},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("BZHIQ: bad operands")
}

// CALL: Call Procedure.
//
// Forms:
//
// 	CALL rel32
func CALL(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r):
		return &intrep.Instruction{
			Opcode:   "CALL",
			Operands: []operand.Op{r},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("CALL: bad operands")
}

// CBW: Convert Byte to Word.
//
// Forms:
//
// 	CBW
func CBW() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "CBW",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{reg.AL},
		Outputs:  []operand.Op{reg.AX},
	}, nil
}

// CDQ: Convert Doubleword to Quadword.
//
// Forms:
//
// 	CDQ
func CDQ() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "CDQ",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{reg.EAX},
		Outputs:  []operand.Op{reg.EDX},
	}, nil
}

// CDQE: Convert Doubleword to Quadword.
//
// Forms:
//
// 	CDQE
func CDQE() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "CDQE",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{reg.EAX},
		Outputs:  []operand.Op{reg.RAX},
	}, nil
}

// CLC: Clear Carry Flag.
//
// Forms:
//
// 	CLC
func CLC() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "CLC",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{},
	}, nil
}

// CLD: Clear Direction Flag.
//
// Forms:
//
// 	CLD
func CLD() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "CLD",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{},
	}, nil
}

// CLFLUSH: Flush Cache Line.
//
// Forms:
//
// 	CLFLUSH m8
func CLFLUSH(m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(m):
		return &intrep.Instruction{
			Opcode:   "CLFLUSH",
			Operands: []operand.Op{m},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{},
			ISA:      []string{"CLFLUSH"},
		}, nil
	}
	return nil, errors.New("CLFLUSH: bad operands")
}

// CLFLUSHOPT: Flush Cache Line Optimized.
//
// Forms:
//
// 	CLFLUSHOPT m8
func CLFLUSHOPT(m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(m):
		return &intrep.Instruction{
			Opcode:   "CLFLUSHOPT",
			Operands: []operand.Op{m},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{},
			ISA:      []string{"CLFLUSHOPT"},
		}, nil
	}
	return nil, errors.New("CLFLUSHOPT: bad operands")
}

// CMC: Complement Carry Flag.
//
// Forms:
//
// 	CMC
func CMC() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "CMC",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{},
	}, nil
}

// CMOVLCC: Move if above or equal (CF == 0).
//
// Forms:
//
// 	CMOVLCC m32 r32
// 	CMOVLCC r32 r32
func CMOVLCC(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLCC",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLCC: bad operands")
}

// CMOVLCS: Move if below (CF == 1).
//
// Forms:
//
// 	CMOVLCS m32 r32
// 	CMOVLCS r32 r32
func CMOVLCS(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLCS",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLCS: bad operands")
}

// CMOVLEQ: Move if equal (ZF == 1).
//
// Forms:
//
// 	CMOVLEQ m32 r32
// 	CMOVLEQ r32 r32
func CMOVLEQ(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLEQ",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLEQ: bad operands")
}

// CMOVLGE: Move if greater or equal (SF == OF).
//
// Forms:
//
// 	CMOVLGE m32 r32
// 	CMOVLGE r32 r32
func CMOVLGE(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLGE",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLGE: bad operands")
}

// CMOVLGT: Move if greater (ZF == 0 and SF == OF).
//
// Forms:
//
// 	CMOVLGT m32 r32
// 	CMOVLGT r32 r32
func CMOVLGT(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLGT",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLGT: bad operands")
}

// CMOVLHI: Move if above (CF == 0 and ZF == 0).
//
// Forms:
//
// 	CMOVLHI m32 r32
// 	CMOVLHI r32 r32
func CMOVLHI(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLHI",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLHI: bad operands")
}

// CMOVLLE: Move if less or equal (ZF == 1 or SF != OF).
//
// Forms:
//
// 	CMOVLLE m32 r32
// 	CMOVLLE r32 r32
func CMOVLLE(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLLE",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLLE: bad operands")
}

// CMOVLLS: Move if below or equal (CF == 1 or ZF == 1).
//
// Forms:
//
// 	CMOVLLS m32 r32
// 	CMOVLLS r32 r32
func CMOVLLS(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLLS",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLLS: bad operands")
}

// CMOVLLT: Move if less (SF != OF).
//
// Forms:
//
// 	CMOVLLT m32 r32
// 	CMOVLLT r32 r32
func CMOVLLT(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLLT",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLLT: bad operands")
}

// CMOVLMI: Move if sign (SF == 1).
//
// Forms:
//
// 	CMOVLMI m32 r32
// 	CMOVLMI r32 r32
func CMOVLMI(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLMI",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLMI: bad operands")
}

// CMOVLNE: Move if not equal (ZF == 0).
//
// Forms:
//
// 	CMOVLNE m32 r32
// 	CMOVLNE r32 r32
func CMOVLNE(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLNE",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLNE: bad operands")
}

// CMOVLOC: Move if not overflow (OF == 0).
//
// Forms:
//
// 	CMOVLOC m32 r32
// 	CMOVLOC r32 r32
func CMOVLOC(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLOC",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLOC: bad operands")
}

// CMOVLOS: Move if overflow (OF == 1).
//
// Forms:
//
// 	CMOVLOS m32 r32
// 	CMOVLOS r32 r32
func CMOVLOS(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLOS",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLOS: bad operands")
}

// CMOVLPC: Move if not parity (PF == 0).
//
// Forms:
//
// 	CMOVLPC m32 r32
// 	CMOVLPC r32 r32
func CMOVLPC(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLPC",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLPC: bad operands")
}

// CMOVLPL: Move if not sign (SF == 0).
//
// Forms:
//
// 	CMOVLPL m32 r32
// 	CMOVLPL r32 r32
func CMOVLPL(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLPL",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLPL: bad operands")
}

// CMOVLPS: Move if parity (PF == 1).
//
// Forms:
//
// 	CMOVLPS m32 r32
// 	CMOVLPS r32 r32
func CMOVLPS(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CMOVLPS",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVLPS: bad operands")
}

// CMOVQCC: Move if above or equal (CF == 0).
//
// Forms:
//
// 	CMOVQCC m64 r64
// 	CMOVQCC r64 r64
func CMOVQCC(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQCC",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQCC: bad operands")
}

// CMOVQCS: Move if below (CF == 1).
//
// Forms:
//
// 	CMOVQCS m64 r64
// 	CMOVQCS r64 r64
func CMOVQCS(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQCS",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQCS: bad operands")
}

// CMOVQEQ: Move if equal (ZF == 1).
//
// Forms:
//
// 	CMOVQEQ m64 r64
// 	CMOVQEQ r64 r64
func CMOVQEQ(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQEQ",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQEQ: bad operands")
}

// CMOVQGE: Move if greater or equal (SF == OF).
//
// Forms:
//
// 	CMOVQGE m64 r64
// 	CMOVQGE r64 r64
func CMOVQGE(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQGE",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQGE: bad operands")
}

// CMOVQGT: Move if greater (ZF == 0 and SF == OF).
//
// Forms:
//
// 	CMOVQGT m64 r64
// 	CMOVQGT r64 r64
func CMOVQGT(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQGT",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQGT: bad operands")
}

// CMOVQHI: Move if above (CF == 0 and ZF == 0).
//
// Forms:
//
// 	CMOVQHI m64 r64
// 	CMOVQHI r64 r64
func CMOVQHI(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQHI",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQHI: bad operands")
}

// CMOVQLE: Move if less or equal (ZF == 1 or SF != OF).
//
// Forms:
//
// 	CMOVQLE m64 r64
// 	CMOVQLE r64 r64
func CMOVQLE(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQLE",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQLE: bad operands")
}

// CMOVQLS: Move if below or equal (CF == 1 or ZF == 1).
//
// Forms:
//
// 	CMOVQLS m64 r64
// 	CMOVQLS r64 r64
func CMOVQLS(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQLS",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQLS: bad operands")
}

// CMOVQLT: Move if less (SF != OF).
//
// Forms:
//
// 	CMOVQLT m64 r64
// 	CMOVQLT r64 r64
func CMOVQLT(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQLT",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQLT: bad operands")
}

// CMOVQMI: Move if sign (SF == 1).
//
// Forms:
//
// 	CMOVQMI m64 r64
// 	CMOVQMI r64 r64
func CMOVQMI(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQMI",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQMI: bad operands")
}

// CMOVQNE: Move if not equal (ZF == 0).
//
// Forms:
//
// 	CMOVQNE m64 r64
// 	CMOVQNE r64 r64
func CMOVQNE(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQNE",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQNE: bad operands")
}

// CMOVQOC: Move if not overflow (OF == 0).
//
// Forms:
//
// 	CMOVQOC m64 r64
// 	CMOVQOC r64 r64
func CMOVQOC(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQOC",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQOC: bad operands")
}

// CMOVQOS: Move if overflow (OF == 1).
//
// Forms:
//
// 	CMOVQOS m64 r64
// 	CMOVQOS r64 r64
func CMOVQOS(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQOS",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQOS: bad operands")
}

// CMOVQPC: Move if not parity (PF == 0).
//
// Forms:
//
// 	CMOVQPC m64 r64
// 	CMOVQPC r64 r64
func CMOVQPC(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQPC",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQPC: bad operands")
}

// CMOVQPL: Move if not sign (SF == 0).
//
// Forms:
//
// 	CMOVQPL m64 r64
// 	CMOVQPL r64 r64
func CMOVQPL(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQPL",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQPL: bad operands")
}

// CMOVQPS: Move if parity (PF == 1).
//
// Forms:
//
// 	CMOVQPS m64 r64
// 	CMOVQPS r64 r64
func CMOVQPS(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CMOVQPS",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVQPS: bad operands")
}

// CMOVWCC: Move if above or equal (CF == 0).
//
// Forms:
//
// 	CMOVWCC m16 r16
// 	CMOVWCC r16 r16
func CMOVWCC(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWCC",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWCC: bad operands")
}

// CMOVWCS: Move if below (CF == 1).
//
// Forms:
//
// 	CMOVWCS m16 r16
// 	CMOVWCS r16 r16
func CMOVWCS(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWCS",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWCS: bad operands")
}

// CMOVWEQ: Move if equal (ZF == 1).
//
// Forms:
//
// 	CMOVWEQ m16 r16
// 	CMOVWEQ r16 r16
func CMOVWEQ(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWEQ",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWEQ: bad operands")
}

// CMOVWGE: Move if greater or equal (SF == OF).
//
// Forms:
//
// 	CMOVWGE m16 r16
// 	CMOVWGE r16 r16
func CMOVWGE(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWGE",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWGE: bad operands")
}

// CMOVWGT: Move if greater (ZF == 0 and SF == OF).
//
// Forms:
//
// 	CMOVWGT m16 r16
// 	CMOVWGT r16 r16
func CMOVWGT(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWGT",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWGT: bad operands")
}

// CMOVWHI: Move if above (CF == 0 and ZF == 0).
//
// Forms:
//
// 	CMOVWHI m16 r16
// 	CMOVWHI r16 r16
func CMOVWHI(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWHI",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWHI: bad operands")
}

// CMOVWLE: Move if less or equal (ZF == 1 or SF != OF).
//
// Forms:
//
// 	CMOVWLE m16 r16
// 	CMOVWLE r16 r16
func CMOVWLE(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWLE",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWLE: bad operands")
}

// CMOVWLS: Move if below or equal (CF == 1 or ZF == 1).
//
// Forms:
//
// 	CMOVWLS m16 r16
// 	CMOVWLS r16 r16
func CMOVWLS(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWLS",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWLS: bad operands")
}

// CMOVWLT: Move if less (SF != OF).
//
// Forms:
//
// 	CMOVWLT m16 r16
// 	CMOVWLT r16 r16
func CMOVWLT(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWLT",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWLT: bad operands")
}

// CMOVWMI: Move if sign (SF == 1).
//
// Forms:
//
// 	CMOVWMI m16 r16
// 	CMOVWMI r16 r16
func CMOVWMI(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWMI",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWMI: bad operands")
}

// CMOVWNE: Move if not equal (ZF == 0).
//
// Forms:
//
// 	CMOVWNE m16 r16
// 	CMOVWNE r16 r16
func CMOVWNE(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWNE",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWNE: bad operands")
}

// CMOVWOC: Move if not overflow (OF == 0).
//
// Forms:
//
// 	CMOVWOC m16 r16
// 	CMOVWOC r16 r16
func CMOVWOC(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWOC",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWOC: bad operands")
}

// CMOVWOS: Move if overflow (OF == 1).
//
// Forms:
//
// 	CMOVWOS m16 r16
// 	CMOVWOS r16 r16
func CMOVWOS(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWOS",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWOS: bad operands")
}

// CMOVWPC: Move if not parity (PF == 0).
//
// Forms:
//
// 	CMOVWPC m16 r16
// 	CMOVWPC r16 r16
func CMOVWPC(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWPC",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWPC: bad operands")
}

// CMOVWPL: Move if not sign (SF == 0).
//
// Forms:
//
// 	CMOVWPL m16 r16
// 	CMOVWPL r16 r16
func CMOVWPL(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWPL",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWPL: bad operands")
}

// CMOVWPS: Move if parity (PF == 1).
//
// Forms:
//
// 	CMOVWPS m16 r16
// 	CMOVWPS r16 r16
func CMOVWPS(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "CMOVWPS",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"CMOV"},
		}, nil
	}
	return nil, errors.New("CMOVWPS: bad operands")
}

// CMPB: Compare Two Operands.
//
// Forms:
//
// 	CMPB al imm8
// 	CMPB m8 imm8
// 	CMPB m8 r8
// 	CMPB r8 imm8
// 	CMPB r8 m8
// 	CMPB r8 r8
func CMPB(amr, imr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR8(amr) && operand.IsR8(imr):
		return &intrep.Instruction{
			Opcode:           "CMPB",
			Operands:         []operand.Op{amr, imr},
			Inputs:           []operand.Op{amr, imr},
			Outputs:          []operand.Op{},
			CancellingInputs: true,
		}, nil
	case operand.IsM8(amr) && operand.IsR8(imr),
		operand.IsR8(amr) && operand.IsM8(imr):
		return &intrep.Instruction{
			Opcode:   "CMPB",
			Operands: []operand.Op{amr, imr},
			Inputs:   []operand.Op{amr, imr},
			Outputs:  []operand.Op{},
		}, nil
	case operand.IsAL(amr) && operand.IsIMM8(imr),
		operand.IsM8(amr) && operand.IsIMM8(imr),
		operand.IsR8(amr) && operand.IsIMM8(imr):
		return &intrep.Instruction{
			Opcode:   "CMPB",
			Operands: []operand.Op{amr, imr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("CMPB: bad operands")
}

// CMPL: Compare Two Operands.
//
// Forms:
//
// 	CMPL eax imm32
// 	CMPL m32 imm32
// 	CMPL m32 imm8
// 	CMPL m32 r32
// 	CMPL r32 imm32
// 	CMPL r32 imm8
// 	CMPL r32 m32
// 	CMPL r32 r32
func CMPL(emr, imr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(emr) && operand.IsR32(imr):
		return &intrep.Instruction{
			Opcode:           "CMPL",
			Operands:         []operand.Op{emr, imr},
			Inputs:           []operand.Op{emr, imr},
			Outputs:          []operand.Op{},
			CancellingInputs: true,
		}, nil
	case operand.IsM32(emr) && operand.IsR32(imr),
		operand.IsR32(emr) && operand.IsM32(imr):
		return &intrep.Instruction{
			Opcode:   "CMPL",
			Operands: []operand.Op{emr, imr},
			Inputs:   []operand.Op{emr, imr},
			Outputs:  []operand.Op{},
		}, nil
	case operand.IsEAX(emr) && operand.IsIMM32(imr),
		operand.IsM32(emr) && operand.IsIMM32(imr),
		operand.IsM32(emr) && operand.IsIMM8(imr),
		operand.IsR32(emr) && operand.IsIMM32(imr),
		operand.IsR32(emr) && operand.IsIMM8(imr):
		return &intrep.Instruction{
			Opcode:   "CMPL",
			Operands: []operand.Op{emr, imr},
			Inputs:   []operand.Op{emr},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("CMPL: bad operands")
}

// CMPPD: Compare Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	CMPPD m128 xmm imm8
// 	CMPPD xmm  xmm imm8
func CMPPD(mx, x, i operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x) && operand.IsIMM8(i),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsIMM8(i):
		return &intrep.Instruction{
			Opcode:   "CMPPD",
			Operands: []operand.Op{mx, x, i},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CMPPD: bad operands")
}

// CMPPS: Compare Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	CMPPS m128 xmm imm8
// 	CMPPS xmm  xmm imm8
func CMPPS(mx, x, i operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x) && operand.IsIMM8(i),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsIMM8(i):
		return &intrep.Instruction{
			Opcode:   "CMPPS",
			Operands: []operand.Op{mx, x, i},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("CMPPS: bad operands")
}

// CMPQ: Compare Two Operands.
//
// Forms:
//
// 	CMPQ m64 imm32
// 	CMPQ m64 imm8
// 	CMPQ m64 r64
// 	CMPQ r64 imm32
// 	CMPQ r64 imm8
// 	CMPQ r64 m64
// 	CMPQ r64 r64
// 	CMPQ rax imm32
func CMPQ(mr, imr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(mr) && operand.IsR64(imr):
		return &intrep.Instruction{
			Opcode:           "CMPQ",
			Operands:         []operand.Op{mr, imr},
			Inputs:           []operand.Op{mr, imr},
			Outputs:          []operand.Op{},
			CancellingInputs: true,
		}, nil
	case operand.IsM64(mr) && operand.IsR64(imr),
		operand.IsR64(mr) && operand.IsM64(imr):
		return &intrep.Instruction{
			Opcode:   "CMPQ",
			Operands: []operand.Op{mr, imr},
			Inputs:   []operand.Op{mr, imr},
			Outputs:  []operand.Op{},
		}, nil
	case operand.IsM64(mr) && operand.IsIMM32(imr),
		operand.IsM64(mr) && operand.IsIMM8(imr),
		operand.IsR64(mr) && operand.IsIMM32(imr),
		operand.IsR64(mr) && operand.IsIMM8(imr),
		operand.IsRAX(mr) && operand.IsIMM32(imr):
		return &intrep.Instruction{
			Opcode:   "CMPQ",
			Operands: []operand.Op{mr, imr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("CMPQ: bad operands")
}

// CMPSD: Compare Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	CMPSD m64 xmm imm8
// 	CMPSD xmm xmm imm8
func CMPSD(mx, x, i operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsIMM8(i),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsIMM8(i):
		return &intrep.Instruction{
			Opcode:   "CMPSD",
			Operands: []operand.Op{mx, x, i},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CMPSD: bad operands")
}

// CMPSS: Compare Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	CMPSS m32 xmm imm8
// 	CMPSS xmm xmm imm8
func CMPSS(mx, x, i operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsIMM8(i),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsIMM8(i):
		return &intrep.Instruction{
			Opcode:   "CMPSS",
			Operands: []operand.Op{mx, x, i},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("CMPSS: bad operands")
}

// CMPW: Compare Two Operands.
//
// Forms:
//
// 	CMPW ax  imm16
// 	CMPW m16 imm16
// 	CMPW m16 imm8
// 	CMPW m16 r16
// 	CMPW r16 imm16
// 	CMPW r16 imm8
// 	CMPW r16 m16
// 	CMPW r16 r16
func CMPW(amr, imr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR16(amr) && operand.IsR16(imr):
		return &intrep.Instruction{
			Opcode:           "CMPW",
			Operands:         []operand.Op{amr, imr},
			Inputs:           []operand.Op{amr, imr},
			Outputs:          []operand.Op{},
			CancellingInputs: true,
		}, nil
	case operand.IsM16(amr) && operand.IsR16(imr),
		operand.IsR16(amr) && operand.IsM16(imr):
		return &intrep.Instruction{
			Opcode:   "CMPW",
			Operands: []operand.Op{amr, imr},
			Inputs:   []operand.Op{amr, imr},
			Outputs:  []operand.Op{},
		}, nil
	case operand.IsAX(amr) && operand.IsIMM16(imr),
		operand.IsM16(amr) && operand.IsIMM16(imr),
		operand.IsM16(amr) && operand.IsIMM8(imr),
		operand.IsR16(amr) && operand.IsIMM16(imr),
		operand.IsR16(amr) && operand.IsIMM8(imr):
		return &intrep.Instruction{
			Opcode:   "CMPW",
			Operands: []operand.Op{amr, imr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("CMPW: bad operands")
}

// CMPXCHG16B: Compare and Exchange 16 Bytes.
//
// Forms:
//
// 	CMPXCHG16B m128
func CMPXCHG16B(m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(m):
		return &intrep.Instruction{
			Opcode:   "CMPXCHG16B",
			Operands: []operand.Op{m},
			Inputs:   []operand.Op{m, reg.RAX, reg.RBX, reg.RCX, reg.RDX},
			Outputs:  []operand.Op{reg.RAX, reg.RDX},
		}, nil
	}
	return nil, errors.New("CMPXCHG16B: bad operands")
}

// CMPXCHG8B: Compare and Exchange 8 Bytes.
//
// Forms:
//
// 	CMPXCHG8B m64
func CMPXCHG8B(m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m):
		return &intrep.Instruction{
			Opcode:   "CMPXCHG8B",
			Operands: []operand.Op{m},
			Inputs:   []operand.Op{m, reg.EAX, reg.EBX, reg.ECX, reg.EDX},
			Outputs:  []operand.Op{reg.EAX, reg.EDX},
		}, nil
	}
	return nil, errors.New("CMPXCHG8B: bad operands")
}

// CMPXCHGB: Compare and Exchange.
//
// Forms:
//
// 	CMPXCHGB r8 m8
// 	CMPXCHGB r8 r8
func CMPXCHGB(r, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR8(r) && operand.IsM8(mr),
		operand.IsR8(r) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "CMPXCHGB",
			Operands: []operand.Op{r, mr},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("CMPXCHGB: bad operands")
}

// CMPXCHGL: Compare and Exchange.
//
// Forms:
//
// 	CMPXCHGL r32 m32
// 	CMPXCHGL r32 r32
func CMPXCHGL(r, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsM32(mr),
		operand.IsR32(r) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "CMPXCHGL",
			Operands: []operand.Op{r, mr},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("CMPXCHGL: bad operands")
}

// CMPXCHGQ: Compare and Exchange.
//
// Forms:
//
// 	CMPXCHGQ r64 m64
// 	CMPXCHGQ r64 r64
func CMPXCHGQ(r, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsM64(mr),
		operand.IsR64(r) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "CMPXCHGQ",
			Operands: []operand.Op{r, mr},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("CMPXCHGQ: bad operands")
}

// CMPXCHGW: Compare and Exchange.
//
// Forms:
//
// 	CMPXCHGW r16 m16
// 	CMPXCHGW r16 r16
func CMPXCHGW(r, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR16(r) && operand.IsM16(mr),
		operand.IsR16(r) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "CMPXCHGW",
			Operands: []operand.Op{r, mr},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("CMPXCHGW: bad operands")
}

// COMISD: Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS.
//
// Forms:
//
// 	COMISD m64 xmm
// 	COMISD xmm xmm
func COMISD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "COMISD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("COMISD: bad operands")
}

// COMISS: Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS.
//
// Forms:
//
// 	COMISS m32 xmm
// 	COMISS xmm xmm
func COMISS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "COMISS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("COMISS: bad operands")
}

// CPUID: CPU Identification.
//
// Forms:
//
// 	CPUID
func CPUID() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "CPUID",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{reg.EAX, reg.ECX},
		Outputs:  []operand.Op{reg.EAX, reg.EBX, reg.ECX, reg.EDX},
		ISA:      []string{"CPUID"},
	}, nil
}

// CQO: Convert Quadword to Octaword.
//
// Forms:
//
// 	CQO
func CQO() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "CQO",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{reg.RAX},
		Outputs:  []operand.Op{reg.RDX},
	}, nil
}

// CRC32B: Accumulate CRC32 Value.
//
// Forms:
//
// 	CRC32B m8 r32
// 	CRC32B m8 r64
// 	CRC32B r8 r32
// 	CRC32B r8 r64
func CRC32B(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr) && operand.IsR32(r),
		operand.IsM8(mr) && operand.IsR64(r),
		operand.IsR8(mr) && operand.IsR32(r),
		operand.IsR8(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CRC32B",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"SSE4.2"},
		}, nil
	}
	return nil, errors.New("CRC32B: bad operands")
}

// CRC32L: Accumulate CRC32 Value.
//
// Forms:
//
// 	CRC32L m32 r32
// 	CRC32L r32 r32
func CRC32L(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CRC32L",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"SSE4.2"},
		}, nil
	}
	return nil, errors.New("CRC32L: bad operands")
}

// CRC32Q: Accumulate CRC32 Value.
//
// Forms:
//
// 	CRC32Q m64 r64
// 	CRC32Q r64 r64
func CRC32Q(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CRC32Q",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"SSE4.2"},
		}, nil
	}
	return nil, errors.New("CRC32Q: bad operands")
}

// CRC32W: Accumulate CRC32 Value.
//
// Forms:
//
// 	CRC32W m16 r32
// 	CRC32W r16 r32
func CRC32W(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR32(r),
		operand.IsR16(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CRC32W",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r},
			ISA:      []string{"SSE4.2"},
		}, nil
	}
	return nil, errors.New("CRC32W: bad operands")
}

// CVTPD2PL: Convert Packed Double-Precision FP Values to Packed Dword Integers.
//
// Forms:
//
// 	CVTPD2PL m128 xmm
// 	CVTPD2PL xmm  xmm
func CVTPD2PL(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "CVTPD2PL",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTPD2PL: bad operands")
}

// CVTPD2PS: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values.
//
// Forms:
//
// 	CVTPD2PS m128 xmm
// 	CVTPD2PS xmm  xmm
func CVTPD2PS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "CVTPD2PS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTPD2PS: bad operands")
}

// CVTPL2PD: Convert Packed Dword Integers to Packed Double-Precision FP Values.
//
// Forms:
//
// 	CVTPL2PD m64 xmm
// 	CVTPL2PD xmm xmm
func CVTPL2PD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "CVTPL2PD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTPL2PD: bad operands")
}

// CVTPL2PS: Convert Packed Dword Integers to Packed Single-Precision FP Values.
//
// Forms:
//
// 	CVTPL2PS m128 xmm
// 	CVTPL2PS xmm  xmm
func CVTPL2PS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "CVTPL2PS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTPL2PS: bad operands")
}

// CVTPS2PD: Convert Packed Single-Precision FP Values to Packed Double-Precision FP Values.
//
// Forms:
//
// 	CVTPS2PD m64 xmm
// 	CVTPS2PD xmm xmm
func CVTPS2PD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "CVTPS2PD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTPS2PD: bad operands")
}

// CVTPS2PL: Convert Packed Single-Precision FP Values to Packed Dword Integers.
//
// Forms:
//
// 	CVTPS2PL m128 xmm
// 	CVTPS2PL xmm  xmm
func CVTPS2PL(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "CVTPS2PL",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTPS2PL: bad operands")
}

// CVTSD2SL: Convert Scalar Double-Precision FP Value to Integer.
//
// Forms:
//
// 	CVTSD2SL m64 r32
// 	CVTSD2SL m64 r64
// 	CVTSD2SL xmm r32
// 	CVTSD2SL xmm r64
func CVTSD2SL(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsR32(r),
		operand.IsM64(mx) && operand.IsR64(r),
		operand.IsXMM(mx) && operand.IsR32(r),
		operand.IsXMM(mx) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CVTSD2SL",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTSD2SL: bad operands")
}

// CVTSD2SS: Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value.
//
// Forms:
//
// 	CVTSD2SS m64 xmm
// 	CVTSD2SS xmm xmm
func CVTSD2SS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "CVTSD2SS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTSD2SS: bad operands")
}

// CVTSL2SD: Convert Dword Integer to Scalar Double-Precision FP Value.
//
// Forms:
//
// 	CVTSL2SD m32 xmm
// 	CVTSL2SD r32 xmm
func CVTSL2SD(mr, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsXMM(x),
		operand.IsR32(mr) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "CVTSL2SD",
			Operands: []operand.Op{mr, x},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTSL2SD: bad operands")
}

// CVTSL2SS: Convert Dword Integer to Scalar Single-Precision FP Value.
//
// Forms:
//
// 	CVTSL2SS m32 xmm
// 	CVTSL2SS r32 xmm
func CVTSL2SS(mr, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsXMM(x),
		operand.IsR32(mr) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "CVTSL2SS",
			Operands: []operand.Op{mr, x},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("CVTSL2SS: bad operands")
}

// CVTSQ2SD: Convert Dword Integer to Scalar Double-Precision FP Value.
//
// Forms:
//
// 	CVTSQ2SD m64 xmm
// 	CVTSQ2SD r64 xmm
func CVTSQ2SD(mr, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsXMM(x),
		operand.IsR64(mr) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "CVTSQ2SD",
			Operands: []operand.Op{mr, x},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTSQ2SD: bad operands")
}

// CVTSQ2SS: Convert Dword Integer to Scalar Single-Precision FP Value.
//
// Forms:
//
// 	CVTSQ2SS m64 xmm
// 	CVTSQ2SS r64 xmm
func CVTSQ2SS(mr, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsXMM(x),
		operand.IsR64(mr) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "CVTSQ2SS",
			Operands: []operand.Op{mr, x},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("CVTSQ2SS: bad operands")
}

// CVTSS2SD: Convert Scalar Single-Precision FP Value to Scalar Double-Precision FP Value.
//
// Forms:
//
// 	CVTSS2SD m32 xmm
// 	CVTSS2SD xmm xmm
func CVTSS2SD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "CVTSS2SD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTSS2SD: bad operands")
}

// CVTSS2SL: Convert Scalar Single-Precision FP Value to Dword Integer.
//
// Forms:
//
// 	CVTSS2SL m32 r32
// 	CVTSS2SL m32 r64
// 	CVTSS2SL xmm r32
// 	CVTSS2SL xmm r64
func CVTSS2SL(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsR32(r),
		operand.IsM32(mx) && operand.IsR64(r),
		operand.IsXMM(mx) && operand.IsR32(r),
		operand.IsXMM(mx) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CVTSS2SL",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("CVTSS2SL: bad operands")
}

// CVTTPD2PL: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers.
//
// Forms:
//
// 	CVTTPD2PL m128 xmm
// 	CVTTPD2PL xmm  xmm
func CVTTPD2PL(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "CVTTPD2PL",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTTPD2PL: bad operands")
}

// CVTTPS2PL: Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers.
//
// Forms:
//
// 	CVTTPS2PL m128 xmm
// 	CVTTPS2PL xmm  xmm
func CVTTPS2PL(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "CVTTPS2PL",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTTPS2PL: bad operands")
}

// CVTTSD2SL: Convert with Truncation Scalar Double-Precision FP Value to Signed Integer.
//
// Forms:
//
// 	CVTTSD2SL m64 r32
// 	CVTTSD2SL xmm r32
func CVTTSD2SL(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsR32(r),
		operand.IsXMM(mx) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "CVTTSD2SL",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTTSD2SL: bad operands")
}

// CVTTSD2SQ: Convert with Truncation Scalar Double-Precision FP Value to Signed Integer.
//
// Forms:
//
// 	CVTTSD2SQ m64 r64
// 	CVTTSD2SQ xmm r64
func CVTTSD2SQ(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsR64(r),
		operand.IsXMM(mx) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CVTTSD2SQ",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("CVTTSD2SQ: bad operands")
}

// CVTTSS2SL: Convert with Truncation Scalar Single-Precision FP Value to Dword Integer.
//
// Forms:
//
// 	CVTTSS2SL m32 r32
// 	CVTTSS2SL m32 r64
// 	CVTTSS2SL xmm r32
// 	CVTTSS2SL xmm r64
func CVTTSS2SL(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsR32(r),
		operand.IsM32(mx) && operand.IsR64(r),
		operand.IsXMM(mx) && operand.IsR32(r),
		operand.IsXMM(mx) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "CVTTSS2SL",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("CVTTSS2SL: bad operands")
}

// CWD: Convert Word to Doubleword.
//
// Forms:
//
// 	CWD
func CWD() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "CWD",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{reg.AX},
		Outputs:  []operand.Op{reg.DX},
	}, nil
}

// CWDE: Convert Word to Doubleword.
//
// Forms:
//
// 	CWDE
func CWDE() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "CWDE",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{reg.AX},
		Outputs:  []operand.Op{reg.EAX},
	}, nil
}

// DECB: Decrement by 1.
//
// Forms:
//
// 	DECB m8
// 	DECB r8
func DECB(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "DECB",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("DECB: bad operands")
}

// DECL: Decrement by 1.
//
// Forms:
//
// 	DECL m32
// 	DECL r32
func DECL(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr),
		operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "DECL",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("DECL: bad operands")
}

// DECQ: Decrement by 1.
//
// Forms:
//
// 	DECQ m64
// 	DECQ r64
func DECQ(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr),
		operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "DECQ",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("DECQ: bad operands")
}

// DECW: Decrement by 1.
//
// Forms:
//
// 	DECW m16
// 	DECW r16
func DECW(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr),
		operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "DECW",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("DECW: bad operands")
}

// DIVB: Unsigned Divide.
//
// Forms:
//
// 	DIVB m8
// 	DIVB r8
func DIVB(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "DIVB",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr, reg.AX},
			Outputs:  []operand.Op{reg.AX},
		}, nil
	}
	return nil, errors.New("DIVB: bad operands")
}

// DIVL: Unsigned Divide.
//
// Forms:
//
// 	DIVL m32
// 	DIVL r32
func DIVL(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr),
		operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "DIVL",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr, reg.EAX, reg.EDX},
			Outputs:  []operand.Op{reg.EAX, reg.EDX},
		}, nil
	}
	return nil, errors.New("DIVL: bad operands")
}

// DIVPD: Divide Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	DIVPD m128 xmm
// 	DIVPD xmm  xmm
func DIVPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "DIVPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("DIVPD: bad operands")
}

// DIVPS: Divide Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	DIVPS m128 xmm
// 	DIVPS xmm  xmm
func DIVPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "DIVPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("DIVPS: bad operands")
}

// DIVQ: Unsigned Divide.
//
// Forms:
//
// 	DIVQ m64
// 	DIVQ r64
func DIVQ(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr),
		operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "DIVQ",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr, reg.RAX, reg.RDX},
			Outputs:  []operand.Op{reg.RAX, reg.RDX},
		}, nil
	}
	return nil, errors.New("DIVQ: bad operands")
}

// DIVSD: Divide Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	DIVSD m64 xmm
// 	DIVSD xmm xmm
func DIVSD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "DIVSD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("DIVSD: bad operands")
}

// DIVSS: Divide Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	DIVSS m32 xmm
// 	DIVSS xmm xmm
func DIVSS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "DIVSS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("DIVSS: bad operands")
}

// DIVW: Unsigned Divide.
//
// Forms:
//
// 	DIVW m16
// 	DIVW r16
func DIVW(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr),
		operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "DIVW",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr, reg.AX, reg.DX},
			Outputs:  []operand.Op{reg.AX, reg.DX},
		}, nil
	}
	return nil, errors.New("DIVW: bad operands")
}

// DPPD: Dot Product of Packed Double Precision Floating-Point Values.
//
// Forms:
//
// 	DPPD imm8 m128 xmm
// 	DPPD imm8 xmm  xmm
func DPPD(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "DPPD",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("DPPD: bad operands")
}

// DPPS: Dot Product of Packed Single Precision Floating-Point Values.
//
// Forms:
//
// 	DPPS imm8 m128 xmm
// 	DPPS imm8 xmm  xmm
func DPPS(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "DPPS",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("DPPS: bad operands")
}

// EXTRACTPS: Extract Packed Single Precision Floating-Point Value.
//
// Forms:
//
// 	EXTRACTPS imm2u xmm m32
// 	EXTRACTPS imm2u xmm r32
func EXTRACTPS(i, x, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM2U(i) && operand.IsXMM(x) && operand.IsM32(mr),
		operand.IsIMM2U(i) && operand.IsXMM(x) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "EXTRACTPS",
			Operands: []operand.Op{i, x, mr},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{mr},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("EXTRACTPS: bad operands")
}

// HADDPD: Packed Double-FP Horizontal Add.
//
// Forms:
//
// 	HADDPD m128 xmm
// 	HADDPD xmm  xmm
func HADDPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "HADDPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE3"},
		}, nil
	}
	return nil, errors.New("HADDPD: bad operands")
}

// HADDPS: Packed Single-FP Horizontal Add.
//
// Forms:
//
// 	HADDPS m128 xmm
// 	HADDPS xmm  xmm
func HADDPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "HADDPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE3"},
		}, nil
	}
	return nil, errors.New("HADDPS: bad operands")
}

// HSUBPD: Packed Double-FP Horizontal Subtract.
//
// Forms:
//
// 	HSUBPD m128 xmm
// 	HSUBPD xmm  xmm
func HSUBPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "HSUBPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE3"},
		}, nil
	}
	return nil, errors.New("HSUBPD: bad operands")
}

// HSUBPS: Packed Single-FP Horizontal Subtract.
//
// Forms:
//
// 	HSUBPS m128 xmm
// 	HSUBPS xmm  xmm
func HSUBPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "HSUBPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE3"},
		}, nil
	}
	return nil, errors.New("HSUBPS: bad operands")
}

// IDIVB: Signed Divide.
//
// Forms:
//
// 	IDIVB m8
// 	IDIVB r8
func IDIVB(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "IDIVB",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr, reg.AX},
			Outputs:  []operand.Op{reg.AX},
		}, nil
	}
	return nil, errors.New("IDIVB: bad operands")
}

// IDIVL: Signed Divide.
//
// Forms:
//
// 	IDIVL m32
// 	IDIVL r32
func IDIVL(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr),
		operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "IDIVL",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr, reg.EAX, reg.EDX},
			Outputs:  []operand.Op{reg.EAX, reg.EDX},
		}, nil
	}
	return nil, errors.New("IDIVL: bad operands")
}

// IDIVQ: Signed Divide.
//
// Forms:
//
// 	IDIVQ m64
// 	IDIVQ r64
func IDIVQ(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr),
		operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "IDIVQ",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr, reg.RAX, reg.RDX},
			Outputs:  []operand.Op{reg.RAX, reg.RDX},
		}, nil
	}
	return nil, errors.New("IDIVQ: bad operands")
}

// IDIVW: Signed Divide.
//
// Forms:
//
// 	IDIVW m16
// 	IDIVW r16
func IDIVW(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr),
		operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "IDIVW",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr, reg.AX, reg.DX},
			Outputs:  []operand.Op{reg.AX, reg.DX},
		}, nil
	}
	return nil, errors.New("IDIVW: bad operands")
}

// IMUL3L: Signed Multiply.
//
// Forms:
//
// 	IMUL3L imm32 m32 r32
// 	IMUL3L imm32 r32 r32
// 	IMUL3L imm8  m32 r32
// 	IMUL3L imm8  r32 r32
func IMUL3L(i, mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM32(i) && operand.IsM32(mr) && operand.IsR32(r),
		operand.IsIMM32(i) && operand.IsR32(mr) && operand.IsR32(r),
		operand.IsIMM8(i) && operand.IsM32(mr) && operand.IsR32(r),
		operand.IsIMM8(i) && operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "IMUL3L",
			Operands: []operand.Op{i, mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("IMUL3L: bad operands")
}

// IMUL3Q: Signed Multiply.
//
// Forms:
//
// 	IMUL3Q imm32 m64 r64
// 	IMUL3Q imm32 r64 r64
// 	IMUL3Q imm8  m64 r64
// 	IMUL3Q imm8  r64 r64
func IMUL3Q(i, mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM32(i) && operand.IsM64(mr) && operand.IsR64(r),
		operand.IsIMM32(i) && operand.IsR64(mr) && operand.IsR64(r),
		operand.IsIMM8(i) && operand.IsM64(mr) && operand.IsR64(r),
		operand.IsIMM8(i) && operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "IMUL3Q",
			Operands: []operand.Op{i, mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("IMUL3Q: bad operands")
}

// IMUL3W: Signed Multiply.
//
// Forms:
//
// 	IMUL3W imm16 m16 r16
// 	IMUL3W imm16 r16 r16
// 	IMUL3W imm8  m16 r16
// 	IMUL3W imm8  r16 r16
func IMUL3W(i, mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM16(i) && operand.IsM16(mr) && operand.IsR16(r),
		operand.IsIMM16(i) && operand.IsR16(mr) && operand.IsR16(r),
		operand.IsIMM8(i) && operand.IsM16(mr) && operand.IsR16(r),
		operand.IsIMM8(i) && operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "IMUL3W",
			Operands: []operand.Op{i, mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("IMUL3W: bad operands")
}

// IMULB: Signed Multiply.
//
// Forms:
//
// 	IMULB m8
// 	IMULB r8
func IMULB(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "IMULB",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr, reg.AL},
			Outputs:  []operand.Op{reg.AX},
		}, nil
	}
	return nil, errors.New("IMULB: bad operands")
}

// IMULL: Signed Multiply.
//
// Forms:
//
// 	IMULL m32 r32
// 	IMULL m32
// 	IMULL r32 r32
// 	IMULL r32
func IMULL(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsR32(ops[1]),
		len(ops) == 2 && operand.IsR32(ops[0]) && operand.IsR32(ops[1]):
		return &intrep.Instruction{
			Opcode:   "IMULL",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	case len(ops) == 1 && operand.IsM32(ops[0]),
		len(ops) == 1 && operand.IsR32(ops[0]):
		return &intrep.Instruction{
			Opcode:   "IMULL",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], reg.EAX},
			Outputs:  []operand.Op{reg.EAX, reg.EDX},
		}, nil
	}
	return nil, errors.New("IMULL: bad operands")
}

// IMULQ: Signed Multiply.
//
// Forms:
//
// 	IMULQ m64 r64
// 	IMULQ m64
// 	IMULQ r64 r64
// 	IMULQ r64
func IMULQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsR64(ops[1]),
		len(ops) == 2 && operand.IsR64(ops[0]) && operand.IsR64(ops[1]):
		return &intrep.Instruction{
			Opcode:   "IMULQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	case len(ops) == 1 && operand.IsM64(ops[0]),
		len(ops) == 1 && operand.IsR64(ops[0]):
		return &intrep.Instruction{
			Opcode:   "IMULQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], reg.RAX},
			Outputs:  []operand.Op{reg.RAX, reg.RDX},
		}, nil
	}
	return nil, errors.New("IMULQ: bad operands")
}

// IMULW: Signed Multiply.
//
// Forms:
//
// 	IMULW m16 r16
// 	IMULW m16
// 	IMULW r16 r16
// 	IMULW r16
func IMULW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 2 && operand.IsM16(ops[0]) && operand.IsR16(ops[1]),
		len(ops) == 2 && operand.IsR16(ops[0]) && operand.IsR16(ops[1]):
		return &intrep.Instruction{
			Opcode:   "IMULW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	case len(ops) == 1 && operand.IsM16(ops[0]),
		len(ops) == 1 && operand.IsR16(ops[0]):
		return &intrep.Instruction{
			Opcode:   "IMULW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], reg.AX},
			Outputs:  []operand.Op{reg.AX, reg.DX},
		}, nil
	}
	return nil, errors.New("IMULW: bad operands")
}

// INCB: Increment by 1.
//
// Forms:
//
// 	INCB m8
// 	INCB r8
func INCB(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "INCB",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("INCB: bad operands")
}

// INCL: Increment by 1.
//
// Forms:
//
// 	INCL m32
// 	INCL r32
func INCL(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr),
		operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "INCL",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("INCL: bad operands")
}

// INCQ: Increment by 1.
//
// Forms:
//
// 	INCQ m64
// 	INCQ r64
func INCQ(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr),
		operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "INCQ",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("INCQ: bad operands")
}

// INCW: Increment by 1.
//
// Forms:
//
// 	INCW m16
// 	INCW r16
func INCW(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr),
		operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "INCW",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("INCW: bad operands")
}

// INSERTPS: Insert Packed Single Precision Floating-Point Value.
//
// Forms:
//
// 	INSERTPS imm8 m32 xmm
// 	INSERTPS imm8 xmm xmm
func INSERTPS(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "INSERTPS",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("INSERTPS: bad operands")
}

// INT: Call to Interrupt Procedure.
//
// Forms:
//
// 	INT 3
// 	INT imm8
func INT(i operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.Is3(i),
		operand.IsIMM8(i):
		return &intrep.Instruction{
			Opcode:   "INT",
			Operands: []operand.Op{i},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("INT: bad operands")
}

// JA: Jump if above (CF == 0 and ZF == 0).
//
// Forms:
//
// 	JA rel32
// 	JA rel8
func JA(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JA",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JA: bad operands")
}

// JAE: Jump if above or equal (CF == 0).
//
// Forms:
//
// 	JAE rel32
// 	JAE rel8
func JAE(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JAE",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JAE: bad operands")
}

// JB: Jump if below (CF == 1).
//
// Forms:
//
// 	JB rel32
// 	JB rel8
func JB(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JB",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JB: bad operands")
}

// JBE: Jump if below or equal (CF == 1 or ZF == 1).
//
// Forms:
//
// 	JBE rel32
// 	JBE rel8
func JBE(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JBE",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JBE: bad operands")
}

// JC: Jump if below (CF == 1).
//
// Forms:
//
// 	JC rel32
// 	JC rel8
func JC(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JC",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JC: bad operands")
}

// JCC: Jump if above or equal (CF == 0).
//
// Forms:
//
// 	JCC rel32
// 	JCC rel8
func JCC(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JCC",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JCC: bad operands")
}

// JCS: Jump if below (CF == 1).
//
// Forms:
//
// 	JCS rel32
// 	JCS rel8
func JCS(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JCS",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JCS: bad operands")
}

// JCXZL: Jump if ECX register is 0.
//
// Forms:
//
// 	JCXZL rel8
func JCXZL(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JCXZL",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{reg.ECX},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JCXZL: bad operands")
}

// JCXZQ: Jump if RCX register is 0.
//
// Forms:
//
// 	JCXZQ rel8
func JCXZQ(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JCXZQ",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{reg.RCX},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JCXZQ: bad operands")
}

// JE: Jump if equal (ZF == 1).
//
// Forms:
//
// 	JE rel32
// 	JE rel8
func JE(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JE",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JE: bad operands")
}

// JEQ: Jump if equal (ZF == 1).
//
// Forms:
//
// 	JEQ rel32
// 	JEQ rel8
func JEQ(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JEQ",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JEQ: bad operands")
}

// JG: Jump if greater (ZF == 0 and SF == OF).
//
// Forms:
//
// 	JG rel32
// 	JG rel8
func JG(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JG",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JG: bad operands")
}

// JGE: Jump if greater or equal (SF == OF).
//
// Forms:
//
// 	JGE rel32
// 	JGE rel8
func JGE(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JGE",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JGE: bad operands")
}

// JGT: Jump if greater (ZF == 0 and SF == OF).
//
// Forms:
//
// 	JGT rel32
// 	JGT rel8
func JGT(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JGT",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JGT: bad operands")
}

// JHI: Jump if above (CF == 0 and ZF == 0).
//
// Forms:
//
// 	JHI rel32
// 	JHI rel8
func JHI(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JHI",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JHI: bad operands")
}

// JHS: Jump if above or equal (CF == 0).
//
// Forms:
//
// 	JHS rel32
// 	JHS rel8
func JHS(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JHS",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JHS: bad operands")
}

// JL: Jump if less (SF != OF).
//
// Forms:
//
// 	JL rel32
// 	JL rel8
func JL(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JL",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JL: bad operands")
}

// JLE: Jump if less or equal (ZF == 1 or SF != OF).
//
// Forms:
//
// 	JLE rel32
// 	JLE rel8
func JLE(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JLE",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JLE: bad operands")
}

// JLO: Jump if below (CF == 1).
//
// Forms:
//
// 	JLO rel32
// 	JLO rel8
func JLO(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JLO",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JLO: bad operands")
}

// JLS: Jump if below or equal (CF == 1 or ZF == 1).
//
// Forms:
//
// 	JLS rel32
// 	JLS rel8
func JLS(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JLS",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JLS: bad operands")
}

// JLT: Jump if less (SF != OF).
//
// Forms:
//
// 	JLT rel32
// 	JLT rel8
func JLT(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JLT",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JLT: bad operands")
}

// JMI: Jump if sign (SF == 1).
//
// Forms:
//
// 	JMI rel32
// 	JMI rel8
func JMI(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JMI",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JMI: bad operands")
}

// JMP: Jump Unconditionally.
//
// Forms:
//
// 	JMP rel32
// 	JMP rel8
// 	JMP m64
// 	JMP r64
func JMP(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr),
		operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:        "JMP",
			Operands:      []operand.Op{mr},
			Inputs:        []operand.Op{mr},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: false,
		}, nil
	case operand.IsREL32(mr),
		operand.IsREL8(mr):
		return &intrep.Instruction{
			Opcode:        "JMP",
			Operands:      []operand.Op{mr},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: false,
		}, nil
	}
	return nil, errors.New("JMP: bad operands")
}

// JNA: Jump if below or equal (CF == 1 or ZF == 1).
//
// Forms:
//
// 	JNA rel32
// 	JNA rel8
func JNA(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JNA",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JNA: bad operands")
}

// JNAE: Jump if below (CF == 1).
//
// Forms:
//
// 	JNAE rel32
// 	JNAE rel8
func JNAE(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JNAE",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JNAE: bad operands")
}

// JNB: Jump if above or equal (CF == 0).
//
// Forms:
//
// 	JNB rel32
// 	JNB rel8
func JNB(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JNB",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JNB: bad operands")
}

// JNBE: Jump if above (CF == 0 and ZF == 0).
//
// Forms:
//
// 	JNBE rel32
// 	JNBE rel8
func JNBE(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JNBE",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JNBE: bad operands")
}

// JNC: Jump if above or equal (CF == 0).
//
// Forms:
//
// 	JNC rel32
// 	JNC rel8
func JNC(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JNC",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JNC: bad operands")
}

// JNE: Jump if not equal (ZF == 0).
//
// Forms:
//
// 	JNE rel32
// 	JNE rel8
func JNE(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JNE",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JNE: bad operands")
}

// JNG: Jump if less or equal (ZF == 1 or SF != OF).
//
// Forms:
//
// 	JNG rel32
// 	JNG rel8
func JNG(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JNG",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JNG: bad operands")
}

// JNGE: Jump if less (SF != OF).
//
// Forms:
//
// 	JNGE rel32
// 	JNGE rel8
func JNGE(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JNGE",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JNGE: bad operands")
}

// JNL: Jump if greater or equal (SF == OF).
//
// Forms:
//
// 	JNL rel32
// 	JNL rel8
func JNL(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JNL",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JNL: bad operands")
}

// JNLE: Jump if greater (ZF == 0 and SF == OF).
//
// Forms:
//
// 	JNLE rel32
// 	JNLE rel8
func JNLE(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JNLE",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JNLE: bad operands")
}

// JNO: Jump if not overflow (OF == 0).
//
// Forms:
//
// 	JNO rel32
// 	JNO rel8
func JNO(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JNO",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JNO: bad operands")
}

// JNP: Jump if not parity (PF == 0).
//
// Forms:
//
// 	JNP rel32
// 	JNP rel8
func JNP(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JNP",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JNP: bad operands")
}

// JNS: Jump if not sign (SF == 0).
//
// Forms:
//
// 	JNS rel32
// 	JNS rel8
func JNS(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JNS",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JNS: bad operands")
}

// JNZ: Jump if not equal (ZF == 0).
//
// Forms:
//
// 	JNZ rel32
// 	JNZ rel8
func JNZ(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JNZ",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JNZ: bad operands")
}

// JO: Jump if overflow (OF == 1).
//
// Forms:
//
// 	JO rel32
// 	JO rel8
func JO(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JO",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JO: bad operands")
}

// JOC: Jump if not overflow (OF == 0).
//
// Forms:
//
// 	JOC rel32
// 	JOC rel8
func JOC(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JOC",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JOC: bad operands")
}

// JOS: Jump if overflow (OF == 1).
//
// Forms:
//
// 	JOS rel32
// 	JOS rel8
func JOS(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JOS",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JOS: bad operands")
}

// JP: Jump if parity (PF == 1).
//
// Forms:
//
// 	JP rel32
// 	JP rel8
func JP(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JP",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JP: bad operands")
}

// JPC: Jump if not parity (PF == 0).
//
// Forms:
//
// 	JPC rel32
// 	JPC rel8
func JPC(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JPC",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JPC: bad operands")
}

// JPE: Jump if parity (PF == 1).
//
// Forms:
//
// 	JPE rel32
// 	JPE rel8
func JPE(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JPE",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JPE: bad operands")
}

// JPL: Jump if not sign (SF == 0).
//
// Forms:
//
// 	JPL rel32
// 	JPL rel8
func JPL(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JPL",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JPL: bad operands")
}

// JPO: Jump if not parity (PF == 0).
//
// Forms:
//
// 	JPO rel32
// 	JPO rel8
func JPO(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JPO",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JPO: bad operands")
}

// JPS: Jump if parity (PF == 1).
//
// Forms:
//
// 	JPS rel32
// 	JPS rel8
func JPS(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JPS",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JPS: bad operands")
}

// JS: Jump if sign (SF == 1).
//
// Forms:
//
// 	JS rel32
// 	JS rel8
func JS(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JS",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JS: bad operands")
}

// JZ: Jump if equal (ZF == 1).
//
// Forms:
//
// 	JZ rel32
// 	JZ rel8
func JZ(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsREL32(r),
		operand.IsREL8(r):
		return &intrep.Instruction{
			Opcode:        "JZ",
			Operands:      []operand.Op{r},
			Inputs:        []operand.Op{},
			Outputs:       []operand.Op{},
			IsBranch:      true,
			IsConditional: true,
		}, nil
	}
	return nil, errors.New("JZ: bad operands")
}

// KADDB: ADD Two 8-bit Masks.
//
// Forms:
//
// 	KADDB k k k
func KADDB(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KADDB",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("KADDB: bad operands")
}

// KADDD: ADD Two 32-bit Masks.
//
// Forms:
//
// 	KADDD k k k
func KADDD(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KADDD",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KADDD: bad operands")
}

// KADDQ: ADD Two 64-bit Masks.
//
// Forms:
//
// 	KADDQ k k k
func KADDQ(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KADDQ",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KADDQ: bad operands")
}

// KADDW: ADD Two 16-bit Masks.
//
// Forms:
//
// 	KADDW k k k
func KADDW(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KADDW",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("KADDW: bad operands")
}

// KANDB: Bitwise Logical AND 8-bit Masks.
//
// Forms:
//
// 	KANDB k k k
func KANDB(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KANDB",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("KANDB: bad operands")
}

// KANDD: Bitwise Logical AND 32-bit Masks.
//
// Forms:
//
// 	KANDD k k k
func KANDD(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KANDD",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KANDD: bad operands")
}

// KANDNB: Bitwise Logical AND NOT 8-bit Masks.
//
// Forms:
//
// 	KANDNB k k k
func KANDNB(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KANDNB",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("KANDNB: bad operands")
}

// KANDND: Bitwise Logical AND NOT 32-bit Masks.
//
// Forms:
//
// 	KANDND k k k
func KANDND(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KANDND",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KANDND: bad operands")
}

// KANDNQ: Bitwise Logical AND NOT 64-bit Masks.
//
// Forms:
//
// 	KANDNQ k k k
func KANDNQ(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KANDNQ",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KANDNQ: bad operands")
}

// KANDNW: Bitwise Logical AND NOT 16-bit Masks.
//
// Forms:
//
// 	KANDNW k k k
func KANDNW(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KANDNW",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("KANDNW: bad operands")
}

// KANDQ: Bitwise Logical AND 64-bit Masks.
//
// Forms:
//
// 	KANDQ k k k
func KANDQ(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KANDQ",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KANDQ: bad operands")
}

// KANDW: Bitwise Logical AND 16-bit Masks.
//
// Forms:
//
// 	KANDW k k k
func KANDW(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KANDW",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("KANDW: bad operands")
}

// KMOVB: Move 8-bit Mask.
//
// Forms:
//
// 	KMOVB k   k
// 	KMOVB k   m8
// 	KMOVB k   r32
// 	KMOVB m8  k
// 	KMOVB r32 k
func KMOVB(kmr, kmr1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(kmr) && operand.IsK(kmr1),
		operand.IsK(kmr) && operand.IsM8(kmr1),
		operand.IsK(kmr) && operand.IsR32(kmr1),
		operand.IsM8(kmr) && operand.IsK(kmr1),
		operand.IsR32(kmr) && operand.IsK(kmr1):
		return &intrep.Instruction{
			Opcode:   "KMOVB",
			Operands: []operand.Op{kmr, kmr1},
			Inputs:   []operand.Op{kmr},
			Outputs:  []operand.Op{kmr1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("KMOVB: bad operands")
}

// KMOVD: Move 32-bit Mask.
//
// Forms:
//
// 	KMOVD k   k
// 	KMOVD k   m32
// 	KMOVD k   r32
// 	KMOVD m32 k
// 	KMOVD r32 k
func KMOVD(kmr, kmr1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(kmr) && operand.IsK(kmr1),
		operand.IsK(kmr) && operand.IsM32(kmr1),
		operand.IsK(kmr) && operand.IsR32(kmr1),
		operand.IsM32(kmr) && operand.IsK(kmr1),
		operand.IsR32(kmr) && operand.IsK(kmr1):
		return &intrep.Instruction{
			Opcode:   "KMOVD",
			Operands: []operand.Op{kmr, kmr1},
			Inputs:   []operand.Op{kmr},
			Outputs:  []operand.Op{kmr1},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KMOVD: bad operands")
}

// KMOVQ: Move 64-bit Mask.
//
// Forms:
//
// 	KMOVQ k   k
// 	KMOVQ k   m64
// 	KMOVQ k   r64
// 	KMOVQ m64 k
// 	KMOVQ r64 k
func KMOVQ(kmr, kmr1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(kmr) && operand.IsK(kmr1),
		operand.IsK(kmr) && operand.IsM64(kmr1),
		operand.IsK(kmr) && operand.IsR64(kmr1),
		operand.IsM64(kmr) && operand.IsK(kmr1),
		operand.IsR64(kmr) && operand.IsK(kmr1):
		return &intrep.Instruction{
			Opcode:   "KMOVQ",
			Operands: []operand.Op{kmr, kmr1},
			Inputs:   []operand.Op{kmr},
			Outputs:  []operand.Op{kmr1},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KMOVQ: bad operands")
}

// KMOVW: Move 16-bit Mask.
//
// Forms:
//
// 	KMOVW k   k
// 	KMOVW k   m16
// 	KMOVW k   r32
// 	KMOVW m16 k
// 	KMOVW r32 k
func KMOVW(kmr, kmr1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(kmr) && operand.IsK(kmr1),
		operand.IsK(kmr) && operand.IsM16(kmr1),
		operand.IsK(kmr) && operand.IsR32(kmr1),
		operand.IsM16(kmr) && operand.IsK(kmr1),
		operand.IsR32(kmr) && operand.IsK(kmr1):
		return &intrep.Instruction{
			Opcode:   "KMOVW",
			Operands: []operand.Op{kmr, kmr1},
			Inputs:   []operand.Op{kmr},
			Outputs:  []operand.Op{kmr1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("KMOVW: bad operands")
}

// KNOTB: NOT 8-bit Mask Register.
//
// Forms:
//
// 	KNOTB k k
func KNOTB(k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KNOTB",
			Operands: []operand.Op{k, k1},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{k1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("KNOTB: bad operands")
}

// KNOTD: NOT 32-bit Mask Register.
//
// Forms:
//
// 	KNOTD k k
func KNOTD(k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KNOTD",
			Operands: []operand.Op{k, k1},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{k1},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KNOTD: bad operands")
}

// KNOTQ: NOT 64-bit Mask Register.
//
// Forms:
//
// 	KNOTQ k k
func KNOTQ(k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KNOTQ",
			Operands: []operand.Op{k, k1},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{k1},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KNOTQ: bad operands")
}

// KNOTW: NOT 16-bit Mask Register.
//
// Forms:
//
// 	KNOTW k k
func KNOTW(k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KNOTW",
			Operands: []operand.Op{k, k1},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{k1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("KNOTW: bad operands")
}

// KORB: Bitwise Logical OR 8-bit Masks.
//
// Forms:
//
// 	KORB k k k
func KORB(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KORB",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("KORB: bad operands")
}

// KORD: Bitwise Logical OR 32-bit Masks.
//
// Forms:
//
// 	KORD k k k
func KORD(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KORD",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KORD: bad operands")
}

// KORQ: Bitwise Logical OR 64-bit Masks.
//
// Forms:
//
// 	KORQ k k k
func KORQ(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KORQ",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KORQ: bad operands")
}

// KORTESTB: OR 8-bit Masks and Set Flags.
//
// Forms:
//
// 	KORTESTB k k
func KORTESTB(k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KORTESTB",
			Operands: []operand.Op{k, k1},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("KORTESTB: bad operands")
}

// KORTESTD: OR 32-bit Masks and Set Flags.
//
// Forms:
//
// 	KORTESTD k k
func KORTESTD(k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KORTESTD",
			Operands: []operand.Op{k, k1},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KORTESTD: bad operands")
}

// KORTESTQ: OR 64-bit Masks and Set Flags.
//
// Forms:
//
// 	KORTESTQ k k
func KORTESTQ(k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KORTESTQ",
			Operands: []operand.Op{k, k1},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KORTESTQ: bad operands")
}

// KORTESTW: OR 16-bit Masks and Set Flags.
//
// Forms:
//
// 	KORTESTW k k
func KORTESTW(k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KORTESTW",
			Operands: []operand.Op{k, k1},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("KORTESTW: bad operands")
}

// KORW: Bitwise Logical OR 16-bit Masks.
//
// Forms:
//
// 	KORW k k k
func KORW(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KORW",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("KORW: bad operands")
}

// KSHIFTLB: Shift Left 8-bit Masks.
//
// Forms:
//
// 	KSHIFTLB imm8 k k
func KSHIFTLB(i, k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KSHIFTLB",
			Operands: []operand.Op{i, k, k1},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{k1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("KSHIFTLB: bad operands")
}

// KSHIFTLD: Shift Left 32-bit Masks.
//
// Forms:
//
// 	KSHIFTLD imm8 k k
func KSHIFTLD(i, k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KSHIFTLD",
			Operands: []operand.Op{i, k, k1},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{k1},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KSHIFTLD: bad operands")
}

// KSHIFTLQ: Shift Left 64-bit Masks.
//
// Forms:
//
// 	KSHIFTLQ imm8 k k
func KSHIFTLQ(i, k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KSHIFTLQ",
			Operands: []operand.Op{i, k, k1},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{k1},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KSHIFTLQ: bad operands")
}

// KSHIFTLW: Shift Left 16-bit Masks.
//
// Forms:
//
// 	KSHIFTLW imm8 k k
func KSHIFTLW(i, k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KSHIFTLW",
			Operands: []operand.Op{i, k, k1},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{k1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("KSHIFTLW: bad operands")
}

// KSHIFTRB: Shift Right 8-bit Masks.
//
// Forms:
//
// 	KSHIFTRB imm8 k k
func KSHIFTRB(i, k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KSHIFTRB",
			Operands: []operand.Op{i, k, k1},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{k1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("KSHIFTRB: bad operands")
}

// KSHIFTRD: Shift Right 32-bit Masks.
//
// Forms:
//
// 	KSHIFTRD imm8 k k
func KSHIFTRD(i, k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KSHIFTRD",
			Operands: []operand.Op{i, k, k1},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{k1},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KSHIFTRD: bad operands")
}

// KSHIFTRQ: Shift Right 64-bit Masks.
//
// Forms:
//
// 	KSHIFTRQ imm8 k k
func KSHIFTRQ(i, k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KSHIFTRQ",
			Operands: []operand.Op{i, k, k1},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{k1},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KSHIFTRQ: bad operands")
}

// KSHIFTRW: Shift Right 16-bit Masks.
//
// Forms:
//
// 	KSHIFTRW imm8 k k
func KSHIFTRW(i, k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KSHIFTRW",
			Operands: []operand.Op{i, k, k1},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{k1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("KSHIFTRW: bad operands")
}

// KTESTB: Bit Test 8-bit Masks and Set Flags.
//
// Forms:
//
// 	KTESTB k k
func KTESTB(k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KTESTB",
			Operands: []operand.Op{k, k1},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("KTESTB: bad operands")
}

// KTESTD: Bit Test 32-bit Masks and Set Flags.
//
// Forms:
//
// 	KTESTD k k
func KTESTD(k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KTESTD",
			Operands: []operand.Op{k, k1},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KTESTD: bad operands")
}

// KTESTQ: Bit Test 64-bit Masks and Set Flags.
//
// Forms:
//
// 	KTESTQ k k
func KTESTQ(k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KTESTQ",
			Operands: []operand.Op{k, k1},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KTESTQ: bad operands")
}

// KTESTW: Bit Test 16-bit Masks and Set Flags.
//
// Forms:
//
// 	KTESTW k k
func KTESTW(k, k1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1):
		return &intrep.Instruction{
			Opcode:   "KTESTW",
			Operands: []operand.Op{k, k1},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("KTESTW: bad operands")
}

// KUNPCKBW: Unpack and Interleave 8-bit Masks.
//
// Forms:
//
// 	KUNPCKBW k k k
func KUNPCKBW(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KUNPCKBW",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("KUNPCKBW: bad operands")
}

// KUNPCKDQ: Unpack and Interleave 32-bit Masks.
//
// Forms:
//
// 	KUNPCKDQ k k k
func KUNPCKDQ(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KUNPCKDQ",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KUNPCKDQ: bad operands")
}

// KUNPCKWD: Unpack and Interleave 16-bit Masks.
//
// Forms:
//
// 	KUNPCKWD k k k
func KUNPCKWD(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KUNPCKWD",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KUNPCKWD: bad operands")
}

// KXNORB: Bitwise Logical XNOR 8-bit Masks.
//
// Forms:
//
// 	KXNORB k k k
func KXNORB(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KXNORB",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("KXNORB: bad operands")
}

// KXNORD: Bitwise Logical XNOR 32-bit Masks.
//
// Forms:
//
// 	KXNORD k k k
func KXNORD(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KXNORD",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KXNORD: bad operands")
}

// KXNORQ: Bitwise Logical XNOR 64-bit Masks.
//
// Forms:
//
// 	KXNORQ k k k
func KXNORQ(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KXNORQ",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KXNORQ: bad operands")
}

// KXNORW: Bitwise Logical XNOR 16-bit Masks.
//
// Forms:
//
// 	KXNORW k k k
func KXNORW(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KXNORW",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("KXNORW: bad operands")
}

// KXORB: Bitwise Logical XOR 8-bit Masks.
//
// Forms:
//
// 	KXORB k k k
func KXORB(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KXORB",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("KXORB: bad operands")
}

// KXORD: Bitwise Logical XOR 32-bit Masks.
//
// Forms:
//
// 	KXORD k k k
func KXORD(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KXORD",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KXORD: bad operands")
}

// KXORQ: Bitwise Logical XOR 64-bit Masks.
//
// Forms:
//
// 	KXORQ k k k
func KXORQ(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KXORQ",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("KXORQ: bad operands")
}

// KXORW: Bitwise Logical XOR 16-bit Masks.
//
// Forms:
//
// 	KXORW k k k
func KXORW(k, k1, k2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsK(k1) && operand.IsK(k2):
		return &intrep.Instruction{
			Opcode:   "KXORW",
			Operands: []operand.Op{k, k1, k2},
			Inputs:   []operand.Op{k, k1},
			Outputs:  []operand.Op{k2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("KXORW: bad operands")
}

// LDDQU: Load Unaligned Integer 128 Bits.
//
// Forms:
//
// 	LDDQU m128 xmm
func LDDQU(m, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(m) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "LDDQU",
			Operands: []operand.Op{m, x},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE3"},
		}, nil
	}
	return nil, errors.New("LDDQU: bad operands")
}

// LDMXCSR: Load MXCSR Register.
//
// Forms:
//
// 	LDMXCSR m32
func LDMXCSR(m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m):
		return &intrep.Instruction{
			Opcode:   "LDMXCSR",
			Operands: []operand.Op{m},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("LDMXCSR: bad operands")
}

// LEAL: Load Effective Address.
//
// Forms:
//
// 	LEAL m r32
func LEAL(m, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM(m) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "LEAL",
			Operands: []operand.Op{m, r},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("LEAL: bad operands")
}

// LEAQ: Load Effective Address.
//
// Forms:
//
// 	LEAQ m r64
func LEAQ(m, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM(m) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "LEAQ",
			Operands: []operand.Op{m, r},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("LEAQ: bad operands")
}

// LEAW: Load Effective Address.
//
// Forms:
//
// 	LEAW m r16
func LEAW(m, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM(m) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "LEAW",
			Operands: []operand.Op{m, r},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("LEAW: bad operands")
}

// LFENCE: Load Fence.
//
// Forms:
//
// 	LFENCE
func LFENCE() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "LFENCE",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{},
		ISA:      []string{"SSE2"},
	}, nil
}

// LZCNTL: Count the Number of Leading Zero Bits.
//
// Forms:
//
// 	LZCNTL m32 r32
// 	LZCNTL r32 r32
func LZCNTL(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "LZCNTL",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"LZCNT"},
		}, nil
	}
	return nil, errors.New("LZCNTL: bad operands")
}

// LZCNTQ: Count the Number of Leading Zero Bits.
//
// Forms:
//
// 	LZCNTQ m64 r64
// 	LZCNTQ r64 r64
func LZCNTQ(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "LZCNTQ",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"LZCNT"},
		}, nil
	}
	return nil, errors.New("LZCNTQ: bad operands")
}

// LZCNTW: Count the Number of Leading Zero Bits.
//
// Forms:
//
// 	LZCNTW m16 r16
// 	LZCNTW r16 r16
func LZCNTW(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "LZCNTW",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"LZCNT"},
		}, nil
	}
	return nil, errors.New("LZCNTW: bad operands")
}

// MASKMOVDQU: Store Selected Bytes of Double Quadword.
//
// Forms:
//
// 	MASKMOVDQU xmm xmm
func MASKMOVDQU(x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "MASKMOVDQU",
			Operands: []operand.Op{x, x1},
			Inputs:   []operand.Op{x, x1, reg.RDI},
			Outputs:  []operand.Op{},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MASKMOVDQU: bad operands")
}

// MASKMOVOU: Store Selected Bytes of Double Quadword.
//
// Forms:
//
// 	MASKMOVOU xmm xmm
func MASKMOVOU(x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "MASKMOVOU",
			Operands: []operand.Op{x, x1},
			Inputs:   []operand.Op{x, x1, reg.RDI},
			Outputs:  []operand.Op{},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MASKMOVOU: bad operands")
}

// MAXPD: Return Maximum Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	MAXPD m128 xmm
// 	MAXPD xmm  xmm
func MAXPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MAXPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MAXPD: bad operands")
}

// MAXPS: Return Maximum Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	MAXPS m128 xmm
// 	MAXPS xmm  xmm
func MAXPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MAXPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MAXPS: bad operands")
}

// MAXSD: Return Maximum Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	MAXSD m64 xmm
// 	MAXSD xmm xmm
func MAXSD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MAXSD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MAXSD: bad operands")
}

// MAXSS: Return Maximum Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	MAXSS m32 xmm
// 	MAXSS xmm xmm
func MAXSS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MAXSS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MAXSS: bad operands")
}

// MFENCE: Memory Fence.
//
// Forms:
//
// 	MFENCE
func MFENCE() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "MFENCE",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{},
		ISA:      []string{"SSE2"},
	}, nil
}

// MINPD: Return Minimum Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	MINPD m128 xmm
// 	MINPD xmm  xmm
func MINPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MINPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MINPD: bad operands")
}

// MINPS: Return Minimum Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	MINPS m128 xmm
// 	MINPS xmm  xmm
func MINPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MINPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MINPS: bad operands")
}

// MINSD: Return Minimum Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	MINSD m64 xmm
// 	MINSD xmm xmm
func MINSD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MINSD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MINSD: bad operands")
}

// MINSS: Return Minimum Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	MINSS m32 xmm
// 	MINSS xmm xmm
func MINSS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MINSS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MINSS: bad operands")
}

// MONITOR: Monitor a Linear Address Range.
//
// Forms:
//
// 	MONITOR
func MONITOR() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "MONITOR",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{reg.RAX, reg.ECX, reg.EDX},
		Outputs:  []operand.Op{},
		ISA:      []string{"MONITOR"},
	}, nil
}

// MOVAPD: Move Aligned Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	MOVAPD m128 xmm
// 	MOVAPD xmm  m128
// 	MOVAPD xmm  xmm
func MOVAPD(mx, mx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(mx1),
		operand.IsXMM(mx) && operand.IsM128(mx1),
		operand.IsXMM(mx) && operand.IsXMM(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVAPD",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MOVAPD: bad operands")
}

// MOVAPS: Move Aligned Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	MOVAPS m128 xmm
// 	MOVAPS xmm  m128
// 	MOVAPS xmm  xmm
func MOVAPS(mx, mx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(mx1),
		operand.IsXMM(mx) && operand.IsM128(mx1),
		operand.IsXMM(mx) && operand.IsXMM(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVAPS",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MOVAPS: bad operands")
}

// MOVB: Move.
//
// Forms:
//
// 	MOVB imm8 m8
// 	MOVB imm8 r8
// 	MOVB m8   r8
// 	MOVB r8   m8
// 	MOVB r8   r8
func MOVB(imr, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(imr) && operand.IsR8(mr),
		operand.IsR8(imr) && operand.IsM8(mr),
		operand.IsR8(imr) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "MOVB",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{imr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM8(imr) && operand.IsM8(mr),
		operand.IsIMM8(imr) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "MOVB",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("MOVB: bad operands")
}

// MOVBELL: Move Data After Swapping Bytes.
//
// Forms:
//
// 	MOVBELL m32 r32
// 	MOVBELL r32 m32
func MOVBELL(mr, mr1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(mr1),
		operand.IsR32(mr) && operand.IsM32(mr1):
		return &intrep.Instruction{
			Opcode:   "MOVBELL",
			Operands: []operand.Op{mr, mr1},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr1},
			ISA:      []string{"MOVBE"},
		}, nil
	}
	return nil, errors.New("MOVBELL: bad operands")
}

// MOVBEQQ: Move Data After Swapping Bytes.
//
// Forms:
//
// 	MOVBEQQ m64 r64
// 	MOVBEQQ r64 m64
func MOVBEQQ(mr, mr1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(mr1),
		operand.IsR64(mr) && operand.IsM64(mr1):
		return &intrep.Instruction{
			Opcode:   "MOVBEQQ",
			Operands: []operand.Op{mr, mr1},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr1},
			ISA:      []string{"MOVBE"},
		}, nil
	}
	return nil, errors.New("MOVBEQQ: bad operands")
}

// MOVBEWW: Move Data After Swapping Bytes.
//
// Forms:
//
// 	MOVBEWW m16 r16
// 	MOVBEWW r16 m16
func MOVBEWW(mr, mr1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(mr1),
		operand.IsR16(mr) && operand.IsM16(mr1):
		return &intrep.Instruction{
			Opcode:   "MOVBEWW",
			Operands: []operand.Op{mr, mr1},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr1},
			ISA:      []string{"MOVBE"},
		}, nil
	}
	return nil, errors.New("MOVBEWW: bad operands")
}

// MOVBLSX: Move with Sign-Extension.
//
// Forms:
//
// 	MOVBLSX m8 r32
// 	MOVBLSX r8 r32
func MOVBLSX(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr) && operand.IsR32(r),
		operand.IsR8(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "MOVBLSX",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("MOVBLSX: bad operands")
}

// MOVBLZX: Move with Zero-Extend.
//
// Forms:
//
// 	MOVBLZX m8 r32
// 	MOVBLZX r8 r32
func MOVBLZX(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr) && operand.IsR32(r),
		operand.IsR8(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "MOVBLZX",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("MOVBLZX: bad operands")
}

// MOVBQSX: Move with Sign-Extension.
//
// Forms:
//
// 	MOVBQSX m8 r64
// 	MOVBQSX r8 r64
func MOVBQSX(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr) && operand.IsR64(r),
		operand.IsR8(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "MOVBQSX",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("MOVBQSX: bad operands")
}

// MOVBQZX: Move with Zero-Extend.
//
// Forms:
//
// 	MOVBQZX m8 r64
// 	MOVBQZX r8 r64
func MOVBQZX(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr) && operand.IsR64(r),
		operand.IsR8(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "MOVBQZX",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("MOVBQZX: bad operands")
}

// MOVBWSX: Move with Sign-Extension.
//
// Forms:
//
// 	MOVBWSX m8 r16
// 	MOVBWSX r8 r16
func MOVBWSX(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr) && operand.IsR16(r),
		operand.IsR8(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "MOVBWSX",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("MOVBWSX: bad operands")
}

// MOVBWZX: Move with Zero-Extend.
//
// Forms:
//
// 	MOVBWZX m8 r16
// 	MOVBWZX r8 r16
func MOVBWZX(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr) && operand.IsR16(r),
		operand.IsR8(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "MOVBWZX",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("MOVBWZX: bad operands")
}

// MOVD: Move.
//
// Forms:
//
// 	MOVD m32   xmm
// 	MOVD m64   xmm
// 	MOVD r32   xmm
// 	MOVD r64   xmm
// 	MOVD xmm   m32
// 	MOVD xmm   m64
// 	MOVD xmm   r32
// 	MOVD xmm   r64
// 	MOVD xmm   xmm
// 	MOVD imm32 m64
// 	MOVD imm32 r64
// 	MOVD imm64 r64
// 	MOVD m64   r64
// 	MOVD r64   m64
// 	MOVD r64   r64
func MOVD(imrx, mrx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(imrx) && operand.IsXMM(mrx),
		operand.IsM64(imrx) && operand.IsXMM(mrx),
		operand.IsR32(imrx) && operand.IsXMM(mrx),
		operand.IsR64(imrx) && operand.IsXMM(mrx),
		operand.IsXMM(imrx) && operand.IsM32(mrx),
		operand.IsXMM(imrx) && operand.IsM64(mrx),
		operand.IsXMM(imrx) && operand.IsR32(mrx),
		operand.IsXMM(imrx) && operand.IsR64(mrx),
		operand.IsXMM(imrx) && operand.IsXMM(mrx):
		return &intrep.Instruction{
			Opcode:   "MOVD",
			Operands: []operand.Op{imrx, mrx},
			Inputs:   []operand.Op{imrx},
			Outputs:  []operand.Op{mrx},
			ISA:      []string{"SSE2"},
		}, nil
	case operand.IsM64(imrx) && operand.IsR64(mrx),
		operand.IsR64(imrx) && operand.IsM64(mrx),
		operand.IsR64(imrx) && operand.IsR64(mrx):
		return &intrep.Instruction{
			Opcode:   "MOVD",
			Operands: []operand.Op{imrx, mrx},
			Inputs:   []operand.Op{imrx},
			Outputs:  []operand.Op{mrx},
		}, nil
	case operand.IsIMM32(imrx) && operand.IsM64(mrx),
		operand.IsIMM32(imrx) && operand.IsR64(mrx),
		operand.IsIMM64(imrx) && operand.IsR64(mrx):
		return &intrep.Instruction{
			Opcode:   "MOVD",
			Operands: []operand.Op{imrx, mrx},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mrx},
		}, nil
	}
	return nil, errors.New("MOVD: bad operands")
}

// MOVDDUP: Move One Double-FP and Duplicate.
//
// Forms:
//
// 	MOVDDUP m64 xmm
// 	MOVDDUP xmm xmm
func MOVDDUP(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MOVDDUP",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE3"},
		}, nil
	}
	return nil, errors.New("MOVDDUP: bad operands")
}

// MOVDQ2Q: Move.
//
// Forms:
//
// 	MOVDQ2Q m32   xmm
// 	MOVDQ2Q m64   xmm
// 	MOVDQ2Q r32   xmm
// 	MOVDQ2Q r64   xmm
// 	MOVDQ2Q xmm   m32
// 	MOVDQ2Q xmm   m64
// 	MOVDQ2Q xmm   r32
// 	MOVDQ2Q xmm   r64
// 	MOVDQ2Q xmm   xmm
// 	MOVDQ2Q imm32 m64
// 	MOVDQ2Q imm32 r64
// 	MOVDQ2Q imm64 r64
// 	MOVDQ2Q m64   r64
// 	MOVDQ2Q r64   m64
// 	MOVDQ2Q r64   r64
func MOVDQ2Q(imrx, mrx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(imrx) && operand.IsXMM(mrx),
		operand.IsM64(imrx) && operand.IsXMM(mrx),
		operand.IsR32(imrx) && operand.IsXMM(mrx),
		operand.IsR64(imrx) && operand.IsXMM(mrx),
		operand.IsXMM(imrx) && operand.IsM32(mrx),
		operand.IsXMM(imrx) && operand.IsM64(mrx),
		operand.IsXMM(imrx) && operand.IsR32(mrx),
		operand.IsXMM(imrx) && operand.IsR64(mrx),
		operand.IsXMM(imrx) && operand.IsXMM(mrx):
		return &intrep.Instruction{
			Opcode:   "MOVDQ2Q",
			Operands: []operand.Op{imrx, mrx},
			Inputs:   []operand.Op{imrx},
			Outputs:  []operand.Op{mrx},
			ISA:      []string{"SSE2"},
		}, nil
	case operand.IsM64(imrx) && operand.IsR64(mrx),
		operand.IsR64(imrx) && operand.IsM64(mrx),
		operand.IsR64(imrx) && operand.IsR64(mrx):
		return &intrep.Instruction{
			Opcode:   "MOVDQ2Q",
			Operands: []operand.Op{imrx, mrx},
			Inputs:   []operand.Op{imrx},
			Outputs:  []operand.Op{mrx},
		}, nil
	case operand.IsIMM32(imrx) && operand.IsM64(mrx),
		operand.IsIMM32(imrx) && operand.IsR64(mrx),
		operand.IsIMM64(imrx) && operand.IsR64(mrx):
		return &intrep.Instruction{
			Opcode:   "MOVDQ2Q",
			Operands: []operand.Op{imrx, mrx},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mrx},
		}, nil
	}
	return nil, errors.New("MOVDQ2Q: bad operands")
}

// MOVHLPS: Move Packed Single-Precision Floating-Point Values High to Low.
//
// Forms:
//
// 	MOVHLPS xmm xmm
func MOVHLPS(x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "MOVHLPS",
			Operands: []operand.Op{x, x1},
			Inputs:   []operand.Op{x, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MOVHLPS: bad operands")
}

// MOVHPD: Move High Packed Double-Precision Floating-Point Value.
//
// Forms:
//
// 	MOVHPD m64 xmm
// 	MOVHPD xmm m64
func MOVHPD(mx, mx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVHPD",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx, mx1},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE2"},
		}, nil
	case operand.IsXMM(mx) && operand.IsM64(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVHPD",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MOVHPD: bad operands")
}

// MOVHPS: Move High Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	MOVHPS m64 xmm
// 	MOVHPS xmm m64
func MOVHPS(mx, mx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVHPS",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx, mx1},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE"},
		}, nil
	case operand.IsXMM(mx) && operand.IsM64(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVHPS",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MOVHPS: bad operands")
}

// MOVL: Move.
//
// Forms:
//
// 	MOVL imm32 m32
// 	MOVL imm32 r32
// 	MOVL m32   r32
// 	MOVL r32   m32
// 	MOVL r32   r32
func MOVL(imr, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(imr) && operand.IsR32(mr),
		operand.IsR32(imr) && operand.IsM32(mr),
		operand.IsR32(imr) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "MOVL",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{imr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM32(imr) && operand.IsM32(mr),
		operand.IsIMM32(imr) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "MOVL",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("MOVL: bad operands")
}

// MOVLHPS: Move Packed Single-Precision Floating-Point Values Low to High.
//
// Forms:
//
// 	MOVLHPS xmm xmm
func MOVLHPS(x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "MOVLHPS",
			Operands: []operand.Op{x, x1},
			Inputs:   []operand.Op{x, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MOVLHPS: bad operands")
}

// MOVLPD: Move Low Packed Double-Precision Floating-Point Value.
//
// Forms:
//
// 	MOVLPD m64 xmm
// 	MOVLPD xmm m64
func MOVLPD(mx, mx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVLPD",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx, mx1},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE2"},
		}, nil
	case operand.IsXMM(mx) && operand.IsM64(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVLPD",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MOVLPD: bad operands")
}

// MOVLPS: Move Low Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	MOVLPS m64 xmm
// 	MOVLPS xmm m64
func MOVLPS(mx, mx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVLPS",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx, mx1},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE"},
		}, nil
	case operand.IsXMM(mx) && operand.IsM64(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVLPS",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MOVLPS: bad operands")
}

// MOVLQSX: Move Doubleword to Quadword with Sign-Extension.
//
// Forms:
//
// 	MOVLQSX m32 r64
// 	MOVLQSX r32 r64
func MOVLQSX(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR64(r),
		operand.IsR32(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "MOVLQSX",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("MOVLQSX: bad operands")
}

// MOVLQZX: Move with Zero-Extend.
//
// Forms:
//
// 	MOVLQZX m32 r64
func MOVLQZX(m, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "MOVLQZX",
			Operands: []operand.Op{m, r},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("MOVLQZX: bad operands")
}

// MOVMSKPD: Extract Packed Double-Precision Floating-Point Sign Mask.
//
// Forms:
//
// 	MOVMSKPD xmm r32
func MOVMSKPD(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "MOVMSKPD",
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MOVMSKPD: bad operands")
}

// MOVMSKPS: Extract Packed Single-Precision Floating-Point Sign Mask.
//
// Forms:
//
// 	MOVMSKPS xmm r32
func MOVMSKPS(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "MOVMSKPS",
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MOVMSKPS: bad operands")
}

// MOVNTDQ: Store Double Quadword Using Non-Temporal Hint.
//
// Forms:
//
// 	MOVNTDQ xmm m128
func MOVNTDQ(x, m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsM128(m):
		return &intrep.Instruction{
			Opcode:   "MOVNTDQ",
			Operands: []operand.Op{x, m},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{m},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MOVNTDQ: bad operands")
}

// MOVNTDQA: Load Double Quadword Non-Temporal Aligned Hint.
//
// Forms:
//
// 	MOVNTDQA m128 xmm
func MOVNTDQA(m, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(m) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MOVNTDQA",
			Operands: []operand.Op{m, x},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("MOVNTDQA: bad operands")
}

// MOVNTIL: Store Doubleword Using Non-Temporal Hint.
//
// Forms:
//
// 	MOVNTIL r32 m32
func MOVNTIL(r, m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsM32(m):
		return &intrep.Instruction{
			Opcode:   "MOVNTIL",
			Operands: []operand.Op{r, m},
			Inputs:   []operand.Op{r},
			Outputs:  []operand.Op{m},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MOVNTIL: bad operands")
}

// MOVNTIQ: Store Doubleword Using Non-Temporal Hint.
//
// Forms:
//
// 	MOVNTIQ r64 m64
func MOVNTIQ(r, m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsM64(m):
		return &intrep.Instruction{
			Opcode:   "MOVNTIQ",
			Operands: []operand.Op{r, m},
			Inputs:   []operand.Op{r},
			Outputs:  []operand.Op{m},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MOVNTIQ: bad operands")
}

// MOVNTO: Store Double Quadword Using Non-Temporal Hint.
//
// Forms:
//
// 	MOVNTO xmm m128
func MOVNTO(x, m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsM128(m):
		return &intrep.Instruction{
			Opcode:   "MOVNTO",
			Operands: []operand.Op{x, m},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{m},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MOVNTO: bad operands")
}

// MOVNTPD: Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint.
//
// Forms:
//
// 	MOVNTPD xmm m128
func MOVNTPD(x, m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsM128(m):
		return &intrep.Instruction{
			Opcode:   "MOVNTPD",
			Operands: []operand.Op{x, m},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{m},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MOVNTPD: bad operands")
}

// MOVNTPS: Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint.
//
// Forms:
//
// 	MOVNTPS xmm m128
func MOVNTPS(x, m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsM128(m):
		return &intrep.Instruction{
			Opcode:   "MOVNTPS",
			Operands: []operand.Op{x, m},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{m},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MOVNTPS: bad operands")
}

// MOVO: Move Aligned Double Quadword.
//
// Forms:
//
// 	MOVO m128 xmm
// 	MOVO xmm  m128
// 	MOVO xmm  xmm
func MOVO(mx, mx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(mx1),
		operand.IsXMM(mx) && operand.IsM128(mx1),
		operand.IsXMM(mx) && operand.IsXMM(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVO",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MOVO: bad operands")
}

// MOVOA: Move Aligned Double Quadword.
//
// Forms:
//
// 	MOVOA m128 xmm
// 	MOVOA xmm  m128
// 	MOVOA xmm  xmm
func MOVOA(mx, mx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(mx1),
		operand.IsXMM(mx) && operand.IsM128(mx1),
		operand.IsXMM(mx) && operand.IsXMM(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVOA",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MOVOA: bad operands")
}

// MOVOU: Move Unaligned Double Quadword.
//
// Forms:
//
// 	MOVOU m128 xmm
// 	MOVOU xmm  m128
// 	MOVOU xmm  xmm
func MOVOU(mx, mx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(mx1),
		operand.IsXMM(mx) && operand.IsM128(mx1),
		operand.IsXMM(mx) && operand.IsXMM(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVOU",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MOVOU: bad operands")
}

// MOVQ: Move.
//
// Forms:
//
// 	MOVQ m32   xmm
// 	MOVQ m64   xmm
// 	MOVQ r32   xmm
// 	MOVQ r64   xmm
// 	MOVQ xmm   m32
// 	MOVQ xmm   m64
// 	MOVQ xmm   r32
// 	MOVQ xmm   r64
// 	MOVQ xmm   xmm
// 	MOVQ imm32 m64
// 	MOVQ imm32 r64
// 	MOVQ imm64 r64
// 	MOVQ m64   r64
// 	MOVQ r64   m64
// 	MOVQ r64   r64
func MOVQ(imrx, mrx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(imrx) && operand.IsXMM(mrx),
		operand.IsM64(imrx) && operand.IsXMM(mrx),
		operand.IsR32(imrx) && operand.IsXMM(mrx),
		operand.IsR64(imrx) && operand.IsXMM(mrx),
		operand.IsXMM(imrx) && operand.IsM32(mrx),
		operand.IsXMM(imrx) && operand.IsM64(mrx),
		operand.IsXMM(imrx) && operand.IsR32(mrx),
		operand.IsXMM(imrx) && operand.IsR64(mrx),
		operand.IsXMM(imrx) && operand.IsXMM(mrx):
		return &intrep.Instruction{
			Opcode:   "MOVQ",
			Operands: []operand.Op{imrx, mrx},
			Inputs:   []operand.Op{imrx},
			Outputs:  []operand.Op{mrx},
			ISA:      []string{"SSE2"},
		}, nil
	case operand.IsM64(imrx) && operand.IsR64(mrx),
		operand.IsR64(imrx) && operand.IsM64(mrx),
		operand.IsR64(imrx) && operand.IsR64(mrx):
		return &intrep.Instruction{
			Opcode:   "MOVQ",
			Operands: []operand.Op{imrx, mrx},
			Inputs:   []operand.Op{imrx},
			Outputs:  []operand.Op{mrx},
		}, nil
	case operand.IsIMM32(imrx) && operand.IsM64(mrx),
		operand.IsIMM32(imrx) && operand.IsR64(mrx),
		operand.IsIMM64(imrx) && operand.IsR64(mrx):
		return &intrep.Instruction{
			Opcode:   "MOVQ",
			Operands: []operand.Op{imrx, mrx},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mrx},
		}, nil
	}
	return nil, errors.New("MOVQ: bad operands")
}

// MOVSD: Move Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	MOVSD m64 xmm
// 	MOVSD xmm m64
// 	MOVSD xmm xmm
func MOVSD(mx, mx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVSD",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx, mx1},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE2"},
		}, nil
	case operand.IsM64(mx) && operand.IsXMM(mx1),
		operand.IsXMM(mx) && operand.IsM64(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVSD",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MOVSD: bad operands")
}

// MOVSHDUP: Move Packed Single-FP High and Duplicate.
//
// Forms:
//
// 	MOVSHDUP m128 xmm
// 	MOVSHDUP xmm  xmm
func MOVSHDUP(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MOVSHDUP",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE3"},
		}, nil
	}
	return nil, errors.New("MOVSHDUP: bad operands")
}

// MOVSLDUP: Move Packed Single-FP Low and Duplicate.
//
// Forms:
//
// 	MOVSLDUP m128 xmm
// 	MOVSLDUP xmm  xmm
func MOVSLDUP(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MOVSLDUP",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE3"},
		}, nil
	}
	return nil, errors.New("MOVSLDUP: bad operands")
}

// MOVSS: Move Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	MOVSS m32 xmm
// 	MOVSS xmm m32
// 	MOVSS xmm xmm
func MOVSS(mx, mx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVSS",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx, mx1},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE"},
		}, nil
	case operand.IsM32(mx) && operand.IsXMM(mx1),
		operand.IsXMM(mx) && operand.IsM32(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVSS",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MOVSS: bad operands")
}

// MOVUPD: Move Unaligned Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	MOVUPD m128 xmm
// 	MOVUPD xmm  m128
// 	MOVUPD xmm  xmm
func MOVUPD(mx, mx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(mx1),
		operand.IsXMM(mx) && operand.IsM128(mx1),
		operand.IsXMM(mx) && operand.IsXMM(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVUPD",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MOVUPD: bad operands")
}

// MOVUPS: Move Unaligned Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	MOVUPS m128 xmm
// 	MOVUPS xmm  m128
// 	MOVUPS xmm  xmm
func MOVUPS(mx, mx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(mx1),
		operand.IsXMM(mx) && operand.IsM128(mx1),
		operand.IsXMM(mx) && operand.IsXMM(mx1):
		return &intrep.Instruction{
			Opcode:   "MOVUPS",
			Operands: []operand.Op{mx, mx1},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{mx1},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MOVUPS: bad operands")
}

// MOVW: Move.
//
// Forms:
//
// 	MOVW imm16 m16
// 	MOVW imm16 r16
// 	MOVW m16   r16
// 	MOVW r16   m16
// 	MOVW r16   r16
func MOVW(imr, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(imr) && operand.IsR16(mr),
		operand.IsR16(imr) && operand.IsM16(mr),
		operand.IsR16(imr) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "MOVW",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{imr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM16(imr) && operand.IsM16(mr),
		operand.IsIMM16(imr) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "MOVW",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("MOVW: bad operands")
}

// MOVWLSX: Move with Sign-Extension.
//
// Forms:
//
// 	MOVWLSX m16 r32
// 	MOVWLSX r16 r32
func MOVWLSX(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR32(r),
		operand.IsR16(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "MOVWLSX",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("MOVWLSX: bad operands")
}

// MOVWLZX: Move with Zero-Extend.
//
// Forms:
//
// 	MOVWLZX m16 r32
// 	MOVWLZX r16 r32
func MOVWLZX(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR32(r),
		operand.IsR16(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "MOVWLZX",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("MOVWLZX: bad operands")
}

// MOVWQSX: Move with Sign-Extension.
//
// Forms:
//
// 	MOVWQSX m16 r64
// 	MOVWQSX r16 r64
func MOVWQSX(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR64(r),
		operand.IsR16(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "MOVWQSX",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("MOVWQSX: bad operands")
}

// MOVWQZX: Move with Zero-Extend.
//
// Forms:
//
// 	MOVWQZX m16 r64
// 	MOVWQZX r16 r64
func MOVWQZX(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR64(r),
		operand.IsR16(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "MOVWQZX",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
		}, nil
	}
	return nil, errors.New("MOVWQZX: bad operands")
}

// MPSADBW: Compute Multiple Packed Sums of Absolute Difference.
//
// Forms:
//
// 	MPSADBW imm8 m128 xmm
// 	MPSADBW imm8 xmm  xmm
func MPSADBW(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MPSADBW",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("MPSADBW: bad operands")
}

// MULB: Unsigned Multiply.
//
// Forms:
//
// 	MULB m8
// 	MULB r8
func MULB(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "MULB",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr, reg.AL},
			Outputs:  []operand.Op{reg.AX},
		}, nil
	}
	return nil, errors.New("MULB: bad operands")
}

// MULL: Unsigned Multiply.
//
// Forms:
//
// 	MULL m32
// 	MULL r32
func MULL(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr),
		operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "MULL",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr, reg.EAX},
			Outputs:  []operand.Op{reg.EAX, reg.EDX},
		}, nil
	}
	return nil, errors.New("MULL: bad operands")
}

// MULPD: Multiply Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	MULPD m128 xmm
// 	MULPD xmm  xmm
func MULPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MULPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MULPD: bad operands")
}

// MULPS: Multiply Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	MULPS m128 xmm
// 	MULPS xmm  xmm
func MULPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MULPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MULPS: bad operands")
}

// MULQ: Unsigned Multiply.
//
// Forms:
//
// 	MULQ m64
// 	MULQ r64
func MULQ(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr),
		operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "MULQ",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr, reg.RAX},
			Outputs:  []operand.Op{reg.RAX, reg.RDX},
		}, nil
	}
	return nil, errors.New("MULQ: bad operands")
}

// MULSD: Multiply Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	MULSD m64 xmm
// 	MULSD xmm xmm
func MULSD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MULSD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("MULSD: bad operands")
}

// MULSS: Multiply Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	MULSS m32 xmm
// 	MULSS xmm xmm
func MULSS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "MULSS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("MULSS: bad operands")
}

// MULW: Unsigned Multiply.
//
// Forms:
//
// 	MULW m16
// 	MULW r16
func MULW(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr),
		operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "MULW",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr, reg.AX},
			Outputs:  []operand.Op{reg.AX, reg.DX},
		}, nil
	}
	return nil, errors.New("MULW: bad operands")
}

// MULXL: Unsigned Multiply Without Affecting Flags.
//
// Forms:
//
// 	MULXL m32 r32 r32
// 	MULXL r32 r32 r32
func MULXL(mr, r, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r) && operand.IsR32(r1),
		operand.IsR32(mr) && operand.IsR32(r) && operand.IsR32(r1):
		return &intrep.Instruction{
			Opcode:   "MULXL",
			Operands: []operand.Op{mr, r, r1},
			Inputs:   []operand.Op{mr, reg.EDX},
			Outputs:  []operand.Op{r, r1},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("MULXL: bad operands")
}

// MULXQ: Unsigned Multiply Without Affecting Flags.
//
// Forms:
//
// 	MULXQ m64 r64 r64
// 	MULXQ r64 r64 r64
func MULXQ(mr, r, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r) && operand.IsR64(r1),
		operand.IsR64(mr) && operand.IsR64(r) && operand.IsR64(r1):
		return &intrep.Instruction{
			Opcode:   "MULXQ",
			Operands: []operand.Op{mr, r, r1},
			Inputs:   []operand.Op{mr, reg.RDX},
			Outputs:  []operand.Op{r, r1},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("MULXQ: bad operands")
}

// MWAIT: Monitor Wait.
//
// Forms:
//
// 	MWAIT
func MWAIT() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "MWAIT",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{reg.EAX, reg.ECX},
		Outputs:  []operand.Op{},
		ISA:      []string{"MONITOR"},
	}, nil
}

// NEGB: Two's Complement Negation.
//
// Forms:
//
// 	NEGB m8
// 	NEGB r8
func NEGB(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "NEGB",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("NEGB: bad operands")
}

// NEGL: Two's Complement Negation.
//
// Forms:
//
// 	NEGL m32
// 	NEGL r32
func NEGL(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr),
		operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "NEGL",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("NEGL: bad operands")
}

// NEGQ: Two's Complement Negation.
//
// Forms:
//
// 	NEGQ m64
// 	NEGQ r64
func NEGQ(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr),
		operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "NEGQ",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("NEGQ: bad operands")
}

// NEGW: Two's Complement Negation.
//
// Forms:
//
// 	NEGW m16
// 	NEGW r16
func NEGW(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr),
		operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "NEGW",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("NEGW: bad operands")
}

// NOP: No Operation.
//
// Forms:
//
// 	NOP
func NOP() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "NOP",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{},
	}, nil
}

// NOTB: One's Complement Negation.
//
// Forms:
//
// 	NOTB m8
// 	NOTB r8
func NOTB(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "NOTB",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("NOTB: bad operands")
}

// NOTL: One's Complement Negation.
//
// Forms:
//
// 	NOTL m32
// 	NOTL r32
func NOTL(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr),
		operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "NOTL",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("NOTL: bad operands")
}

// NOTQ: One's Complement Negation.
//
// Forms:
//
// 	NOTQ m64
// 	NOTQ r64
func NOTQ(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr),
		operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "NOTQ",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("NOTQ: bad operands")
}

// NOTW: One's Complement Negation.
//
// Forms:
//
// 	NOTW m16
// 	NOTW r16
func NOTW(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr),
		operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "NOTW",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("NOTW: bad operands")
}

// ORB: Logical Inclusive OR.
//
// Forms:
//
// 	ORB imm8 al
// 	ORB imm8 m8
// 	ORB imm8 r8
// 	ORB m8   r8
// 	ORB r8   m8
// 	ORB r8   r8
func ORB(imr, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(imr) && operand.IsAL(amr),
		operand.IsIMM8(imr) && operand.IsM8(amr),
		operand.IsIMM8(imr) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:   "ORB",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{amr},
		}, nil
	case operand.IsM8(imr) && operand.IsR8(amr),
		operand.IsR8(imr) && operand.IsM8(amr),
		operand.IsR8(imr) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:   "ORB",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{imr, amr},
			Outputs:  []operand.Op{amr},
		}, nil
	}
	return nil, errors.New("ORB: bad operands")
}

// ORL: Logical Inclusive OR.
//
// Forms:
//
// 	ORL imm32 eax
// 	ORL imm32 m32
// 	ORL imm32 r32
// 	ORL imm8  m32
// 	ORL imm8  r32
// 	ORL m32   r32
// 	ORL r32   m32
// 	ORL r32   r32
func ORL(imr, emr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM32(imr) && operand.IsEAX(emr),
		operand.IsIMM32(imr) && operand.IsM32(emr),
		operand.IsIMM32(imr) && operand.IsR32(emr),
		operand.IsIMM8(imr) && operand.IsM32(emr),
		operand.IsIMM8(imr) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:   "ORL",
			Operands: []operand.Op{imr, emr},
			Inputs:   []operand.Op{emr},
			Outputs:  []operand.Op{emr},
		}, nil
	case operand.IsM32(imr) && operand.IsR32(emr),
		operand.IsR32(imr) && operand.IsM32(emr),
		operand.IsR32(imr) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:   "ORL",
			Operands: []operand.Op{imr, emr},
			Inputs:   []operand.Op{imr, emr},
			Outputs:  []operand.Op{emr},
		}, nil
	}
	return nil, errors.New("ORL: bad operands")
}

// ORPD: Bitwise Logical OR of Double-Precision Floating-Point Values.
//
// Forms:
//
// 	ORPD m128 xmm
// 	ORPD xmm  xmm
func ORPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ORPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("ORPD: bad operands")
}

// ORPS: Bitwise Logical OR of Single-Precision Floating-Point Values.
//
// Forms:
//
// 	ORPS m128 xmm
// 	ORPS xmm  xmm
func ORPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ORPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("ORPS: bad operands")
}

// ORQ: Logical Inclusive OR.
//
// Forms:
//
// 	ORQ imm32 m64
// 	ORQ imm32 r64
// 	ORQ imm32 rax
// 	ORQ imm8  m64
// 	ORQ imm8  r64
// 	ORQ m64   r64
// 	ORQ r64   m64
// 	ORQ r64   r64
func ORQ(imr, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(imr) && operand.IsR64(mr),
		operand.IsR64(imr) && operand.IsM64(mr),
		operand.IsR64(imr) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "ORQ",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{imr, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM32(imr) && operand.IsM64(mr),
		operand.IsIMM32(imr) && operand.IsR64(mr),
		operand.IsIMM32(imr) && operand.IsRAX(mr),
		operand.IsIMM8(imr) && operand.IsM64(mr),
		operand.IsIMM8(imr) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "ORQ",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("ORQ: bad operands")
}

// ORW: Logical Inclusive OR.
//
// Forms:
//
// 	ORW imm16 ax
// 	ORW imm16 m16
// 	ORW imm16 r16
// 	ORW imm8  m16
// 	ORW imm8  r16
// 	ORW m16   r16
// 	ORW r16   m16
// 	ORW r16   r16
func ORW(imr, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM16(imr) && operand.IsAX(amr),
		operand.IsIMM16(imr) && operand.IsM16(amr),
		operand.IsIMM16(imr) && operand.IsR16(amr),
		operand.IsIMM8(imr) && operand.IsM16(amr),
		operand.IsIMM8(imr) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:   "ORW",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{amr},
		}, nil
	case operand.IsM16(imr) && operand.IsR16(amr),
		operand.IsR16(imr) && operand.IsM16(amr),
		operand.IsR16(imr) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:   "ORW",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{imr, amr},
			Outputs:  []operand.Op{amr},
		}, nil
	}
	return nil, errors.New("ORW: bad operands")
}

// PABSB: Packed Absolute Value of Byte Integers.
//
// Forms:
//
// 	PABSB m128 xmm
// 	PABSB xmm  xmm
func PABSB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PABSB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PABSB: bad operands")
}

// PABSD: Packed Absolute Value of Doubleword Integers.
//
// Forms:
//
// 	PABSD m128 xmm
// 	PABSD xmm  xmm
func PABSD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PABSD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PABSD: bad operands")
}

// PABSW: Packed Absolute Value of Word Integers.
//
// Forms:
//
// 	PABSW m128 xmm
// 	PABSW xmm  xmm
func PABSW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PABSW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PABSW: bad operands")
}

// PACKSSLW: Pack Doublewords into Words with Signed Saturation.
//
// Forms:
//
// 	PACKSSLW m128 xmm
// 	PACKSSLW xmm  xmm
func PACKSSLW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PACKSSLW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PACKSSLW: bad operands")
}

// PACKSSWB: Pack Words into Bytes with Signed Saturation.
//
// Forms:
//
// 	PACKSSWB m128 xmm
// 	PACKSSWB xmm  xmm
func PACKSSWB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PACKSSWB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PACKSSWB: bad operands")
}

// PACKUSDW: Pack Doublewords into Words with Unsigned Saturation.
//
// Forms:
//
// 	PACKUSDW m128 xmm
// 	PACKUSDW xmm  xmm
func PACKUSDW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PACKUSDW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PACKUSDW: bad operands")
}

// PACKUSWB: Pack Words into Bytes with Unsigned Saturation.
//
// Forms:
//
// 	PACKUSWB m128 xmm
// 	PACKUSWB xmm  xmm
func PACKUSWB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PACKUSWB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PACKUSWB: bad operands")
}

// PADDB: Add Packed Byte Integers.
//
// Forms:
//
// 	PADDB m128 xmm
// 	PADDB xmm  xmm
func PADDB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PADDB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PADDB: bad operands")
}

// PADDD: Add Packed Doubleword Integers.
//
// Forms:
//
// 	PADDD m128 xmm
// 	PADDD xmm  xmm
func PADDD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PADDD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PADDD: bad operands")
}

// PADDL: Add Packed Doubleword Integers.
//
// Forms:
//
// 	PADDL m128 xmm
// 	PADDL xmm  xmm
func PADDL(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PADDL",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PADDL: bad operands")
}

// PADDQ: Add Packed Quadword Integers.
//
// Forms:
//
// 	PADDQ m128 xmm
// 	PADDQ xmm  xmm
func PADDQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PADDQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PADDQ: bad operands")
}

// PADDSB: Add Packed Signed Byte Integers with Signed Saturation.
//
// Forms:
//
// 	PADDSB m128 xmm
// 	PADDSB xmm  xmm
func PADDSB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PADDSB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PADDSB: bad operands")
}

// PADDSW: Add Packed Signed Word Integers with Signed Saturation.
//
// Forms:
//
// 	PADDSW m128 xmm
// 	PADDSW xmm  xmm
func PADDSW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PADDSW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PADDSW: bad operands")
}

// PADDUSB: Add Packed Unsigned Byte Integers with Unsigned Saturation.
//
// Forms:
//
// 	PADDUSB m128 xmm
// 	PADDUSB xmm  xmm
func PADDUSB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PADDUSB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PADDUSB: bad operands")
}

// PADDUSW: Add Packed Unsigned Word Integers with Unsigned Saturation.
//
// Forms:
//
// 	PADDUSW m128 xmm
// 	PADDUSW xmm  xmm
func PADDUSW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PADDUSW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PADDUSW: bad operands")
}

// PADDW: Add Packed Word Integers.
//
// Forms:
//
// 	PADDW m128 xmm
// 	PADDW xmm  xmm
func PADDW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PADDW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PADDW: bad operands")
}

// PALIGNR: Packed Align Right.
//
// Forms:
//
// 	PALIGNR imm8 m128 xmm
// 	PALIGNR imm8 xmm  xmm
func PALIGNR(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PALIGNR",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PALIGNR: bad operands")
}

// PAND: Packed Bitwise Logical AND.
//
// Forms:
//
// 	PAND m128 xmm
// 	PAND xmm  xmm
func PAND(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PAND",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PAND: bad operands")
}

// PANDN: Packed Bitwise Logical AND NOT.
//
// Forms:
//
// 	PANDN m128 xmm
// 	PANDN xmm  xmm
func PANDN(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PANDN",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PANDN",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PANDN: bad operands")
}

// PAUSE: Spin Loop Hint.
//
// Forms:
//
// 	PAUSE
func PAUSE() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "PAUSE",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{},
	}, nil
}

// PAVGB: Average Packed Byte Integers.
//
// Forms:
//
// 	PAVGB m128 xmm
// 	PAVGB xmm  xmm
func PAVGB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PAVGB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PAVGB: bad operands")
}

// PAVGW: Average Packed Word Integers.
//
// Forms:
//
// 	PAVGW m128 xmm
// 	PAVGW xmm  xmm
func PAVGW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PAVGW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PAVGW: bad operands")
}

// PBLENDVB: Variable Blend Packed Bytes.
//
// Forms:
//
// 	PBLENDVB xmm0 m128 xmm
// 	PBLENDVB xmm0 xmm  xmm
func PBLENDVB(x, mx, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM0(x) && operand.IsM128(mx) && operand.IsXMM(x1),
		operand.IsXMM0(x) && operand.IsXMM(mx) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "PBLENDVB",
			Operands: []operand.Op{x, mx, x1},
			Inputs:   []operand.Op{x, mx, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PBLENDVB: bad operands")
}

// PBLENDW: Blend Packed Words.
//
// Forms:
//
// 	PBLENDW imm8 m128 xmm
// 	PBLENDW imm8 xmm  xmm
func PBLENDW(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PBLENDW",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PBLENDW: bad operands")
}

// PCLMULQDQ: Carry-Less Quadword Multiplication.
//
// Forms:
//
// 	PCLMULQDQ imm8 m128 xmm
// 	PCLMULQDQ imm8 xmm  xmm
func PCLMULQDQ(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PCLMULQDQ",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"PCLMULQDQ"},
		}, nil
	}
	return nil, errors.New("PCLMULQDQ: bad operands")
}

// PCMPEQB: Compare Packed Byte Data for Equality.
//
// Forms:
//
// 	PCMPEQB m128 xmm
// 	PCMPEQB xmm  xmm
func PCMPEQB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PCMPEQB",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PCMPEQB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PCMPEQB: bad operands")
}

// PCMPEQL: Compare Packed Doubleword Data for Equality.
//
// Forms:
//
// 	PCMPEQL m128 xmm
// 	PCMPEQL xmm  xmm
func PCMPEQL(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PCMPEQL",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PCMPEQL",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PCMPEQL: bad operands")
}

// PCMPEQQ: Compare Packed Quadword Data for Equality.
//
// Forms:
//
// 	PCMPEQQ m128 xmm
// 	PCMPEQQ xmm  xmm
func PCMPEQQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PCMPEQQ",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE4.1"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PCMPEQQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PCMPEQQ: bad operands")
}

// PCMPEQW: Compare Packed Word Data for Equality.
//
// Forms:
//
// 	PCMPEQW m128 xmm
// 	PCMPEQW xmm  xmm
func PCMPEQW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PCMPEQW",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PCMPEQW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PCMPEQW: bad operands")
}

// PCMPESTRI: Packed Compare Explicit Length Strings, Return Index.
//
// Forms:
//
// 	PCMPESTRI imm8 m128 xmm
// 	PCMPESTRI imm8 xmm  xmm
func PCMPESTRI(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PCMPESTRI",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x, reg.EAX, reg.EDX},
			Outputs:  []operand.Op{reg.ECX},
			ISA:      []string{"SSE4.2"},
		}, nil
	}
	return nil, errors.New("PCMPESTRI: bad operands")
}

// PCMPESTRM: Packed Compare Explicit Length Strings, Return Mask.
//
// Forms:
//
// 	PCMPESTRM imm8 m128 xmm
// 	PCMPESTRM imm8 xmm  xmm
func PCMPESTRM(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PCMPESTRM",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x, reg.EAX, reg.EDX},
			Outputs:  []operand.Op{reg.X0},
			ISA:      []string{"SSE4.2"},
		}, nil
	}
	return nil, errors.New("PCMPESTRM: bad operands")
}

// PCMPGTB: Compare Packed Signed Byte Integers for Greater Than.
//
// Forms:
//
// 	PCMPGTB m128 xmm
// 	PCMPGTB xmm  xmm
func PCMPGTB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PCMPGTB",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PCMPGTB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PCMPGTB: bad operands")
}

// PCMPGTL: Compare Packed Signed Doubleword Integers for Greater Than.
//
// Forms:
//
// 	PCMPGTL m128 xmm
// 	PCMPGTL xmm  xmm
func PCMPGTL(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PCMPGTL",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PCMPGTL",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PCMPGTL: bad operands")
}

// PCMPGTQ: Compare Packed Data for Greater Than.
//
// Forms:
//
// 	PCMPGTQ m128 xmm
// 	PCMPGTQ xmm  xmm
func PCMPGTQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PCMPGTQ",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE4.2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PCMPGTQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.2"},
		}, nil
	}
	return nil, errors.New("PCMPGTQ: bad operands")
}

// PCMPGTW: Compare Packed Signed Word Integers for Greater Than.
//
// Forms:
//
// 	PCMPGTW m128 xmm
// 	PCMPGTW xmm  xmm
func PCMPGTW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PCMPGTW",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PCMPGTW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PCMPGTW: bad operands")
}

// PCMPISTRI: Packed Compare Implicit Length Strings, Return Index.
//
// Forms:
//
// 	PCMPISTRI imm8 m128 xmm
// 	PCMPISTRI imm8 xmm  xmm
func PCMPISTRI(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PCMPISTRI",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{reg.ECX},
			ISA:      []string{"SSE4.2"},
		}, nil
	}
	return nil, errors.New("PCMPISTRI: bad operands")
}

// PCMPISTRM: Packed Compare Implicit Length Strings, Return Mask.
//
// Forms:
//
// 	PCMPISTRM imm8 m128 xmm
// 	PCMPISTRM imm8 xmm  xmm
func PCMPISTRM(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PCMPISTRM",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{reg.X0},
			ISA:      []string{"SSE4.2"},
		}, nil
	}
	return nil, errors.New("PCMPISTRM: bad operands")
}

// PDEPL: Parallel Bits Deposit.
//
// Forms:
//
// 	PDEPL m32 r32 r32
// 	PDEPL r32 r32 r32
func PDEPL(mr, r, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r) && operand.IsR32(r1),
		operand.IsR32(mr) && operand.IsR32(r) && operand.IsR32(r1):
		return &intrep.Instruction{
			Opcode:   "PDEPL",
			Operands: []operand.Op{mr, r, r1},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("PDEPL: bad operands")
}

// PDEPQ: Parallel Bits Deposit.
//
// Forms:
//
// 	PDEPQ m64 r64 r64
// 	PDEPQ r64 r64 r64
func PDEPQ(mr, r, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r) && operand.IsR64(r1),
		operand.IsR64(mr) && operand.IsR64(r) && operand.IsR64(r1):
		return &intrep.Instruction{
			Opcode:   "PDEPQ",
			Operands: []operand.Op{mr, r, r1},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("PDEPQ: bad operands")
}

// PEXTL: Parallel Bits Extract.
//
// Forms:
//
// 	PEXTL m32 r32 r32
// 	PEXTL r32 r32 r32
func PEXTL(mr, r, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r) && operand.IsR32(r1),
		operand.IsR32(mr) && operand.IsR32(r) && operand.IsR32(r1):
		return &intrep.Instruction{
			Opcode:   "PEXTL",
			Operands: []operand.Op{mr, r, r1},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("PEXTL: bad operands")
}

// PEXTQ: Parallel Bits Extract.
//
// Forms:
//
// 	PEXTQ m64 r64 r64
// 	PEXTQ r64 r64 r64
func PEXTQ(mr, r, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r) && operand.IsR64(r1),
		operand.IsR64(mr) && operand.IsR64(r) && operand.IsR64(r1):
		return &intrep.Instruction{
			Opcode:   "PEXTQ",
			Operands: []operand.Op{mr, r, r1},
			Inputs:   []operand.Op{mr, r},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("PEXTQ: bad operands")
}

// PEXTRB: Extract Byte.
//
// Forms:
//
// 	PEXTRB imm8 xmm m8
// 	PEXTRB imm8 xmm r32
func PEXTRB(i, x, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsM8(mr),
		operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "PEXTRB",
			Operands: []operand.Op{i, x, mr},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{mr},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PEXTRB: bad operands")
}

// PEXTRD: Extract Doubleword.
//
// Forms:
//
// 	PEXTRD imm8 xmm m32
// 	PEXTRD imm8 xmm r32
func PEXTRD(i, x, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsM32(mr),
		operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "PEXTRD",
			Operands: []operand.Op{i, x, mr},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{mr},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PEXTRD: bad operands")
}

// PEXTRQ: Extract Quadword.
//
// Forms:
//
// 	PEXTRQ imm8 xmm m64
// 	PEXTRQ imm8 xmm r64
func PEXTRQ(i, x, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsM64(mr),
		operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "PEXTRQ",
			Operands: []operand.Op{i, x, mr},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{mr},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PEXTRQ: bad operands")
}

// PEXTRW: Extract Word.
//
// Forms:
//
// 	PEXTRW imm8 xmm m16
// 	PEXTRW imm8 xmm r32
func PEXTRW(i, x, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsM16(mr),
		operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "PEXTRW",
			Operands: []operand.Op{i, x, mr},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{mr},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PEXTRW: bad operands")
}

// PHADDD: Packed Horizontal Add Doubleword Integer.
//
// Forms:
//
// 	PHADDD m128 xmm
// 	PHADDD xmm  xmm
func PHADDD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PHADDD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PHADDD: bad operands")
}

// PHADDSW: Packed Horizontal Add Signed Word Integers with Signed Saturation.
//
// Forms:
//
// 	PHADDSW m128 xmm
// 	PHADDSW xmm  xmm
func PHADDSW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PHADDSW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PHADDSW: bad operands")
}

// PHADDW: Packed Horizontal Add Word Integers.
//
// Forms:
//
// 	PHADDW m128 xmm
// 	PHADDW xmm  xmm
func PHADDW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PHADDW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PHADDW: bad operands")
}

// PHMINPOSUW: Packed Horizontal Minimum of Unsigned Word Integers.
//
// Forms:
//
// 	PHMINPOSUW m128 xmm
// 	PHMINPOSUW xmm  xmm
func PHMINPOSUW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PHMINPOSUW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PHMINPOSUW: bad operands")
}

// PHSUBD: Packed Horizontal Subtract Doubleword Integers.
//
// Forms:
//
// 	PHSUBD m128 xmm
// 	PHSUBD xmm  xmm
func PHSUBD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PHSUBD",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSSE3"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PHSUBD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PHSUBD: bad operands")
}

// PHSUBSW: Packed Horizontal Subtract Signed Word Integers with Signed Saturation.
//
// Forms:
//
// 	PHSUBSW m128 xmm
// 	PHSUBSW xmm  xmm
func PHSUBSW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PHSUBSW",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSSE3"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PHSUBSW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PHSUBSW: bad operands")
}

// PHSUBW: Packed Horizontal Subtract Word Integers.
//
// Forms:
//
// 	PHSUBW m128 xmm
// 	PHSUBW xmm  xmm
func PHSUBW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PHSUBW",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSSE3"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PHSUBW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PHSUBW: bad operands")
}

// PINSRB: Insert Byte.
//
// Forms:
//
// 	PINSRB imm8 m8  xmm
// 	PINSRB imm8 r32 xmm
func PINSRB(i, mr, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM8(mr) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsR32(mr) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PINSRB",
			Operands: []operand.Op{i, mr, x},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PINSRB: bad operands")
}

// PINSRD: Insert Doubleword.
//
// Forms:
//
// 	PINSRD imm8 m32 xmm
// 	PINSRD imm8 r32 xmm
func PINSRD(i, mr, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(mr) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsR32(mr) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PINSRD",
			Operands: []operand.Op{i, mr, x},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PINSRD: bad operands")
}

// PINSRQ: Insert Quadword.
//
// Forms:
//
// 	PINSRQ imm8 m64 xmm
// 	PINSRQ imm8 r64 xmm
func PINSRQ(i, mr, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(mr) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsR64(mr) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PINSRQ",
			Operands: []operand.Op{i, mr, x},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PINSRQ: bad operands")
}

// PINSRW: Insert Word.
//
// Forms:
//
// 	PINSRW imm8 m16 xmm
// 	PINSRW imm8 r32 xmm
func PINSRW(i, mr, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM16(mr) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsR32(mr) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PINSRW",
			Operands: []operand.Op{i, mr, x},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PINSRW: bad operands")
}

// PMADDUBSW: Multiply and Add Packed Signed and Unsigned Byte Integers.
//
// Forms:
//
// 	PMADDUBSW m128 xmm
// 	PMADDUBSW xmm  xmm
func PMADDUBSW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMADDUBSW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PMADDUBSW: bad operands")
}

// PMADDWL: Multiply and Add Packed Signed Word Integers.
//
// Forms:
//
// 	PMADDWL m128 xmm
// 	PMADDWL xmm  xmm
func PMADDWL(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMADDWL",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PMADDWL: bad operands")
}

// PMAXSB: Maximum of Packed Signed Byte Integers.
//
// Forms:
//
// 	PMAXSB m128 xmm
// 	PMAXSB xmm  xmm
func PMAXSB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMAXSB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMAXSB: bad operands")
}

// PMAXSD: Maximum of Packed Signed Doubleword Integers.
//
// Forms:
//
// 	PMAXSD m128 xmm
// 	PMAXSD xmm  xmm
func PMAXSD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMAXSD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMAXSD: bad operands")
}

// PMAXSW: Maximum of Packed Signed Word Integers.
//
// Forms:
//
// 	PMAXSW m128 xmm
// 	PMAXSW xmm  xmm
func PMAXSW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMAXSW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PMAXSW: bad operands")
}

// PMAXUB: Maximum of Packed Unsigned Byte Integers.
//
// Forms:
//
// 	PMAXUB m128 xmm
// 	PMAXUB xmm  xmm
func PMAXUB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMAXUB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PMAXUB: bad operands")
}

// PMAXUD: Maximum of Packed Unsigned Doubleword Integers.
//
// Forms:
//
// 	PMAXUD m128 xmm
// 	PMAXUD xmm  xmm
func PMAXUD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMAXUD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMAXUD: bad operands")
}

// PMAXUW: Maximum of Packed Unsigned Word Integers.
//
// Forms:
//
// 	PMAXUW m128 xmm
// 	PMAXUW xmm  xmm
func PMAXUW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMAXUW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMAXUW: bad operands")
}

// PMINSB: Minimum of Packed Signed Byte Integers.
//
// Forms:
//
// 	PMINSB m128 xmm
// 	PMINSB xmm  xmm
func PMINSB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMINSB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMINSB: bad operands")
}

// PMINSD: Minimum of Packed Signed Doubleword Integers.
//
// Forms:
//
// 	PMINSD m128 xmm
// 	PMINSD xmm  xmm
func PMINSD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMINSD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMINSD: bad operands")
}

// PMINSW: Minimum of Packed Signed Word Integers.
//
// Forms:
//
// 	PMINSW m128 xmm
// 	PMINSW xmm  xmm
func PMINSW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMINSW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PMINSW: bad operands")
}

// PMINUB: Minimum of Packed Unsigned Byte Integers.
//
// Forms:
//
// 	PMINUB m128 xmm
// 	PMINUB xmm  xmm
func PMINUB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMINUB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PMINUB: bad operands")
}

// PMINUD: Minimum of Packed Unsigned Doubleword Integers.
//
// Forms:
//
// 	PMINUD m128 xmm
// 	PMINUD xmm  xmm
func PMINUD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMINUD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMINUD: bad operands")
}

// PMINUW: Minimum of Packed Unsigned Word Integers.
//
// Forms:
//
// 	PMINUW m128 xmm
// 	PMINUW xmm  xmm
func PMINUW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMINUW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMINUW: bad operands")
}

// PMOVMSKB: Move Byte Mask.
//
// Forms:
//
// 	PMOVMSKB xmm r32
func PMOVMSKB(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "PMOVMSKB",
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PMOVMSKB: bad operands")
}

// PMOVSXBD: Move Packed Byte Integers to Doubleword Integers with Sign Extension.
//
// Forms:
//
// 	PMOVSXBD m32 xmm
// 	PMOVSXBD xmm xmm
func PMOVSXBD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMOVSXBD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMOVSXBD: bad operands")
}

// PMOVSXBQ: Move Packed Byte Integers to Quadword Integers with Sign Extension.
//
// Forms:
//
// 	PMOVSXBQ m16 xmm
// 	PMOVSXBQ xmm xmm
func PMOVSXBQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMOVSXBQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMOVSXBQ: bad operands")
}

// PMOVSXBW: Move Packed Byte Integers to Word Integers with Sign Extension.
//
// Forms:
//
// 	PMOVSXBW m64 xmm
// 	PMOVSXBW xmm xmm
func PMOVSXBW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMOVSXBW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMOVSXBW: bad operands")
}

// PMOVSXDQ: Move Packed Doubleword Integers to Quadword Integers with Sign Extension.
//
// Forms:
//
// 	PMOVSXDQ m64 xmm
// 	PMOVSXDQ xmm xmm
func PMOVSXDQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMOVSXDQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMOVSXDQ: bad operands")
}

// PMOVSXWD: Move Packed Word Integers to Doubleword Integers with Sign Extension.
//
// Forms:
//
// 	PMOVSXWD m64 xmm
// 	PMOVSXWD xmm xmm
func PMOVSXWD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMOVSXWD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMOVSXWD: bad operands")
}

// PMOVSXWQ: Move Packed Word Integers to Quadword Integers with Sign Extension.
//
// Forms:
//
// 	PMOVSXWQ m32 xmm
// 	PMOVSXWQ xmm xmm
func PMOVSXWQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMOVSXWQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMOVSXWQ: bad operands")
}

// PMOVZXBD: Move Packed Byte Integers to Doubleword Integers with Zero Extension.
//
// Forms:
//
// 	PMOVZXBD m32 xmm
// 	PMOVZXBD xmm xmm
func PMOVZXBD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMOVZXBD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMOVZXBD: bad operands")
}

// PMOVZXBQ: Move Packed Byte Integers to Quadword Integers with Zero Extension.
//
// Forms:
//
// 	PMOVZXBQ m16 xmm
// 	PMOVZXBQ xmm xmm
func PMOVZXBQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMOVZXBQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMOVZXBQ: bad operands")
}

// PMOVZXBW: Move Packed Byte Integers to Word Integers with Zero Extension.
//
// Forms:
//
// 	PMOVZXBW m64 xmm
// 	PMOVZXBW xmm xmm
func PMOVZXBW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMOVZXBW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMOVZXBW: bad operands")
}

// PMOVZXDQ: Move Packed Doubleword Integers to Quadword Integers with Zero Extension.
//
// Forms:
//
// 	PMOVZXDQ m64 xmm
// 	PMOVZXDQ xmm xmm
func PMOVZXDQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMOVZXDQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMOVZXDQ: bad operands")
}

// PMOVZXWD: Move Packed Word Integers to Doubleword Integers with Zero Extension.
//
// Forms:
//
// 	PMOVZXWD m64 xmm
// 	PMOVZXWD xmm xmm
func PMOVZXWD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMOVZXWD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMOVZXWD: bad operands")
}

// PMOVZXWQ: Move Packed Word Integers to Quadword Integers with Zero Extension.
//
// Forms:
//
// 	PMOVZXWQ m32 xmm
// 	PMOVZXWQ xmm xmm
func PMOVZXWQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMOVZXWQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMOVZXWQ: bad operands")
}

// PMULDQ: Multiply Packed Signed Doubleword Integers and Store Quadword Result.
//
// Forms:
//
// 	PMULDQ m128 xmm
// 	PMULDQ xmm  xmm
func PMULDQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMULDQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMULDQ: bad operands")
}

// PMULHRSW: Packed Multiply Signed Word Integers and Store High Result with Round and Scale.
//
// Forms:
//
// 	PMULHRSW m128 xmm
// 	PMULHRSW xmm  xmm
func PMULHRSW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMULHRSW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PMULHRSW: bad operands")
}

// PMULHUW: Multiply Packed Unsigned Word Integers and Store High Result.
//
// Forms:
//
// 	PMULHUW m128 xmm
// 	PMULHUW xmm  xmm
func PMULHUW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMULHUW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PMULHUW: bad operands")
}

// PMULHW: Multiply Packed Signed Word Integers and Store High Result.
//
// Forms:
//
// 	PMULHW m128 xmm
// 	PMULHW xmm  xmm
func PMULHW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMULHW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PMULHW: bad operands")
}

// PMULLD: Multiply Packed Signed Doubleword Integers and Store Low Result.
//
// Forms:
//
// 	PMULLD m128 xmm
// 	PMULLD xmm  xmm
func PMULLD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMULLD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PMULLD: bad operands")
}

// PMULLW: Multiply Packed Signed Word Integers and Store Low Result.
//
// Forms:
//
// 	PMULLW m128 xmm
// 	PMULLW xmm  xmm
func PMULLW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMULLW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PMULLW: bad operands")
}

// PMULULQ: Multiply Packed Unsigned Doubleword Integers.
//
// Forms:
//
// 	PMULULQ m128 xmm
// 	PMULULQ xmm  xmm
func PMULULQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PMULULQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PMULULQ: bad operands")
}

// POPCNTL: Count of Number of Bits Set to 1.
//
// Forms:
//
// 	POPCNTL m32 r32
// 	POPCNTL r32 r32
func POPCNTL(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "POPCNTL",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"POPCNT"},
		}, nil
	}
	return nil, errors.New("POPCNTL: bad operands")
}

// POPCNTQ: Count of Number of Bits Set to 1.
//
// Forms:
//
// 	POPCNTQ m64 r64
// 	POPCNTQ r64 r64
func POPCNTQ(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "POPCNTQ",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"POPCNT"},
		}, nil
	}
	return nil, errors.New("POPCNTQ: bad operands")
}

// POPCNTW: Count of Number of Bits Set to 1.
//
// Forms:
//
// 	POPCNTW m16 r16
// 	POPCNTW r16 r16
func POPCNTW(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "POPCNTW",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"POPCNT"},
		}, nil
	}
	return nil, errors.New("POPCNTW: bad operands")
}

// POPQ: Pop a Value from the Stack.
//
// Forms:
//
// 	POPQ m64
// 	POPQ r64
func POPQ(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr),
		operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "POPQ",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("POPQ: bad operands")
}

// POPW: Pop a Value from the Stack.
//
// Forms:
//
// 	POPW m16
// 	POPW r16
func POPW(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr),
		operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "POPW",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("POPW: bad operands")
}

// POR: Packed Bitwise Logical OR.
//
// Forms:
//
// 	POR m128 xmm
// 	POR xmm  xmm
func POR(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "POR",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("POR: bad operands")
}

// PREFETCHNTA: Prefetch Data Into Caches using NTA Hint.
//
// Forms:
//
// 	PREFETCHNTA m8
func PREFETCHNTA(m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(m):
		return &intrep.Instruction{
			Opcode:   "PREFETCHNTA",
			Operands: []operand.Op{m},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{},
			ISA:      []string{"MMX+"},
		}, nil
	}
	return nil, errors.New("PREFETCHNTA: bad operands")
}

// PREFETCHT0: Prefetch Data Into Caches using T0 Hint.
//
// Forms:
//
// 	PREFETCHT0 m8
func PREFETCHT0(m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(m):
		return &intrep.Instruction{
			Opcode:   "PREFETCHT0",
			Operands: []operand.Op{m},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{},
			ISA:      []string{"MMX+"},
		}, nil
	}
	return nil, errors.New("PREFETCHT0: bad operands")
}

// PREFETCHT1: Prefetch Data Into Caches using T1 Hint.
//
// Forms:
//
// 	PREFETCHT1 m8
func PREFETCHT1(m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(m):
		return &intrep.Instruction{
			Opcode:   "PREFETCHT1",
			Operands: []operand.Op{m},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{},
			ISA:      []string{"MMX+"},
		}, nil
	}
	return nil, errors.New("PREFETCHT1: bad operands")
}

// PREFETCHT2: Prefetch Data Into Caches using T2 Hint.
//
// Forms:
//
// 	PREFETCHT2 m8
func PREFETCHT2(m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(m):
		return &intrep.Instruction{
			Opcode:   "PREFETCHT2",
			Operands: []operand.Op{m},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{},
			ISA:      []string{"MMX+"},
		}, nil
	}
	return nil, errors.New("PREFETCHT2: bad operands")
}

// PSADBW: Compute Sum of Absolute Differences.
//
// Forms:
//
// 	PSADBW m128 xmm
// 	PSADBW xmm  xmm
func PSADBW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PSADBW",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSADBW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSADBW: bad operands")
}

// PSHUFB: Packed Shuffle Bytes.
//
// Forms:
//
// 	PSHUFB m128 xmm
// 	PSHUFB xmm  xmm
func PSHUFB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSHUFB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PSHUFB: bad operands")
}

// PSHUFD: Shuffle Packed Doublewords.
//
// Forms:
//
// 	PSHUFD imm8 m128 xmm
// 	PSHUFD imm8 xmm  xmm
func PSHUFD(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSHUFD",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSHUFD: bad operands")
}

// PSHUFHW: Shuffle Packed High Words.
//
// Forms:
//
// 	PSHUFHW imm8 m128 xmm
// 	PSHUFHW imm8 xmm  xmm
func PSHUFHW(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSHUFHW",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSHUFHW: bad operands")
}

// PSHUFL: Shuffle Packed Doublewords.
//
// Forms:
//
// 	PSHUFL imm8 m128 xmm
// 	PSHUFL imm8 xmm  xmm
func PSHUFL(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSHUFL",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSHUFL: bad operands")
}

// PSHUFLW: Shuffle Packed Low Words.
//
// Forms:
//
// 	PSHUFLW imm8 m128 xmm
// 	PSHUFLW imm8 xmm  xmm
func PSHUFLW(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSHUFLW",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSHUFLW: bad operands")
}

// PSIGNB: Packed Sign of Byte Integers.
//
// Forms:
//
// 	PSIGNB m128 xmm
// 	PSIGNB xmm  xmm
func PSIGNB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSIGNB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PSIGNB: bad operands")
}

// PSIGND: Packed Sign of Doubleword Integers.
//
// Forms:
//
// 	PSIGND m128 xmm
// 	PSIGND xmm  xmm
func PSIGND(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSIGND",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PSIGND: bad operands")
}

// PSIGNW: Packed Sign of Word Integers.
//
// Forms:
//
// 	PSIGNW m128 xmm
// 	PSIGNW xmm  xmm
func PSIGNW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSIGNW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSSE3"},
		}, nil
	}
	return nil, errors.New("PSIGNW: bad operands")
}

// PSLLDQ: Shift Packed Double Quadword Left Logical.
//
// Forms:
//
// 	PSLLDQ imm8 xmm
func PSLLDQ(i, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSLLDQ",
			Operands: []operand.Op{i, x},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSLLDQ: bad operands")
}

// PSLLL: Shift Packed Doubleword Data Left Logical.
//
// Forms:
//
// 	PSLLL imm8 xmm
// 	PSLLL m128 xmm
// 	PSLLL xmm  xmm
func PSLLL(imx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsXMM(x),
		operand.IsXMM(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSLLL",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{imx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSLLL",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSLLL: bad operands")
}

// PSLLO: Shift Packed Double Quadword Left Logical.
//
// Forms:
//
// 	PSLLO imm8 xmm
func PSLLO(i, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSLLO",
			Operands: []operand.Op{i, x},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSLLO: bad operands")
}

// PSLLQ: Shift Packed Quadword Data Left Logical.
//
// Forms:
//
// 	PSLLQ imm8 xmm
// 	PSLLQ m128 xmm
// 	PSLLQ xmm  xmm
func PSLLQ(imx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsXMM(x),
		operand.IsXMM(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSLLQ",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{imx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSLLQ",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSLLQ: bad operands")
}

// PSLLW: Shift Packed Word Data Left Logical.
//
// Forms:
//
// 	PSLLW imm8 xmm
// 	PSLLW m128 xmm
// 	PSLLW xmm  xmm
func PSLLW(imx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsXMM(x),
		operand.IsXMM(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSLLW",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{imx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSLLW",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSLLW: bad operands")
}

// PSRAL: Shift Packed Doubleword Data Right Arithmetic.
//
// Forms:
//
// 	PSRAL imm8 xmm
// 	PSRAL m128 xmm
// 	PSRAL xmm  xmm
func PSRAL(imx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsXMM(x),
		operand.IsXMM(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSRAL",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{imx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSRAL",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSRAL: bad operands")
}

// PSRAW: Shift Packed Word Data Right Arithmetic.
//
// Forms:
//
// 	PSRAW imm8 xmm
// 	PSRAW m128 xmm
// 	PSRAW xmm  xmm
func PSRAW(imx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsXMM(x),
		operand.IsXMM(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSRAW",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{imx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSRAW",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSRAW: bad operands")
}

// PSRLDQ: Shift Packed Double Quadword Right Logical.
//
// Forms:
//
// 	PSRLDQ imm8 xmm
func PSRLDQ(i, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSRLDQ",
			Operands: []operand.Op{i, x},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSRLDQ: bad operands")
}

// PSRLL: Shift Packed Doubleword Data Right Logical.
//
// Forms:
//
// 	PSRLL imm8 xmm
// 	PSRLL m128 xmm
// 	PSRLL xmm  xmm
func PSRLL(imx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsXMM(x),
		operand.IsXMM(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSRLL",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{imx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSRLL",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSRLL: bad operands")
}

// PSRLO: Shift Packed Double Quadword Right Logical.
//
// Forms:
//
// 	PSRLO imm8 xmm
func PSRLO(i, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSRLO",
			Operands: []operand.Op{i, x},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSRLO: bad operands")
}

// PSRLQ: Shift Packed Quadword Data Right Logical.
//
// Forms:
//
// 	PSRLQ imm8 xmm
// 	PSRLQ m128 xmm
// 	PSRLQ xmm  xmm
func PSRLQ(imx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsXMM(x),
		operand.IsXMM(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSRLQ",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{imx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSRLQ",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSRLQ: bad operands")
}

// PSRLW: Shift Packed Word Data Right Logical.
//
// Forms:
//
// 	PSRLW imm8 xmm
// 	PSRLW m128 xmm
// 	PSRLW xmm  xmm
func PSRLW(imx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsXMM(x),
		operand.IsXMM(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSRLW",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{imx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSRLW",
			Operands: []operand.Op{imx, x},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSRLW: bad operands")
}

// PSUBB: Subtract Packed Byte Integers.
//
// Forms:
//
// 	PSUBB m128 xmm
// 	PSUBB xmm  xmm
func PSUBB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PSUBB",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSUBB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSUBB: bad operands")
}

// PSUBL: Subtract Packed Doubleword Integers.
//
// Forms:
//
// 	PSUBL m128 xmm
// 	PSUBL xmm  xmm
func PSUBL(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PSUBL",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSUBL",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSUBL: bad operands")
}

// PSUBQ: Subtract Packed Quadword Integers.
//
// Forms:
//
// 	PSUBQ m128 xmm
// 	PSUBQ xmm  xmm
func PSUBQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PSUBQ",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSUBQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSUBQ: bad operands")
}

// PSUBSB: Subtract Packed Signed Byte Integers with Signed Saturation.
//
// Forms:
//
// 	PSUBSB m128 xmm
// 	PSUBSB xmm  xmm
func PSUBSB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PSUBSB",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSUBSB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSUBSB: bad operands")
}

// PSUBSW: Subtract Packed Signed Word Integers with Signed Saturation.
//
// Forms:
//
// 	PSUBSW m128 xmm
// 	PSUBSW xmm  xmm
func PSUBSW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PSUBSW",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSUBSW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSUBSW: bad operands")
}

// PSUBUSB: Subtract Packed Unsigned Byte Integers with Unsigned Saturation.
//
// Forms:
//
// 	PSUBUSB m128 xmm
// 	PSUBUSB xmm  xmm
func PSUBUSB(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PSUBUSB",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSUBUSB",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSUBUSB: bad operands")
}

// PSUBUSW: Subtract Packed Unsigned Word Integers with Unsigned Saturation.
//
// Forms:
//
// 	PSUBUSW m128 xmm
// 	PSUBUSW xmm  xmm
func PSUBUSW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PSUBUSW",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSUBUSW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSUBUSW: bad operands")
}

// PSUBW: Subtract Packed Word Integers.
//
// Forms:
//
// 	PSUBW m128 xmm
// 	PSUBW xmm  xmm
func PSUBW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PSUBW",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PSUBW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PSUBW: bad operands")
}

// PTEST: Packed Logical Compare.
//
// Forms:
//
// 	PTEST m128 xmm
// 	PTEST xmm  xmm
func PTEST(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PTEST",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("PTEST: bad operands")
}

// PUNPCKHBW: Unpack and Interleave High-Order Bytes into Words.
//
// Forms:
//
// 	PUNPCKHBW m128 xmm
// 	PUNPCKHBW xmm  xmm
func PUNPCKHBW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PUNPCKHBW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PUNPCKHBW: bad operands")
}

// PUNPCKHLQ: Unpack and Interleave High-Order Doublewords into Quadwords.
//
// Forms:
//
// 	PUNPCKHLQ m128 xmm
// 	PUNPCKHLQ xmm  xmm
func PUNPCKHLQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PUNPCKHLQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PUNPCKHLQ: bad operands")
}

// PUNPCKHQDQ: Unpack and Interleave High-Order Quadwords into Double Quadwords.
//
// Forms:
//
// 	PUNPCKHQDQ m128 xmm
// 	PUNPCKHQDQ xmm  xmm
func PUNPCKHQDQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PUNPCKHQDQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PUNPCKHQDQ: bad operands")
}

// PUNPCKHWL: Unpack and Interleave High-Order Words into Doublewords.
//
// Forms:
//
// 	PUNPCKHWL m128 xmm
// 	PUNPCKHWL xmm  xmm
func PUNPCKHWL(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PUNPCKHWL",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PUNPCKHWL: bad operands")
}

// PUNPCKLBW: Unpack and Interleave Low-Order Bytes into Words.
//
// Forms:
//
// 	PUNPCKLBW m128 xmm
// 	PUNPCKLBW xmm  xmm
func PUNPCKLBW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PUNPCKLBW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PUNPCKLBW: bad operands")
}

// PUNPCKLLQ: Unpack and Interleave Low-Order Doublewords into Quadwords.
//
// Forms:
//
// 	PUNPCKLLQ m128 xmm
// 	PUNPCKLLQ xmm  xmm
func PUNPCKLLQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PUNPCKLLQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PUNPCKLLQ: bad operands")
}

// PUNPCKLQDQ: Unpack and Interleave Low-Order Quadwords into Double Quadwords.
//
// Forms:
//
// 	PUNPCKLQDQ m128 xmm
// 	PUNPCKLQDQ xmm  xmm
func PUNPCKLQDQ(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PUNPCKLQDQ",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PUNPCKLQDQ: bad operands")
}

// PUNPCKLWL: Unpack and Interleave Low-Order Words into Doublewords.
//
// Forms:
//
// 	PUNPCKLWL m128 xmm
// 	PUNPCKLWL xmm  xmm
func PUNPCKLWL(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PUNPCKLWL",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PUNPCKLWL: bad operands")
}

// PUSHQ: Push Value Onto the Stack.
//
// Forms:
//
// 	PUSHQ imm32
// 	PUSHQ imm8
// 	PUSHQ m64
// 	PUSHQ r64
func PUSHQ(imr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(imr),
		operand.IsR64(imr):
		return &intrep.Instruction{
			Opcode:   "PUSHQ",
			Operands: []operand.Op{imr},
			Inputs:   []operand.Op{imr},
			Outputs:  []operand.Op{},
		}, nil
	case operand.IsIMM32(imr),
		operand.IsIMM8(imr):
		return &intrep.Instruction{
			Opcode:   "PUSHQ",
			Operands: []operand.Op{imr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("PUSHQ: bad operands")
}

// PUSHW: Push Value Onto the Stack.
//
// Forms:
//
// 	PUSHW m16
// 	PUSHW r16
func PUSHW(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr),
		operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "PUSHW",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("PUSHW: bad operands")
}

// PXOR: Packed Bitwise Logical Exclusive OR.
//
// Forms:
//
// 	PXOR m128 xmm
// 	PXOR xmm  xmm
func PXOR(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "PXOR",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "PXOR",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("PXOR: bad operands")
}

// RCLB: Rotate Left through Carry Flag.
//
// Forms:
//
// 	RCLB 1    m8
// 	RCLB 1    r8
// 	RCLB cl   m8
// 	RCLB cl   r8
// 	RCLB imm8 m8
// 	RCLB imm8 r8
func RCLB(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM8(mr),
		operand.IsCL(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "RCLB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM8(mr),
		operand.Is1(ci) && operand.IsR8(mr),
		operand.IsIMM8(ci) && operand.IsM8(mr),
		operand.IsIMM8(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "RCLB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("RCLB: bad operands")
}

// RCLL: Rotate Left through Carry Flag.
//
// Forms:
//
// 	RCLL 1    m32
// 	RCLL 1    r32
// 	RCLL cl   m32
// 	RCLL cl   r32
// 	RCLL imm8 m32
// 	RCLL imm8 r32
func RCLL(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM32(mr),
		operand.IsCL(ci) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "RCLL",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM32(mr),
		operand.Is1(ci) && operand.IsR32(mr),
		operand.IsIMM8(ci) && operand.IsM32(mr),
		operand.IsIMM8(ci) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "RCLL",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("RCLL: bad operands")
}

// RCLQ: Rotate Left through Carry Flag.
//
// Forms:
//
// 	RCLQ 1    m64
// 	RCLQ 1    r64
// 	RCLQ cl   m64
// 	RCLQ cl   r64
// 	RCLQ imm8 m64
// 	RCLQ imm8 r64
func RCLQ(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM64(mr),
		operand.IsCL(ci) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "RCLQ",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM64(mr),
		operand.Is1(ci) && operand.IsR64(mr),
		operand.IsIMM8(ci) && operand.IsM64(mr),
		operand.IsIMM8(ci) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "RCLQ",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("RCLQ: bad operands")
}

// RCLW: Rotate Left through Carry Flag.
//
// Forms:
//
// 	RCLW 1    m16
// 	RCLW 1    r16
// 	RCLW cl   m16
// 	RCLW cl   r16
// 	RCLW imm8 m16
// 	RCLW imm8 r16
func RCLW(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM16(mr),
		operand.IsCL(ci) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "RCLW",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM16(mr),
		operand.Is1(ci) && operand.IsR16(mr),
		operand.IsIMM8(ci) && operand.IsM16(mr),
		operand.IsIMM8(ci) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "RCLW",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("RCLW: bad operands")
}

// RCPPS: Compute Approximate Reciprocals of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	RCPPS m128 xmm
// 	RCPPS xmm  xmm
func RCPPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "RCPPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("RCPPS: bad operands")
}

// RCPSS: Compute Approximate Reciprocal of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	RCPSS m32 xmm
// 	RCPSS xmm xmm
func RCPSS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "RCPSS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("RCPSS: bad operands")
}

// RCRB: Rotate Right through Carry Flag.
//
// Forms:
//
// 	RCRB 1    m8
// 	RCRB 1    r8
// 	RCRB cl   m8
// 	RCRB cl   r8
// 	RCRB imm8 m8
// 	RCRB imm8 r8
func RCRB(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM8(mr),
		operand.IsCL(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "RCRB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM8(mr),
		operand.Is1(ci) && operand.IsR8(mr),
		operand.IsIMM8(ci) && operand.IsM8(mr),
		operand.IsIMM8(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "RCRB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("RCRB: bad operands")
}

// RCRL: Rotate Right through Carry Flag.
//
// Forms:
//
// 	RCRL 1    m32
// 	RCRL 1    r32
// 	RCRL cl   m32
// 	RCRL cl   r32
// 	RCRL imm8 m32
// 	RCRL imm8 r32
func RCRL(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM32(mr),
		operand.IsCL(ci) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "RCRL",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM32(mr),
		operand.Is1(ci) && operand.IsR32(mr),
		operand.IsIMM8(ci) && operand.IsM32(mr),
		operand.IsIMM8(ci) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "RCRL",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("RCRL: bad operands")
}

// RCRQ: Rotate Right through Carry Flag.
//
// Forms:
//
// 	RCRQ 1    m64
// 	RCRQ 1    r64
// 	RCRQ cl   m64
// 	RCRQ cl   r64
// 	RCRQ imm8 m64
// 	RCRQ imm8 r64
func RCRQ(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM64(mr),
		operand.IsCL(ci) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "RCRQ",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM64(mr),
		operand.Is1(ci) && operand.IsR64(mr),
		operand.IsIMM8(ci) && operand.IsM64(mr),
		operand.IsIMM8(ci) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "RCRQ",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("RCRQ: bad operands")
}

// RCRW: Rotate Right through Carry Flag.
//
// Forms:
//
// 	RCRW 1    m16
// 	RCRW 1    r16
// 	RCRW cl   m16
// 	RCRW cl   r16
// 	RCRW imm8 m16
// 	RCRW imm8 r16
func RCRW(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM16(mr),
		operand.IsCL(ci) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "RCRW",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM16(mr),
		operand.Is1(ci) && operand.IsR16(mr),
		operand.IsIMM8(ci) && operand.IsM16(mr),
		operand.IsIMM8(ci) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "RCRW",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("RCRW: bad operands")
}

// RDRANDL: Read Random Number.
//
// Forms:
//
// 	RDRANDL r16
// 	RDRANDL r32
// 	RDRANDL r64
func RDRANDL(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR16(r),
		operand.IsR32(r),
		operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "RDRANDL",
			Operands: []operand.Op{r},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{r},
			ISA:      []string{"RDRAND"},
		}, nil
	}
	return nil, errors.New("RDRANDL: bad operands")
}

// RDSEEDL: Read Random SEED.
//
// Forms:
//
// 	RDSEEDL r16
// 	RDSEEDL r32
// 	RDSEEDL r64
func RDSEEDL(r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR16(r),
		operand.IsR32(r),
		operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "RDSEEDL",
			Operands: []operand.Op{r},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{r},
			ISA:      []string{"RDSEED"},
		}, nil
	}
	return nil, errors.New("RDSEEDL: bad operands")
}

// RDTSC: Read Time-Stamp Counter.
//
// Forms:
//
// 	RDTSC
func RDTSC() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "RDTSC",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{reg.EAX, reg.EDX},
		ISA:      []string{"RDTSC"},
	}, nil
}

// RDTSCP: Read Time-Stamp Counter and Processor ID.
//
// Forms:
//
// 	RDTSCP
func RDTSCP() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "RDTSCP",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{reg.EAX, reg.ECX, reg.EDX},
		ISA:      []string{"RDTSCP"},
	}, nil
}

// RET: Return from Procedure.
//
// Forms:
//
// 	RET
func RET() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:     "RET",
		Operands:   []operand.Op{},
		Inputs:     []operand.Op{},
		Outputs:    []operand.Op{},
		IsTerminal: true,
	}, nil
}

// RETFL: Return from Procedure.
//
// Forms:
//
// 	RETFL imm16
func RETFL(i operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM16(i):
		return &intrep.Instruction{
			Opcode:   "RETFL",
			Operands: []operand.Op{i},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("RETFL: bad operands")
}

// RETFQ: Return from Procedure.
//
// Forms:
//
// 	RETFQ imm16
func RETFQ(i operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM16(i):
		return &intrep.Instruction{
			Opcode:   "RETFQ",
			Operands: []operand.Op{i},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("RETFQ: bad operands")
}

// RETFW: Return from Procedure.
//
// Forms:
//
// 	RETFW imm16
func RETFW(i operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM16(i):
		return &intrep.Instruction{
			Opcode:   "RETFW",
			Operands: []operand.Op{i},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("RETFW: bad operands")
}

// ROLB: Rotate Left.
//
// Forms:
//
// 	ROLB 1    m8
// 	ROLB 1    r8
// 	ROLB cl   m8
// 	ROLB cl   r8
// 	ROLB imm8 m8
// 	ROLB imm8 r8
func ROLB(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM8(mr),
		operand.IsCL(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "ROLB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM8(mr),
		operand.Is1(ci) && operand.IsR8(mr),
		operand.IsIMM8(ci) && operand.IsM8(mr),
		operand.IsIMM8(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "ROLB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("ROLB: bad operands")
}

// ROLL: Rotate Left.
//
// Forms:
//
// 	ROLL 1    m32
// 	ROLL 1    r32
// 	ROLL cl   m32
// 	ROLL cl   r32
// 	ROLL imm8 m32
// 	ROLL imm8 r32
func ROLL(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM32(mr),
		operand.IsCL(ci) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "ROLL",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM32(mr),
		operand.Is1(ci) && operand.IsR32(mr),
		operand.IsIMM8(ci) && operand.IsM32(mr),
		operand.IsIMM8(ci) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "ROLL",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("ROLL: bad operands")
}

// ROLQ: Rotate Left.
//
// Forms:
//
// 	ROLQ 1    m64
// 	ROLQ 1    r64
// 	ROLQ cl   m64
// 	ROLQ cl   r64
// 	ROLQ imm8 m64
// 	ROLQ imm8 r64
func ROLQ(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM64(mr),
		operand.IsCL(ci) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "ROLQ",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM64(mr),
		operand.Is1(ci) && operand.IsR64(mr),
		operand.IsIMM8(ci) && operand.IsM64(mr),
		operand.IsIMM8(ci) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "ROLQ",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("ROLQ: bad operands")
}

// ROLW: Rotate Left.
//
// Forms:
//
// 	ROLW 1    m16
// 	ROLW 1    r16
// 	ROLW cl   m16
// 	ROLW cl   r16
// 	ROLW imm8 m16
// 	ROLW imm8 r16
func ROLW(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM16(mr),
		operand.IsCL(ci) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "ROLW",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM16(mr),
		operand.Is1(ci) && operand.IsR16(mr),
		operand.IsIMM8(ci) && operand.IsM16(mr),
		operand.IsIMM8(ci) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "ROLW",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("ROLW: bad operands")
}

// RORB: Rotate Right.
//
// Forms:
//
// 	RORB 1    m8
// 	RORB 1    r8
// 	RORB cl   m8
// 	RORB cl   r8
// 	RORB imm8 m8
// 	RORB imm8 r8
func RORB(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM8(mr),
		operand.IsCL(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "RORB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM8(mr),
		operand.Is1(ci) && operand.IsR8(mr),
		operand.IsIMM8(ci) && operand.IsM8(mr),
		operand.IsIMM8(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "RORB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("RORB: bad operands")
}

// RORL: Rotate Right.
//
// Forms:
//
// 	RORL 1    m32
// 	RORL 1    r32
// 	RORL cl   m32
// 	RORL cl   r32
// 	RORL imm8 m32
// 	RORL imm8 r32
func RORL(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM32(mr),
		operand.IsCL(ci) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "RORL",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM32(mr),
		operand.Is1(ci) && operand.IsR32(mr),
		operand.IsIMM8(ci) && operand.IsM32(mr),
		operand.IsIMM8(ci) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "RORL",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("RORL: bad operands")
}

// RORQ: Rotate Right.
//
// Forms:
//
// 	RORQ 1    m64
// 	RORQ 1    r64
// 	RORQ cl   m64
// 	RORQ cl   r64
// 	RORQ imm8 m64
// 	RORQ imm8 r64
func RORQ(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM64(mr),
		operand.IsCL(ci) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "RORQ",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM64(mr),
		operand.Is1(ci) && operand.IsR64(mr),
		operand.IsIMM8(ci) && operand.IsM64(mr),
		operand.IsIMM8(ci) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "RORQ",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("RORQ: bad operands")
}

// RORW: Rotate Right.
//
// Forms:
//
// 	RORW 1    m16
// 	RORW 1    r16
// 	RORW cl   m16
// 	RORW cl   r16
// 	RORW imm8 m16
// 	RORW imm8 r16
func RORW(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM16(mr),
		operand.IsCL(ci) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "RORW",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM16(mr),
		operand.Is1(ci) && operand.IsR16(mr),
		operand.IsIMM8(ci) && operand.IsM16(mr),
		operand.IsIMM8(ci) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "RORW",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("RORW: bad operands")
}

// RORXL: Rotate Right Logical Without Affecting Flags.
//
// Forms:
//
// 	RORXL imm8 m32 r32
// 	RORXL imm8 r32 r32
func RORXL(i, mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(mr) && operand.IsR32(r),
		operand.IsIMM8(i) && operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "RORXL",
			Operands: []operand.Op{i, mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("RORXL: bad operands")
}

// RORXQ: Rotate Right Logical Without Affecting Flags.
//
// Forms:
//
// 	RORXQ imm8 m64 r64
// 	RORXQ imm8 r64 r64
func RORXQ(i, mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(mr) && operand.IsR64(r),
		operand.IsIMM8(i) && operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "RORXQ",
			Operands: []operand.Op{i, mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("RORXQ: bad operands")
}

// ROUNDPD: Round Packed Double Precision Floating-Point Values.
//
// Forms:
//
// 	ROUNDPD imm8 m128 xmm
// 	ROUNDPD imm8 xmm  xmm
func ROUNDPD(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ROUNDPD",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("ROUNDPD: bad operands")
}

// ROUNDPS: Round Packed Single Precision Floating-Point Values.
//
// Forms:
//
// 	ROUNDPS imm8 m128 xmm
// 	ROUNDPS imm8 xmm  xmm
func ROUNDPS(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ROUNDPS",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("ROUNDPS: bad operands")
}

// ROUNDSD: Round Scalar Double Precision Floating-Point Values.
//
// Forms:
//
// 	ROUNDSD imm8 m64 xmm
// 	ROUNDSD imm8 xmm xmm
func ROUNDSD(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ROUNDSD",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("ROUNDSD: bad operands")
}

// ROUNDSS: Round Scalar Single Precision Floating-Point Values.
//
// Forms:
//
// 	ROUNDSS imm8 m32 xmm
// 	ROUNDSS imm8 xmm xmm
func ROUNDSS(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "ROUNDSS",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE4.1"},
		}, nil
	}
	return nil, errors.New("ROUNDSS: bad operands")
}

// RSQRTPS: Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	RSQRTPS m128 xmm
// 	RSQRTPS xmm  xmm
func RSQRTPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "RSQRTPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("RSQRTPS: bad operands")
}

// RSQRTSS: Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	RSQRTSS m32 xmm
// 	RSQRTSS xmm xmm
func RSQRTSS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "RSQRTSS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("RSQRTSS: bad operands")
}

// SALB: Arithmetic Shift Left.
//
// Forms:
//
// 	SALB 1    m8
// 	SALB 1    r8
// 	SALB cl   m8
// 	SALB cl   r8
// 	SALB imm8 m8
// 	SALB imm8 r8
func SALB(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM8(mr),
		operand.IsCL(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SALB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM8(mr),
		operand.Is1(ci) && operand.IsR8(mr),
		operand.IsIMM8(ci) && operand.IsM8(mr),
		operand.IsIMM8(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SALB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SALB: bad operands")
}

// SALL: Arithmetic Shift Left.
//
// Forms:
//
// 	SALL 1    m32
// 	SALL 1    r32
// 	SALL cl   m32
// 	SALL cl   r32
// 	SALL imm8 m32
// 	SALL imm8 r32
func SALL(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM32(mr),
		operand.IsCL(ci) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "SALL",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM32(mr),
		operand.Is1(ci) && operand.IsR32(mr),
		operand.IsIMM8(ci) && operand.IsM32(mr),
		operand.IsIMM8(ci) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "SALL",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SALL: bad operands")
}

// SALQ: Arithmetic Shift Left.
//
// Forms:
//
// 	SALQ 1    m64
// 	SALQ 1    r64
// 	SALQ cl   m64
// 	SALQ cl   r64
// 	SALQ imm8 m64
// 	SALQ imm8 r64
func SALQ(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM64(mr),
		operand.IsCL(ci) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "SALQ",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM64(mr),
		operand.Is1(ci) && operand.IsR64(mr),
		operand.IsIMM8(ci) && operand.IsM64(mr),
		operand.IsIMM8(ci) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "SALQ",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SALQ: bad operands")
}

// SALW: Arithmetic Shift Left.
//
// Forms:
//
// 	SALW 1    m16
// 	SALW 1    r16
// 	SALW cl   m16
// 	SALW cl   r16
// 	SALW imm8 m16
// 	SALW imm8 r16
func SALW(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM16(mr),
		operand.IsCL(ci) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "SALW",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM16(mr),
		operand.Is1(ci) && operand.IsR16(mr),
		operand.IsIMM8(ci) && operand.IsM16(mr),
		operand.IsIMM8(ci) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "SALW",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SALW: bad operands")
}

// SARB: Arithmetic Shift Right.
//
// Forms:
//
// 	SARB 1    m8
// 	SARB 1    r8
// 	SARB cl   m8
// 	SARB cl   r8
// 	SARB imm8 m8
// 	SARB imm8 r8
func SARB(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM8(mr),
		operand.IsCL(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SARB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM8(mr),
		operand.Is1(ci) && operand.IsR8(mr),
		operand.IsIMM8(ci) && operand.IsM8(mr),
		operand.IsIMM8(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SARB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SARB: bad operands")
}

// SARL: Arithmetic Shift Right.
//
// Forms:
//
// 	SARL 1    m32
// 	SARL 1    r32
// 	SARL cl   m32
// 	SARL cl   r32
// 	SARL imm8 m32
// 	SARL imm8 r32
func SARL(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM32(mr),
		operand.IsCL(ci) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "SARL",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM32(mr),
		operand.Is1(ci) && operand.IsR32(mr),
		operand.IsIMM8(ci) && operand.IsM32(mr),
		operand.IsIMM8(ci) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "SARL",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SARL: bad operands")
}

// SARQ: Arithmetic Shift Right.
//
// Forms:
//
// 	SARQ 1    m64
// 	SARQ 1    r64
// 	SARQ cl   m64
// 	SARQ cl   r64
// 	SARQ imm8 m64
// 	SARQ imm8 r64
func SARQ(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM64(mr),
		operand.IsCL(ci) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "SARQ",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM64(mr),
		operand.Is1(ci) && operand.IsR64(mr),
		operand.IsIMM8(ci) && operand.IsM64(mr),
		operand.IsIMM8(ci) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "SARQ",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SARQ: bad operands")
}

// SARW: Arithmetic Shift Right.
//
// Forms:
//
// 	SARW 1    m16
// 	SARW 1    r16
// 	SARW cl   m16
// 	SARW cl   r16
// 	SARW imm8 m16
// 	SARW imm8 r16
func SARW(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM16(mr),
		operand.IsCL(ci) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "SARW",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM16(mr),
		operand.Is1(ci) && operand.IsR16(mr),
		operand.IsIMM8(ci) && operand.IsM16(mr),
		operand.IsIMM8(ci) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "SARW",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SARW: bad operands")
}

// SARXL: Arithmetic Shift Right Without Affecting Flags.
//
// Forms:
//
// 	SARXL r32 m32 r32
// 	SARXL r32 r32 r32
func SARXL(r, mr, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsM32(mr) && operand.IsR32(r1),
		operand.IsR32(r) && operand.IsR32(mr) && operand.IsR32(r1):
		return &intrep.Instruction{
			Opcode:   "SARXL",
			Operands: []operand.Op{r, mr, r1},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("SARXL: bad operands")
}

// SARXQ: Arithmetic Shift Right Without Affecting Flags.
//
// Forms:
//
// 	SARXQ r64 m64 r64
// 	SARXQ r64 r64 r64
func SARXQ(r, mr, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsM64(mr) && operand.IsR64(r1),
		operand.IsR64(r) && operand.IsR64(mr) && operand.IsR64(r1):
		return &intrep.Instruction{
			Opcode:   "SARXQ",
			Operands: []operand.Op{r, mr, r1},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("SARXQ: bad operands")
}

// SBBB: Subtract with Borrow.
//
// Forms:
//
// 	SBBB imm8 al
// 	SBBB imm8 m8
// 	SBBB imm8 r8
// 	SBBB m8   r8
// 	SBBB r8   m8
// 	SBBB r8   r8
func SBBB(imr, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(imr) && operand.IsAL(amr),
		operand.IsIMM8(imr) && operand.IsM8(amr),
		operand.IsIMM8(imr) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:   "SBBB",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{amr},
		}, nil
	case operand.IsR8(imr) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:           "SBBB",
			Operands:         []operand.Op{imr, amr},
			Inputs:           []operand.Op{imr, amr},
			Outputs:          []operand.Op{amr},
			CancellingInputs: true,
		}, nil
	case operand.IsM8(imr) && operand.IsR8(amr),
		operand.IsR8(imr) && operand.IsM8(amr):
		return &intrep.Instruction{
			Opcode:   "SBBB",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{imr, amr},
			Outputs:  []operand.Op{amr},
		}, nil
	}
	return nil, errors.New("SBBB: bad operands")
}

// SBBL: Subtract with Borrow.
//
// Forms:
//
// 	SBBL imm32 eax
// 	SBBL imm32 m32
// 	SBBL imm32 r32
// 	SBBL imm8  m32
// 	SBBL imm8  r32
// 	SBBL m32   r32
// 	SBBL r32   m32
// 	SBBL r32   r32
func SBBL(imr, emr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM32(imr) && operand.IsEAX(emr),
		operand.IsIMM32(imr) && operand.IsM32(emr),
		operand.IsIMM32(imr) && operand.IsR32(emr),
		operand.IsIMM8(imr) && operand.IsM32(emr),
		operand.IsIMM8(imr) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:   "SBBL",
			Operands: []operand.Op{imr, emr},
			Inputs:   []operand.Op{emr},
			Outputs:  []operand.Op{emr},
		}, nil
	case operand.IsR32(imr) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:           "SBBL",
			Operands:         []operand.Op{imr, emr},
			Inputs:           []operand.Op{imr, emr},
			Outputs:          []operand.Op{emr},
			CancellingInputs: true,
		}, nil
	case operand.IsM32(imr) && operand.IsR32(emr),
		operand.IsR32(imr) && operand.IsM32(emr):
		return &intrep.Instruction{
			Opcode:   "SBBL",
			Operands: []operand.Op{imr, emr},
			Inputs:   []operand.Op{imr, emr},
			Outputs:  []operand.Op{emr},
		}, nil
	}
	return nil, errors.New("SBBL: bad operands")
}

// SBBQ: Subtract with Borrow.
//
// Forms:
//
// 	SBBQ imm32 m64
// 	SBBQ imm32 r64
// 	SBBQ imm32 rax
// 	SBBQ imm8  m64
// 	SBBQ imm8  r64
// 	SBBQ m64   r64
// 	SBBQ r64   m64
// 	SBBQ r64   r64
func SBBQ(imr, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(imr) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:           "SBBQ",
			Operands:         []operand.Op{imr, mr},
			Inputs:           []operand.Op{imr, mr},
			Outputs:          []operand.Op{mr},
			CancellingInputs: true,
		}, nil
	case operand.IsM64(imr) && operand.IsR64(mr),
		operand.IsR64(imr) && operand.IsM64(mr):
		return &intrep.Instruction{
			Opcode:   "SBBQ",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{imr, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM32(imr) && operand.IsM64(mr),
		operand.IsIMM32(imr) && operand.IsR64(mr),
		operand.IsIMM32(imr) && operand.IsRAX(mr),
		operand.IsIMM8(imr) && operand.IsM64(mr),
		operand.IsIMM8(imr) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "SBBQ",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SBBQ: bad operands")
}

// SBBW: Subtract with Borrow.
//
// Forms:
//
// 	SBBW imm16 ax
// 	SBBW imm16 m16
// 	SBBW imm16 r16
// 	SBBW imm8  m16
// 	SBBW imm8  r16
// 	SBBW m16   r16
// 	SBBW r16   m16
// 	SBBW r16   r16
func SBBW(imr, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM16(imr) && operand.IsAX(amr),
		operand.IsIMM16(imr) && operand.IsM16(amr),
		operand.IsIMM16(imr) && operand.IsR16(amr),
		operand.IsIMM8(imr) && operand.IsM16(amr),
		operand.IsIMM8(imr) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:   "SBBW",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{amr},
		}, nil
	case operand.IsR16(imr) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:           "SBBW",
			Operands:         []operand.Op{imr, amr},
			Inputs:           []operand.Op{imr, amr},
			Outputs:          []operand.Op{amr},
			CancellingInputs: true,
		}, nil
	case operand.IsM16(imr) && operand.IsR16(amr),
		operand.IsR16(imr) && operand.IsM16(amr):
		return &intrep.Instruction{
			Opcode:   "SBBW",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{imr, amr},
			Outputs:  []operand.Op{amr},
		}, nil
	}
	return nil, errors.New("SBBW: bad operands")
}

// SETCC: Set byte if above or equal (CF == 0).
//
// Forms:
//
// 	SETCC m8
// 	SETCC r8
func SETCC(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETCC",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETCC: bad operands")
}

// SETCS: Set byte if below (CF == 1).
//
// Forms:
//
// 	SETCS m8
// 	SETCS r8
func SETCS(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETCS",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETCS: bad operands")
}

// SETEQ: Set byte if equal (ZF == 1).
//
// Forms:
//
// 	SETEQ m8
// 	SETEQ r8
func SETEQ(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETEQ",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETEQ: bad operands")
}

// SETGE: Set byte if greater or equal (SF == OF).
//
// Forms:
//
// 	SETGE m8
// 	SETGE r8
func SETGE(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETGE",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETGE: bad operands")
}

// SETGT: Set byte if greater (ZF == 0 and SF == OF).
//
// Forms:
//
// 	SETGT m8
// 	SETGT r8
func SETGT(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETGT",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETGT: bad operands")
}

// SETHI: Set byte if above (CF == 0 and ZF == 0).
//
// Forms:
//
// 	SETHI m8
// 	SETHI r8
func SETHI(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETHI",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETHI: bad operands")
}

// SETLE: Set byte if less or equal (ZF == 1 or SF != OF).
//
// Forms:
//
// 	SETLE m8
// 	SETLE r8
func SETLE(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETLE",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETLE: bad operands")
}

// SETLS: Set byte if below or equal (CF == 1 or ZF == 1).
//
// Forms:
//
// 	SETLS m8
// 	SETLS r8
func SETLS(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETLS",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETLS: bad operands")
}

// SETLT: Set byte if less (SF != OF).
//
// Forms:
//
// 	SETLT m8
// 	SETLT r8
func SETLT(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETLT",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETLT: bad operands")
}

// SETMI: Set byte if sign (SF == 1).
//
// Forms:
//
// 	SETMI m8
// 	SETMI r8
func SETMI(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETMI",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETMI: bad operands")
}

// SETNE: Set byte if not equal (ZF == 0).
//
// Forms:
//
// 	SETNE m8
// 	SETNE r8
func SETNE(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETNE",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETNE: bad operands")
}

// SETOC: Set byte if not overflow (OF == 0).
//
// Forms:
//
// 	SETOC m8
// 	SETOC r8
func SETOC(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETOC",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETOC: bad operands")
}

// SETOS: Set byte if overflow (OF == 1).
//
// Forms:
//
// 	SETOS m8
// 	SETOS r8
func SETOS(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETOS",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETOS: bad operands")
}

// SETPC: Set byte if not parity (PF == 0).
//
// Forms:
//
// 	SETPC m8
// 	SETPC r8
func SETPC(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETPC",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETPC: bad operands")
}

// SETPL: Set byte if not sign (SF == 0).
//
// Forms:
//
// 	SETPL m8
// 	SETPL r8
func SETPL(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETPL",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETPL: bad operands")
}

// SETPS: Set byte if parity (PF == 1).
//
// Forms:
//
// 	SETPS m8
// 	SETPS r8
func SETPS(mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr),
		operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SETPS",
			Operands: []operand.Op{mr},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SETPS: bad operands")
}

// SFENCE: Store Fence.
//
// Forms:
//
// 	SFENCE
func SFENCE() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "SFENCE",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{},
		ISA:      []string{"MMX+"},
	}, nil
}

// SHA1MSG1: Perform an Intermediate Calculation for the Next Four SHA1 Message Doublewords.
//
// Forms:
//
// 	SHA1MSG1 m128 xmm
// 	SHA1MSG1 xmm  xmm
func SHA1MSG1(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SHA1MSG1",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SHA"},
		}, nil
	}
	return nil, errors.New("SHA1MSG1: bad operands")
}

// SHA1MSG2: Perform a Final Calculation for the Next Four SHA1 Message Doublewords.
//
// Forms:
//
// 	SHA1MSG2 m128 xmm
// 	SHA1MSG2 xmm  xmm
func SHA1MSG2(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SHA1MSG2",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SHA"},
		}, nil
	}
	return nil, errors.New("SHA1MSG2: bad operands")
}

// SHA1NEXTE: Calculate SHA1 State Variable E after Four Rounds.
//
// Forms:
//
// 	SHA1NEXTE m128 xmm
// 	SHA1NEXTE xmm  xmm
func SHA1NEXTE(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SHA1NEXTE",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SHA"},
		}, nil
	}
	return nil, errors.New("SHA1NEXTE: bad operands")
}

// SHA1RNDS4: Perform Four Rounds of SHA1 Operation.
//
// Forms:
//
// 	SHA1RNDS4 imm2u m128 xmm
// 	SHA1RNDS4 imm2u xmm  xmm
func SHA1RNDS4(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM2U(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM2U(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SHA1RNDS4",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SHA"},
		}, nil
	}
	return nil, errors.New("SHA1RNDS4: bad operands")
}

// SHA256MSG1: Perform an Intermediate Calculation for the Next Four SHA256 Message Doublewords.
//
// Forms:
//
// 	SHA256MSG1 m128 xmm
// 	SHA256MSG1 xmm  xmm
func SHA256MSG1(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SHA256MSG1",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SHA"},
		}, nil
	}
	return nil, errors.New("SHA256MSG1: bad operands")
}

// SHA256MSG2: Perform a Final Calculation for the Next Four SHA256 Message Doublewords.
//
// Forms:
//
// 	SHA256MSG2 m128 xmm
// 	SHA256MSG2 xmm  xmm
func SHA256MSG2(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SHA256MSG2",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SHA"},
		}, nil
	}
	return nil, errors.New("SHA256MSG2: bad operands")
}

// SHA256RNDS2: Perform Two Rounds of SHA256 Operation.
//
// Forms:
//
// 	SHA256RNDS2 xmm0 m128 xmm
// 	SHA256RNDS2 xmm0 xmm  xmm
func SHA256RNDS2(x, mx, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM0(x) && operand.IsM128(mx) && operand.IsXMM(x1),
		operand.IsXMM0(x) && operand.IsXMM(mx) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "SHA256RNDS2",
			Operands: []operand.Op{x, mx, x1},
			Inputs:   []operand.Op{x, mx, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"SHA"},
		}, nil
	}
	return nil, errors.New("SHA256RNDS2: bad operands")
}

// SHLB: Logical Shift Left.
//
// Forms:
//
// 	SHLB 1    m8
// 	SHLB 1    r8
// 	SHLB cl   m8
// 	SHLB cl   r8
// 	SHLB imm8 m8
// 	SHLB imm8 r8
func SHLB(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM8(mr),
		operand.IsCL(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SHLB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM8(mr),
		operand.Is1(ci) && operand.IsR8(mr),
		operand.IsIMM8(ci) && operand.IsM8(mr),
		operand.IsIMM8(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SHLB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SHLB: bad operands")
}

// SHLL: Logical Shift Left.
//
// Forms:
//
// 	SHLL 1    m32
// 	SHLL 1    r32
// 	SHLL cl   m32
// 	SHLL cl   r32
// 	SHLL cl   r32 m32
// 	SHLL cl   r32 r32
// 	SHLL imm8 m32
// 	SHLL imm8 r32
// 	SHLL imm8 r32 m32
// 	SHLL imm8 r32 r32
func SHLL(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsCL(ops[0]) && operand.IsR32(ops[1]) && operand.IsM32(ops[2]),
		len(ops) == 3 && operand.IsCL(ops[0]) && operand.IsR32(ops[1]) && operand.IsR32(ops[2]):
		return &intrep.Instruction{
			Opcode:   "SHLL",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
		}, nil
	case len(ops) == 2 && operand.IsCL(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.IsCL(ops[0]) && operand.IsR32(ops[1]):
		return &intrep.Instruction{
			Opcode:   "SHLL",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsR32(ops[1]) && operand.IsM32(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsR32(ops[1]) && operand.IsR32(ops[2]):
		return &intrep.Instruction{
			Opcode:   "SHLL",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
		}, nil
	case len(ops) == 2 && operand.Is1(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.Is1(ops[0]) && operand.IsR32(ops[1]),
		len(ops) == 2 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.IsIMM8(ops[0]) && operand.IsR32(ops[1]):
		return &intrep.Instruction{
			Opcode:   "SHLL",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	}
	return nil, errors.New("SHLL: bad operands")
}

// SHLQ: Logical Shift Left.
//
// Forms:
//
// 	SHLQ 1    m64
// 	SHLQ 1    r64
// 	SHLQ cl   m64
// 	SHLQ cl   r64
// 	SHLQ cl   r64 m64
// 	SHLQ cl   r64 r64
// 	SHLQ imm8 m64
// 	SHLQ imm8 r64
// 	SHLQ imm8 r64 m64
// 	SHLQ imm8 r64 r64
func SHLQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsCL(ops[0]) && operand.IsR64(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsCL(ops[0]) && operand.IsR64(ops[1]) && operand.IsR64(ops[2]):
		return &intrep.Instruction{
			Opcode:   "SHLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
		}, nil
	case len(ops) == 2 && operand.IsCL(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsCL(ops[0]) && operand.IsR64(ops[1]):
		return &intrep.Instruction{
			Opcode:   "SHLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsR64(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsR64(ops[1]) && operand.IsR64(ops[2]):
		return &intrep.Instruction{
			Opcode:   "SHLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
		}, nil
	case len(ops) == 2 && operand.Is1(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.Is1(ops[0]) && operand.IsR64(ops[1]),
		len(ops) == 2 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsIMM8(ops[0]) && operand.IsR64(ops[1]):
		return &intrep.Instruction{
			Opcode:   "SHLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	}
	return nil, errors.New("SHLQ: bad operands")
}

// SHLW: Logical Shift Left.
//
// Forms:
//
// 	SHLW 1    m16
// 	SHLW 1    r16
// 	SHLW cl   m16
// 	SHLW cl   r16
// 	SHLW cl   r16 m16
// 	SHLW cl   r16 r16
// 	SHLW imm8 m16
// 	SHLW imm8 r16
// 	SHLW imm8 r16 m16
// 	SHLW imm8 r16 r16
func SHLW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsCL(ops[0]) && operand.IsR16(ops[1]) && operand.IsM16(ops[2]),
		len(ops) == 3 && operand.IsCL(ops[0]) && operand.IsR16(ops[1]) && operand.IsR16(ops[2]):
		return &intrep.Instruction{
			Opcode:   "SHLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
		}, nil
	case len(ops) == 2 && operand.IsCL(ops[0]) && operand.IsM16(ops[1]),
		len(ops) == 2 && operand.IsCL(ops[0]) && operand.IsR16(ops[1]):
		return &intrep.Instruction{
			Opcode:   "SHLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsR16(ops[1]) && operand.IsM16(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsR16(ops[1]) && operand.IsR16(ops[2]):
		return &intrep.Instruction{
			Opcode:   "SHLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
		}, nil
	case len(ops) == 2 && operand.Is1(ops[0]) && operand.IsM16(ops[1]),
		len(ops) == 2 && operand.Is1(ops[0]) && operand.IsR16(ops[1]),
		len(ops) == 2 && operand.IsIMM8(ops[0]) && operand.IsM16(ops[1]),
		len(ops) == 2 && operand.IsIMM8(ops[0]) && operand.IsR16(ops[1]):
		return &intrep.Instruction{
			Opcode:   "SHLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	}
	return nil, errors.New("SHLW: bad operands")
}

// SHLXL: Logical Shift Left Without Affecting Flags.
//
// Forms:
//
// 	SHLXL r32 m32 r32
// 	SHLXL r32 r32 r32
func SHLXL(r, mr, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsM32(mr) && operand.IsR32(r1),
		operand.IsR32(r) && operand.IsR32(mr) && operand.IsR32(r1):
		return &intrep.Instruction{
			Opcode:   "SHLXL",
			Operands: []operand.Op{r, mr, r1},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("SHLXL: bad operands")
}

// SHLXQ: Logical Shift Left Without Affecting Flags.
//
// Forms:
//
// 	SHLXQ r64 m64 r64
// 	SHLXQ r64 r64 r64
func SHLXQ(r, mr, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsM64(mr) && operand.IsR64(r1),
		operand.IsR64(r) && operand.IsR64(mr) && operand.IsR64(r1):
		return &intrep.Instruction{
			Opcode:   "SHLXQ",
			Operands: []operand.Op{r, mr, r1},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("SHLXQ: bad operands")
}

// SHRB: Logical Shift Right.
//
// Forms:
//
// 	SHRB 1    m8
// 	SHRB 1    r8
// 	SHRB cl   m8
// 	SHRB cl   r8
// 	SHRB imm8 m8
// 	SHRB imm8 r8
func SHRB(ci, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsCL(ci) && operand.IsM8(mr),
		operand.IsCL(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SHRB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{ci, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.Is1(ci) && operand.IsM8(mr),
		operand.Is1(ci) && operand.IsR8(mr),
		operand.IsIMM8(ci) && operand.IsM8(mr),
		operand.IsIMM8(ci) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "SHRB",
			Operands: []operand.Op{ci, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SHRB: bad operands")
}

// SHRL: Logical Shift Right.
//
// Forms:
//
// 	SHRL 1    m32
// 	SHRL 1    r32
// 	SHRL cl   m32
// 	SHRL cl   r32
// 	SHRL cl   r32 m32
// 	SHRL cl   r32 r32
// 	SHRL imm8 m32
// 	SHRL imm8 r32
// 	SHRL imm8 r32 m32
// 	SHRL imm8 r32 r32
func SHRL(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsCL(ops[0]) && operand.IsR32(ops[1]) && operand.IsM32(ops[2]),
		len(ops) == 3 && operand.IsCL(ops[0]) && operand.IsR32(ops[1]) && operand.IsR32(ops[2]):
		return &intrep.Instruction{
			Opcode:   "SHRL",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
		}, nil
	case len(ops) == 2 && operand.IsCL(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.IsCL(ops[0]) && operand.IsR32(ops[1]):
		return &intrep.Instruction{
			Opcode:   "SHRL",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsR32(ops[1]) && operand.IsM32(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsR32(ops[1]) && operand.IsR32(ops[2]):
		return &intrep.Instruction{
			Opcode:   "SHRL",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
		}, nil
	case len(ops) == 2 && operand.Is1(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.Is1(ops[0]) && operand.IsR32(ops[1]),
		len(ops) == 2 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.IsIMM8(ops[0]) && operand.IsR32(ops[1]):
		return &intrep.Instruction{
			Opcode:   "SHRL",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	}
	return nil, errors.New("SHRL: bad operands")
}

// SHRQ: Logical Shift Right.
//
// Forms:
//
// 	SHRQ 1    m64
// 	SHRQ 1    r64
// 	SHRQ cl   m64
// 	SHRQ cl   r64
// 	SHRQ cl   r64 m64
// 	SHRQ cl   r64 r64
// 	SHRQ imm8 m64
// 	SHRQ imm8 r64
// 	SHRQ imm8 r64 m64
// 	SHRQ imm8 r64 r64
func SHRQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsCL(ops[0]) && operand.IsR64(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsCL(ops[0]) && operand.IsR64(ops[1]) && operand.IsR64(ops[2]):
		return &intrep.Instruction{
			Opcode:   "SHRQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
		}, nil
	case len(ops) == 2 && operand.IsCL(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsCL(ops[0]) && operand.IsR64(ops[1]):
		return &intrep.Instruction{
			Opcode:   "SHRQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsR64(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsR64(ops[1]) && operand.IsR64(ops[2]):
		return &intrep.Instruction{
			Opcode:   "SHRQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
		}, nil
	case len(ops) == 2 && operand.Is1(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.Is1(ops[0]) && operand.IsR64(ops[1]),
		len(ops) == 2 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsIMM8(ops[0]) && operand.IsR64(ops[1]):
		return &intrep.Instruction{
			Opcode:   "SHRQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	}
	return nil, errors.New("SHRQ: bad operands")
}

// SHRW: Logical Shift Right.
//
// Forms:
//
// 	SHRW 1    m16
// 	SHRW 1    r16
// 	SHRW cl   m16
// 	SHRW cl   r16
// 	SHRW cl   r16 m16
// 	SHRW cl   r16 r16
// 	SHRW imm8 m16
// 	SHRW imm8 r16
// 	SHRW imm8 r16 m16
// 	SHRW imm8 r16 r16
func SHRW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsCL(ops[0]) && operand.IsR16(ops[1]) && operand.IsM16(ops[2]),
		len(ops) == 3 && operand.IsCL(ops[0]) && operand.IsR16(ops[1]) && operand.IsR16(ops[2]):
		return &intrep.Instruction{
			Opcode:   "SHRW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
		}, nil
	case len(ops) == 2 && operand.IsCL(ops[0]) && operand.IsM16(ops[1]),
		len(ops) == 2 && operand.IsCL(ops[0]) && operand.IsR16(ops[1]):
		return &intrep.Instruction{
			Opcode:   "SHRW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsR16(ops[1]) && operand.IsM16(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsR16(ops[1]) && operand.IsR16(ops[2]):
		return &intrep.Instruction{
			Opcode:   "SHRW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
		}, nil
	case len(ops) == 2 && operand.Is1(ops[0]) && operand.IsM16(ops[1]),
		len(ops) == 2 && operand.Is1(ops[0]) && operand.IsR16(ops[1]),
		len(ops) == 2 && operand.IsIMM8(ops[0]) && operand.IsM16(ops[1]),
		len(ops) == 2 && operand.IsIMM8(ops[0]) && operand.IsR16(ops[1]):
		return &intrep.Instruction{
			Opcode:   "SHRW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[1]},
		}, nil
	}
	return nil, errors.New("SHRW: bad operands")
}

// SHRXL: Logical Shift Right Without Affecting Flags.
//
// Forms:
//
// 	SHRXL r32 m32 r32
// 	SHRXL r32 r32 r32
func SHRXL(r, mr, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsM32(mr) && operand.IsR32(r1),
		operand.IsR32(r) && operand.IsR32(mr) && operand.IsR32(r1):
		return &intrep.Instruction{
			Opcode:   "SHRXL",
			Operands: []operand.Op{r, mr, r1},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("SHRXL: bad operands")
}

// SHRXQ: Logical Shift Right Without Affecting Flags.
//
// Forms:
//
// 	SHRXQ r64 m64 r64
// 	SHRXQ r64 r64 r64
func SHRXQ(r, mr, r1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsM64(mr) && operand.IsR64(r1),
		operand.IsR64(r) && operand.IsR64(mr) && operand.IsR64(r1):
		return &intrep.Instruction{
			Opcode:   "SHRXQ",
			Operands: []operand.Op{r, mr, r1},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{r1},
			ISA:      []string{"BMI2"},
		}, nil
	}
	return nil, errors.New("SHRXQ: bad operands")
}

// SHUFPD: Shuffle Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	SHUFPD imm8 m128 xmm
// 	SHUFPD imm8 xmm  xmm
func SHUFPD(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SHUFPD",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("SHUFPD: bad operands")
}

// SHUFPS: Shuffle Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	SHUFPS imm8 m128 xmm
// 	SHUFPS imm8 xmm  xmm
func SHUFPS(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SHUFPS",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("SHUFPS: bad operands")
}

// SQRTPD: Compute Square Roots of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	SQRTPD m128 xmm
// 	SQRTPD xmm  xmm
func SQRTPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SQRTPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("SQRTPD: bad operands")
}

// SQRTPS: Compute Square Roots of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	SQRTPS m128 xmm
// 	SQRTPS xmm  xmm
func SQRTPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SQRTPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("SQRTPS: bad operands")
}

// SQRTSD: Compute Square Root of Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	SQRTSD m64 xmm
// 	SQRTSD xmm xmm
func SQRTSD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SQRTSD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("SQRTSD: bad operands")
}

// SQRTSS: Compute Square Root of Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	SQRTSS m32 xmm
// 	SQRTSS xmm xmm
func SQRTSS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SQRTSS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("SQRTSS: bad operands")
}

// STC: Set Carry Flag.
//
// Forms:
//
// 	STC
func STC() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "STC",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{},
	}, nil
}

// STD: Set Direction Flag.
//
// Forms:
//
// 	STD
func STD() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "STD",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{},
	}, nil
}

// STMXCSR: Store MXCSR Register State.
//
// Forms:
//
// 	STMXCSR m32
func STMXCSR(m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m):
		return &intrep.Instruction{
			Opcode:   "STMXCSR",
			Operands: []operand.Op{m},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{m},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("STMXCSR: bad operands")
}

// SUBB: Subtract.
//
// Forms:
//
// 	SUBB imm8 al
// 	SUBB imm8 m8
// 	SUBB imm8 r8
// 	SUBB m8   r8
// 	SUBB r8   m8
// 	SUBB r8   r8
func SUBB(imr, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(imr) && operand.IsAL(amr),
		operand.IsIMM8(imr) && operand.IsM8(amr),
		operand.IsIMM8(imr) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:   "SUBB",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{amr},
		}, nil
	case operand.IsR8(imr) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:           "SUBB",
			Operands:         []operand.Op{imr, amr},
			Inputs:           []operand.Op{imr, amr},
			Outputs:          []operand.Op{amr},
			CancellingInputs: true,
		}, nil
	case operand.IsM8(imr) && operand.IsR8(amr),
		operand.IsR8(imr) && operand.IsM8(amr):
		return &intrep.Instruction{
			Opcode:   "SUBB",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{imr, amr},
			Outputs:  []operand.Op{amr},
		}, nil
	}
	return nil, errors.New("SUBB: bad operands")
}

// SUBL: Subtract.
//
// Forms:
//
// 	SUBL imm32 eax
// 	SUBL imm32 m32
// 	SUBL imm32 r32
// 	SUBL imm8  m32
// 	SUBL imm8  r32
// 	SUBL m32   r32
// 	SUBL r32   m32
// 	SUBL r32   r32
func SUBL(imr, emr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM32(imr) && operand.IsEAX(emr),
		operand.IsIMM32(imr) && operand.IsM32(emr),
		operand.IsIMM32(imr) && operand.IsR32(emr),
		operand.IsIMM8(imr) && operand.IsM32(emr),
		operand.IsIMM8(imr) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:   "SUBL",
			Operands: []operand.Op{imr, emr},
			Inputs:   []operand.Op{emr},
			Outputs:  []operand.Op{emr},
		}, nil
	case operand.IsR32(imr) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:           "SUBL",
			Operands:         []operand.Op{imr, emr},
			Inputs:           []operand.Op{imr, emr},
			Outputs:          []operand.Op{emr},
			CancellingInputs: true,
		}, nil
	case operand.IsM32(imr) && operand.IsR32(emr),
		operand.IsR32(imr) && operand.IsM32(emr):
		return &intrep.Instruction{
			Opcode:   "SUBL",
			Operands: []operand.Op{imr, emr},
			Inputs:   []operand.Op{imr, emr},
			Outputs:  []operand.Op{emr},
		}, nil
	}
	return nil, errors.New("SUBL: bad operands")
}

// SUBPD: Subtract Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	SUBPD m128 xmm
// 	SUBPD xmm  xmm
func SUBPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SUBPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("SUBPD: bad operands")
}

// SUBPS: Subtract Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	SUBPS m128 xmm
// 	SUBPS xmm  xmm
func SUBPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SUBPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("SUBPS: bad operands")
}

// SUBQ: Subtract.
//
// Forms:
//
// 	SUBQ imm32 m64
// 	SUBQ imm32 r64
// 	SUBQ imm32 rax
// 	SUBQ imm8  m64
// 	SUBQ imm8  r64
// 	SUBQ m64   r64
// 	SUBQ r64   m64
// 	SUBQ r64   r64
func SUBQ(imr, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(imr) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:           "SUBQ",
			Operands:         []operand.Op{imr, mr},
			Inputs:           []operand.Op{imr, mr},
			Outputs:          []operand.Op{mr},
			CancellingInputs: true,
		}, nil
	case operand.IsM64(imr) && operand.IsR64(mr),
		operand.IsR64(imr) && operand.IsM64(mr):
		return &intrep.Instruction{
			Opcode:   "SUBQ",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{imr, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM32(imr) && operand.IsM64(mr),
		operand.IsIMM32(imr) && operand.IsR64(mr),
		operand.IsIMM32(imr) && operand.IsRAX(mr),
		operand.IsIMM8(imr) && operand.IsM64(mr),
		operand.IsIMM8(imr) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "SUBQ",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("SUBQ: bad operands")
}

// SUBSD: Subtract Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	SUBSD m64 xmm
// 	SUBSD xmm xmm
func SUBSD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SUBSD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("SUBSD: bad operands")
}

// SUBSS: Subtract Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	SUBSS m32 xmm
// 	SUBSS xmm xmm
func SUBSS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "SUBSS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("SUBSS: bad operands")
}

// SUBW: Subtract.
//
// Forms:
//
// 	SUBW imm16 ax
// 	SUBW imm16 m16
// 	SUBW imm16 r16
// 	SUBW imm8  m16
// 	SUBW imm8  r16
// 	SUBW m16   r16
// 	SUBW r16   m16
// 	SUBW r16   r16
func SUBW(imr, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM16(imr) && operand.IsAX(amr),
		operand.IsIMM16(imr) && operand.IsM16(amr),
		operand.IsIMM16(imr) && operand.IsR16(amr),
		operand.IsIMM8(imr) && operand.IsM16(amr),
		operand.IsIMM8(imr) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:   "SUBW",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{amr},
		}, nil
	case operand.IsR16(imr) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:           "SUBW",
			Operands:         []operand.Op{imr, amr},
			Inputs:           []operand.Op{imr, amr},
			Outputs:          []operand.Op{amr},
			CancellingInputs: true,
		}, nil
	case operand.IsM16(imr) && operand.IsR16(amr),
		operand.IsR16(imr) && operand.IsM16(amr):
		return &intrep.Instruction{
			Opcode:   "SUBW",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{imr, amr},
			Outputs:  []operand.Op{amr},
		}, nil
	}
	return nil, errors.New("SUBW: bad operands")
}

// SYSCALL: Fast System Call.
//
// Forms:
//
// 	SYSCALL
func SYSCALL() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "SYSCALL",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{reg.R11, reg.RCX},
	}, nil
}

// TESTB: Logical Compare.
//
// Forms:
//
// 	TESTB imm8 al
// 	TESTB imm8 m8
// 	TESTB imm8 r8
// 	TESTB r8   m8
// 	TESTB r8   r8
func TESTB(ir, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(ir) && operand.IsAL(amr),
		operand.IsIMM8(ir) && operand.IsM8(amr),
		operand.IsIMM8(ir) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:   "TESTB",
			Operands: []operand.Op{ir, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{},
		}, nil
	case operand.IsR8(ir) && operand.IsM8(amr),
		operand.IsR8(ir) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:   "TESTB",
			Operands: []operand.Op{ir, amr},
			Inputs:   []operand.Op{ir, amr},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("TESTB: bad operands")
}

// TESTL: Logical Compare.
//
// Forms:
//
// 	TESTL imm32 eax
// 	TESTL imm32 m32
// 	TESTL imm32 r32
// 	TESTL r32   m32
// 	TESTL r32   r32
func TESTL(ir, emr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM32(ir) && operand.IsEAX(emr),
		operand.IsIMM32(ir) && operand.IsM32(emr),
		operand.IsIMM32(ir) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:   "TESTL",
			Operands: []operand.Op{ir, emr},
			Inputs:   []operand.Op{emr},
			Outputs:  []operand.Op{},
		}, nil
	case operand.IsR32(ir) && operand.IsM32(emr),
		operand.IsR32(ir) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:   "TESTL",
			Operands: []operand.Op{ir, emr},
			Inputs:   []operand.Op{ir, emr},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("TESTL: bad operands")
}

// TESTQ: Logical Compare.
//
// Forms:
//
// 	TESTQ imm32 m64
// 	TESTQ imm32 r64
// 	TESTQ imm32 rax
// 	TESTQ r64   m64
// 	TESTQ r64   r64
func TESTQ(ir, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(ir) && operand.IsM64(mr),
		operand.IsR64(ir) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "TESTQ",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{ir, mr},
			Outputs:  []operand.Op{},
		}, nil
	case operand.IsIMM32(ir) && operand.IsM64(mr),
		operand.IsIMM32(ir) && operand.IsR64(mr),
		operand.IsIMM32(ir) && operand.IsRAX(mr):
		return &intrep.Instruction{
			Opcode:   "TESTQ",
			Operands: []operand.Op{ir, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("TESTQ: bad operands")
}

// TESTW: Logical Compare.
//
// Forms:
//
// 	TESTW imm16 ax
// 	TESTW imm16 m16
// 	TESTW imm16 r16
// 	TESTW r16   m16
// 	TESTW r16   r16
func TESTW(ir, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM16(ir) && operand.IsAX(amr),
		operand.IsIMM16(ir) && operand.IsM16(amr),
		operand.IsIMM16(ir) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:   "TESTW",
			Operands: []operand.Op{ir, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{},
		}, nil
	case operand.IsR16(ir) && operand.IsM16(amr),
		operand.IsR16(ir) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:   "TESTW",
			Operands: []operand.Op{ir, amr},
			Inputs:   []operand.Op{ir, amr},
			Outputs:  []operand.Op{},
		}, nil
	}
	return nil, errors.New("TESTW: bad operands")
}

// TZCNTL: Count the Number of Trailing Zero Bits.
//
// Forms:
//
// 	TZCNTL m32 r32
// 	TZCNTL r32 r32
func TZCNTL(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsR32(r),
		operand.IsR32(mr) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "TZCNTL",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"BMI"},
		}, nil
	}
	return nil, errors.New("TZCNTL: bad operands")
}

// TZCNTQ: Count the Number of Trailing Zero Bits.
//
// Forms:
//
// 	TZCNTQ m64 r64
// 	TZCNTQ r64 r64
func TZCNTQ(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(r),
		operand.IsR64(mr) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "TZCNTQ",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"BMI"},
		}, nil
	}
	return nil, errors.New("TZCNTQ: bad operands")
}

// TZCNTW: Count the Number of Trailing Zero Bits.
//
// Forms:
//
// 	TZCNTW m16 r16
// 	TZCNTW r16 r16
func TZCNTW(mr, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mr) && operand.IsR16(r),
		operand.IsR16(mr) && operand.IsR16(r):
		return &intrep.Instruction{
			Opcode:   "TZCNTW",
			Operands: []operand.Op{mr, r},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{r},
			ISA:      []string{"BMI"},
		}, nil
	}
	return nil, errors.New("TZCNTW: bad operands")
}

// UCOMISD: Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS.
//
// Forms:
//
// 	UCOMISD m64 xmm
// 	UCOMISD xmm xmm
func UCOMISD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "UCOMISD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("UCOMISD: bad operands")
}

// UCOMISS: Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS.
//
// Forms:
//
// 	UCOMISS m32 xmm
// 	UCOMISS xmm xmm
func UCOMISS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "UCOMISS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("UCOMISS: bad operands")
}

// UD2: Undefined Instruction.
//
// Forms:
//
// 	UD2
func UD2() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "UD2",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{},
	}, nil
}

// UNPCKHPD: Unpack and Interleave High Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	UNPCKHPD m128 xmm
// 	UNPCKHPD xmm  xmm
func UNPCKHPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "UNPCKHPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("UNPCKHPD: bad operands")
}

// UNPCKHPS: Unpack and Interleave High Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	UNPCKHPS m128 xmm
// 	UNPCKHPS xmm  xmm
func UNPCKHPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "UNPCKHPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("UNPCKHPS: bad operands")
}

// UNPCKLPD: Unpack and Interleave Low Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	UNPCKLPD m128 xmm
// 	UNPCKLPD xmm  xmm
func UNPCKLPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "UNPCKLPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("UNPCKLPD: bad operands")
}

// UNPCKLPS: Unpack and Interleave Low Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	UNPCKLPS m128 xmm
// 	UNPCKLPS xmm  xmm
func UNPCKLPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "UNPCKLPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("UNPCKLPS: bad operands")
}

// VADDPD: Add Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VADDPD m128 xmm xmm
// 	VADDPD m256 ymm ymm
// 	VADDPD xmm  xmm xmm
// 	VADDPD ymm  ymm ymm
// 	VADDPD m512 zmm k zmm
// 	VADDPD m512 zmm zmm
// 	VADDPD zmm  zmm k zmm
// 	VADDPD zmm  zmm zmm
// 	VADDPD m128 xmm k xmm
// 	VADDPD m256 ymm k ymm
// 	VADDPD xmm  xmm k xmm
// 	VADDPD ymm  ymm k ymm
func VADDPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPD: bad operands")
}

// VADDPD_BCST: Add Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VADDPD.BCST m64 zmm k zmm
// 	VADDPD.BCST m64 zmm zmm
// 	VADDPD.BCST m64 xmm k xmm
// 	VADDPD.BCST m64 xmm xmm
// 	VADDPD.BCST m64 ymm k ymm
// 	VADDPD.BCST m64 ymm ymm
func VADDPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPD_BCST: bad operands")
}

// VADDPD_BCST_Z: Add Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VADDPD.BCST.Z m64 zmm k zmm
// 	VADDPD.BCST.Z m64 xmm k xmm
// 	VADDPD.BCST.Z m64 ymm k ymm
func VADDPD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPD_BCST_Z: bad operands")
}

// VADDPD_RD_SAE: Add Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VADDPD.RD_SAE zmm zmm k zmm
// 	VADDPD.RD_SAE zmm zmm zmm
func VADDPD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPD_RD_SAE: bad operands")
}

// VADDPD_RD_SAE_Z: Add Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VADDPD.RD_SAE.Z zmm zmm k zmm
func VADDPD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPD_RD_SAE_Z: bad operands")
}

// VADDPD_RN_SAE: Add Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VADDPD.RN_SAE zmm zmm k zmm
// 	VADDPD.RN_SAE zmm zmm zmm
func VADDPD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPD_RN_SAE: bad operands")
}

// VADDPD_RN_SAE_Z: Add Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VADDPD.RN_SAE.Z zmm zmm k zmm
func VADDPD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPD_RN_SAE_Z: bad operands")
}

// VADDPD_RU_SAE: Add Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VADDPD.RU_SAE zmm zmm k zmm
// 	VADDPD.RU_SAE zmm zmm zmm
func VADDPD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPD_RU_SAE: bad operands")
}

// VADDPD_RU_SAE_Z: Add Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VADDPD.RU_SAE.Z zmm zmm k zmm
func VADDPD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPD_RU_SAE_Z: bad operands")
}

// VADDPD_RZ_SAE: Add Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VADDPD.RZ_SAE zmm zmm k zmm
// 	VADDPD.RZ_SAE zmm zmm zmm
func VADDPD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPD_RZ_SAE: bad operands")
}

// VADDPD_RZ_SAE_Z: Add Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VADDPD.RZ_SAE.Z zmm zmm k zmm
func VADDPD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPD_RZ_SAE_Z: bad operands")
}

// VADDPD_Z: Add Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VADDPD.Z m512 zmm k zmm
// 	VADDPD.Z zmm  zmm k zmm
// 	VADDPD.Z m128 xmm k xmm
// 	VADDPD.Z m256 ymm k ymm
// 	VADDPD.Z xmm  xmm k xmm
// 	VADDPD.Z ymm  ymm k ymm
func VADDPD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VADDPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPD_Z: bad operands")
}

// VADDPS: Add Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VADDPS m128 xmm xmm
// 	VADDPS m256 ymm ymm
// 	VADDPS xmm  xmm xmm
// 	VADDPS ymm  ymm ymm
// 	VADDPS m512 zmm k zmm
// 	VADDPS m512 zmm zmm
// 	VADDPS zmm  zmm k zmm
// 	VADDPS zmm  zmm zmm
// 	VADDPS m128 xmm k xmm
// 	VADDPS m256 ymm k ymm
// 	VADDPS xmm  xmm k xmm
// 	VADDPS ymm  ymm k ymm
func VADDPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPS: bad operands")
}

// VADDPS_BCST: Add Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VADDPS.BCST m32 zmm k zmm
// 	VADDPS.BCST m32 zmm zmm
// 	VADDPS.BCST m32 xmm k xmm
// 	VADDPS.BCST m32 xmm xmm
// 	VADDPS.BCST m32 ymm k ymm
// 	VADDPS.BCST m32 ymm ymm
func VADDPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPS_BCST: bad operands")
}

// VADDPS_BCST_Z: Add Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VADDPS.BCST.Z m32 zmm k zmm
// 	VADDPS.BCST.Z m32 xmm k xmm
// 	VADDPS.BCST.Z m32 ymm k ymm
func VADDPS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPS_BCST_Z: bad operands")
}

// VADDPS_RD_SAE: Add Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VADDPS.RD_SAE zmm zmm k zmm
// 	VADDPS.RD_SAE zmm zmm zmm
func VADDPS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPS_RD_SAE: bad operands")
}

// VADDPS_RD_SAE_Z: Add Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VADDPS.RD_SAE.Z zmm zmm k zmm
func VADDPS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPS_RD_SAE_Z: bad operands")
}

// VADDPS_RN_SAE: Add Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VADDPS.RN_SAE zmm zmm k zmm
// 	VADDPS.RN_SAE zmm zmm zmm
func VADDPS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPS_RN_SAE: bad operands")
}

// VADDPS_RN_SAE_Z: Add Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VADDPS.RN_SAE.Z zmm zmm k zmm
func VADDPS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPS_RN_SAE_Z: bad operands")
}

// VADDPS_RU_SAE: Add Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VADDPS.RU_SAE zmm zmm k zmm
// 	VADDPS.RU_SAE zmm zmm zmm
func VADDPS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPS_RU_SAE: bad operands")
}

// VADDPS_RU_SAE_Z: Add Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VADDPS.RU_SAE.Z zmm zmm k zmm
func VADDPS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPS_RU_SAE_Z: bad operands")
}

// VADDPS_RZ_SAE: Add Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VADDPS.RZ_SAE zmm zmm k zmm
// 	VADDPS.RZ_SAE zmm zmm zmm
func VADDPS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPS_RZ_SAE: bad operands")
}

// VADDPS_RZ_SAE_Z: Add Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VADDPS.RZ_SAE.Z zmm zmm k zmm
func VADDPS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPS_RZ_SAE_Z: bad operands")
}

// VADDPS_Z: Add Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VADDPS.Z m512 zmm k zmm
// 	VADDPS.Z zmm  zmm k zmm
// 	VADDPS.Z m128 xmm k xmm
// 	VADDPS.Z m256 ymm k ymm
// 	VADDPS.Z xmm  xmm k xmm
// 	VADDPS.Z ymm  ymm k ymm
func VADDPS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VADDPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDPS_Z: bad operands")
}

// VADDSD: Add Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VADDSD m64 xmm xmm
// 	VADDSD xmm xmm xmm
// 	VADDSD m64 xmm k xmm
// 	VADDSD xmm xmm k xmm
func VADDSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VADDSD: bad operands")
}

// VADDSD_RD_SAE: Add Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VADDSD.RD_SAE xmm xmm k xmm
// 	VADDSD.RD_SAE xmm xmm xmm
func VADDSD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSD_RD_SAE: bad operands")
}

// VADDSD_RD_SAE_Z: Add Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VADDSD.RD_SAE.Z xmm xmm k xmm
func VADDSD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSD_RD_SAE_Z: bad operands")
}

// VADDSD_RN_SAE: Add Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VADDSD.RN_SAE xmm xmm k xmm
// 	VADDSD.RN_SAE xmm xmm xmm
func VADDSD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSD_RN_SAE: bad operands")
}

// VADDSD_RN_SAE_Z: Add Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VADDSD.RN_SAE.Z xmm xmm k xmm
func VADDSD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSD_RN_SAE_Z: bad operands")
}

// VADDSD_RU_SAE: Add Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VADDSD.RU_SAE xmm xmm k xmm
// 	VADDSD.RU_SAE xmm xmm xmm
func VADDSD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSD_RU_SAE: bad operands")
}

// VADDSD_RU_SAE_Z: Add Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VADDSD.RU_SAE.Z xmm xmm k xmm
func VADDSD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSD_RU_SAE_Z: bad operands")
}

// VADDSD_RZ_SAE: Add Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VADDSD.RZ_SAE xmm xmm k xmm
// 	VADDSD.RZ_SAE xmm xmm xmm
func VADDSD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSD_RZ_SAE: bad operands")
}

// VADDSD_RZ_SAE_Z: Add Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VADDSD.RZ_SAE.Z xmm xmm k xmm
func VADDSD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSD_RZ_SAE_Z: bad operands")
}

// VADDSD_Z: Add Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VADDSD.Z m64 xmm k xmm
// 	VADDSD.Z xmm xmm k xmm
func VADDSD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VADDSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSD_Z: bad operands")
}

// VADDSS: Add Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VADDSS m32 xmm xmm
// 	VADDSS xmm xmm xmm
// 	VADDSS m32 xmm k xmm
// 	VADDSS xmm xmm k xmm
func VADDSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VADDSS: bad operands")
}

// VADDSS_RD_SAE: Add Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VADDSS.RD_SAE xmm xmm k xmm
// 	VADDSS.RD_SAE xmm xmm xmm
func VADDSS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSS_RD_SAE: bad operands")
}

// VADDSS_RD_SAE_Z: Add Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VADDSS.RD_SAE.Z xmm xmm k xmm
func VADDSS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSS_RD_SAE_Z: bad operands")
}

// VADDSS_RN_SAE: Add Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VADDSS.RN_SAE xmm xmm k xmm
// 	VADDSS.RN_SAE xmm xmm xmm
func VADDSS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSS_RN_SAE: bad operands")
}

// VADDSS_RN_SAE_Z: Add Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VADDSS.RN_SAE.Z xmm xmm k xmm
func VADDSS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSS_RN_SAE_Z: bad operands")
}

// VADDSS_RU_SAE: Add Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VADDSS.RU_SAE xmm xmm k xmm
// 	VADDSS.RU_SAE xmm xmm xmm
func VADDSS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSS_RU_SAE: bad operands")
}

// VADDSS_RU_SAE_Z: Add Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VADDSS.RU_SAE.Z xmm xmm k xmm
func VADDSS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSS_RU_SAE_Z: bad operands")
}

// VADDSS_RZ_SAE: Add Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VADDSS.RZ_SAE xmm xmm k xmm
// 	VADDSS.RZ_SAE xmm xmm xmm
func VADDSS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSS_RZ_SAE: bad operands")
}

// VADDSS_RZ_SAE_Z: Add Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VADDSS.RZ_SAE.Z xmm xmm k xmm
func VADDSS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSS_RZ_SAE_Z: bad operands")
}

// VADDSS_Z: Add Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VADDSS.Z m32 xmm k xmm
// 	VADDSS.Z xmm xmm k xmm
func VADDSS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VADDSS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VADDSS_Z: bad operands")
}

// VADDSUBPD: Packed Double-FP Add/Subtract.
//
// Forms:
//
// 	VADDSUBPD m128 xmm xmm
// 	VADDSUBPD m256 ymm ymm
// 	VADDSUBPD xmm  xmm xmm
// 	VADDSUBPD ymm  ymm ymm
func VADDSUBPD(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VADDSUBPD",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VADDSUBPD: bad operands")
}

// VADDSUBPS: Packed Single-FP Add/Subtract.
//
// Forms:
//
// 	VADDSUBPS m128 xmm xmm
// 	VADDSUBPS m256 ymm ymm
// 	VADDSUBPS xmm  xmm xmm
// 	VADDSUBPS ymm  ymm ymm
func VADDSUBPS(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VADDSUBPS",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VADDSUBPS: bad operands")
}

// VAESDEC: Perform One Round of an AES Decryption Flow.
//
// Forms:
//
// 	VAESDEC m128 xmm xmm
// 	VAESDEC xmm  xmm xmm
func VAESDEC(mx, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VAESDEC",
			Operands: []operand.Op{mx, x, x1},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX", "AES"},
		}, nil
	}
	return nil, errors.New("VAESDEC: bad operands")
}

// VAESDECLAST: Perform Last Round of an AES Decryption Flow.
//
// Forms:
//
// 	VAESDECLAST m128 xmm xmm
// 	VAESDECLAST xmm  xmm xmm
func VAESDECLAST(mx, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VAESDECLAST",
			Operands: []operand.Op{mx, x, x1},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX", "AES"},
		}, nil
	}
	return nil, errors.New("VAESDECLAST: bad operands")
}

// VAESENC: Perform One Round of an AES Encryption Flow.
//
// Forms:
//
// 	VAESENC m128 xmm xmm
// 	VAESENC xmm  xmm xmm
func VAESENC(mx, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VAESENC",
			Operands: []operand.Op{mx, x, x1},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX", "AES"},
		}, nil
	}
	return nil, errors.New("VAESENC: bad operands")
}

// VAESENCLAST: Perform Last Round of an AES Encryption Flow.
//
// Forms:
//
// 	VAESENCLAST m128 xmm xmm
// 	VAESENCLAST xmm  xmm xmm
func VAESENCLAST(mx, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VAESENCLAST",
			Operands: []operand.Op{mx, x, x1},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX", "AES"},
		}, nil
	}
	return nil, errors.New("VAESENCLAST: bad operands")
}

// VAESIMC: Perform the AES InvMixColumn Transformation.
//
// Forms:
//
// 	VAESIMC m128 xmm
// 	VAESIMC xmm  xmm
func VAESIMC(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VAESIMC",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX", "AES"},
		}, nil
	}
	return nil, errors.New("VAESIMC: bad operands")
}

// VAESKEYGENASSIST: AES Round Key Generation Assist.
//
// Forms:
//
// 	VAESKEYGENASSIST imm8 m128 xmm
// 	VAESKEYGENASSIST imm8 xmm  xmm
func VAESKEYGENASSIST(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VAESKEYGENASSIST",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX", "AES"},
		}, nil
	}
	return nil, errors.New("VAESKEYGENASSIST: bad operands")
}

// VALIGND: Align Doubleword Vectors.
//
// Forms:
//
// 	VALIGND imm8 m512 zmm k zmm
// 	VALIGND imm8 m512 zmm zmm
// 	VALIGND imm8 zmm  zmm k zmm
// 	VALIGND imm8 zmm  zmm zmm
// 	VALIGND imm8 m128 xmm k xmm
// 	VALIGND imm8 m128 xmm xmm
// 	VALIGND imm8 m256 ymm k ymm
// 	VALIGND imm8 m256 ymm ymm
// 	VALIGND imm8 xmm  xmm k xmm
// 	VALIGND imm8 xmm  xmm xmm
// 	VALIGND imm8 ymm  ymm k ymm
// 	VALIGND imm8 ymm  ymm ymm
func VALIGND(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VALIGND",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VALIGND",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VALIGND",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VALIGND",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VALIGND: bad operands")
}

// VALIGND_BCST: Align Doubleword Vectors (Broadcast).
//
// Forms:
//
// 	VALIGND.BCST imm8 m32 zmm k zmm
// 	VALIGND.BCST imm8 m32 zmm zmm
// 	VALIGND.BCST imm8 m32 xmm k xmm
// 	VALIGND.BCST imm8 m32 xmm xmm
// 	VALIGND.BCST imm8 m32 ymm k ymm
// 	VALIGND.BCST imm8 m32 ymm ymm
func VALIGND_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VALIGND",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VALIGND",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VALIGND",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VALIGND",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VALIGND_BCST: bad operands")
}

// VALIGND_BCST_Z: Align Doubleword Vectors (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VALIGND.BCST.Z imm8 m32 zmm k zmm
// 	VALIGND.BCST.Z imm8 m32 xmm k xmm
// 	VALIGND.BCST.Z imm8 m32 ymm k ymm
func VALIGND_BCST_Z(i, m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VALIGND",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VALIGND",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VALIGND_BCST_Z: bad operands")
}

// VALIGND_Z: Align Doubleword Vectors (Zeroing Masking).
//
// Forms:
//
// 	VALIGND.Z imm8 m512 zmm k zmm
// 	VALIGND.Z imm8 zmm  zmm k zmm
// 	VALIGND.Z imm8 m128 xmm k xmm
// 	VALIGND.Z imm8 m256 ymm k ymm
// 	VALIGND.Z imm8 xmm  xmm k xmm
// 	VALIGND.Z imm8 ymm  ymm k ymm
func VALIGND_Z(i, mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VALIGND",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VALIGND",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VALIGND_Z: bad operands")
}

// VALIGNQ: Align Quadword Vectors.
//
// Forms:
//
// 	VALIGNQ imm8 m512 zmm k zmm
// 	VALIGNQ imm8 m512 zmm zmm
// 	VALIGNQ imm8 zmm  zmm k zmm
// 	VALIGNQ imm8 zmm  zmm zmm
// 	VALIGNQ imm8 m128 xmm k xmm
// 	VALIGNQ imm8 m128 xmm xmm
// 	VALIGNQ imm8 m256 ymm k ymm
// 	VALIGNQ imm8 m256 ymm ymm
// 	VALIGNQ imm8 xmm  xmm k xmm
// 	VALIGNQ imm8 xmm  xmm xmm
// 	VALIGNQ imm8 ymm  ymm k ymm
// 	VALIGNQ imm8 ymm  ymm ymm
func VALIGNQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VALIGNQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VALIGNQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VALIGNQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VALIGNQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VALIGNQ: bad operands")
}

// VALIGNQ_BCST: Align Quadword Vectors (Broadcast).
//
// Forms:
//
// 	VALIGNQ.BCST imm8 m64 zmm k zmm
// 	VALIGNQ.BCST imm8 m64 zmm zmm
// 	VALIGNQ.BCST imm8 m64 xmm k xmm
// 	VALIGNQ.BCST imm8 m64 xmm xmm
// 	VALIGNQ.BCST imm8 m64 ymm k ymm
// 	VALIGNQ.BCST imm8 m64 ymm ymm
func VALIGNQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VALIGNQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VALIGNQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VALIGNQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VALIGNQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VALIGNQ_BCST: bad operands")
}

// VALIGNQ_BCST_Z: Align Quadword Vectors (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VALIGNQ.BCST.Z imm8 m64 zmm k zmm
// 	VALIGNQ.BCST.Z imm8 m64 xmm k xmm
// 	VALIGNQ.BCST.Z imm8 m64 ymm k ymm
func VALIGNQ_BCST_Z(i, m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VALIGNQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VALIGNQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VALIGNQ_BCST_Z: bad operands")
}

// VALIGNQ_Z: Align Quadword Vectors (Zeroing Masking).
//
// Forms:
//
// 	VALIGNQ.Z imm8 m512 zmm k zmm
// 	VALIGNQ.Z imm8 zmm  zmm k zmm
// 	VALIGNQ.Z imm8 m128 xmm k xmm
// 	VALIGNQ.Z imm8 m256 ymm k ymm
// 	VALIGNQ.Z imm8 xmm  xmm k xmm
// 	VALIGNQ.Z imm8 ymm  ymm k ymm
func VALIGNQ_Z(i, mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VALIGNQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VALIGNQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VALIGNQ_Z: bad operands")
}

// VANDNPD: Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VANDNPD m128 xmm xmm
// 	VANDNPD m256 ymm ymm
// 	VANDNPD xmm  xmm xmm
// 	VANDNPD ymm  ymm ymm
// 	VANDNPD m512 zmm k zmm
// 	VANDNPD m512 zmm zmm
// 	VANDNPD zmm  zmm k zmm
// 	VANDNPD zmm  zmm zmm
// 	VANDNPD m128 xmm k xmm
// 	VANDNPD m256 ymm k ymm
// 	VANDNPD xmm  xmm k xmm
// 	VANDNPD ymm  ymm k ymm
func VANDNPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VANDNPD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDNPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VANDNPD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDNPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VANDNPD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDNPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VANDNPD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDNPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDNPD: bad operands")
}

// VANDNPD_BCST: Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VANDNPD.BCST m64 zmm k zmm
// 	VANDNPD.BCST m64 zmm zmm
// 	VANDNPD.BCST m64 xmm k xmm
// 	VANDNPD.BCST m64 xmm xmm
// 	VANDNPD.BCST m64 ymm k ymm
// 	VANDNPD.BCST m64 ymm ymm
func VANDNPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDNPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDNPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDNPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDNPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDNPD_BCST: bad operands")
}

// VANDNPD_BCST_Z: Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VANDNPD.BCST.Z m64 zmm k zmm
// 	VANDNPD.BCST.Z m64 xmm k xmm
// 	VANDNPD.BCST.Z m64 ymm k ymm
func VANDNPD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDNPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDNPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDNPD_BCST_Z: bad operands")
}

// VANDNPD_Z: Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VANDNPD.Z m512 zmm k zmm
// 	VANDNPD.Z zmm  zmm k zmm
// 	VANDNPD.Z m128 xmm k xmm
// 	VANDNPD.Z m256 ymm k ymm
// 	VANDNPD.Z xmm  xmm k xmm
// 	VANDNPD.Z ymm  ymm k ymm
func VANDNPD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VANDNPD",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDNPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VANDNPD",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512VL", "AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDNPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDNPD_Z: bad operands")
}

// VANDNPS: Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VANDNPS m128 xmm xmm
// 	VANDNPS m256 ymm ymm
// 	VANDNPS xmm  xmm xmm
// 	VANDNPS ymm  ymm ymm
// 	VANDNPS m512 zmm k zmm
// 	VANDNPS m512 zmm zmm
// 	VANDNPS zmm  zmm k zmm
// 	VANDNPS zmm  zmm zmm
// 	VANDNPS m128 xmm k xmm
// 	VANDNPS m256 ymm k ymm
// 	VANDNPS xmm  xmm k xmm
// 	VANDNPS ymm  ymm k ymm
func VANDNPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VANDNPS",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDNPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VANDNPS",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDNPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VANDNPS",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDNPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VANDNPS",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDNPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDNPS: bad operands")
}

// VANDNPS_BCST: Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VANDNPS.BCST m32 zmm k zmm
// 	VANDNPS.BCST m32 zmm zmm
// 	VANDNPS.BCST m32 xmm k xmm
// 	VANDNPS.BCST m32 xmm xmm
// 	VANDNPS.BCST m32 ymm k ymm
// 	VANDNPS.BCST m32 ymm ymm
func VANDNPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDNPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDNPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDNPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDNPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDNPS_BCST: bad operands")
}

// VANDNPS_BCST_Z: Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VANDNPS.BCST.Z m32 zmm k zmm
// 	VANDNPS.BCST.Z m32 xmm k xmm
// 	VANDNPS.BCST.Z m32 ymm k ymm
func VANDNPS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDNPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDNPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDNPS_BCST_Z: bad operands")
}

// VANDNPS_Z: Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VANDNPS.Z m512 zmm k zmm
// 	VANDNPS.Z zmm  zmm k zmm
// 	VANDNPS.Z m128 xmm k xmm
// 	VANDNPS.Z m256 ymm k ymm
// 	VANDNPS.Z xmm  xmm k xmm
// 	VANDNPS.Z ymm  ymm k ymm
func VANDNPS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VANDNPS",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDNPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VANDNPS",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512VL", "AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDNPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDNPS_Z: bad operands")
}

// VANDPD: Bitwise Logical AND of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VANDPD m128 xmm xmm
// 	VANDPD m256 ymm ymm
// 	VANDPD xmm  xmm xmm
// 	VANDPD ymm  ymm ymm
// 	VANDPD m512 zmm k zmm
// 	VANDPD m512 zmm zmm
// 	VANDPD zmm  zmm k zmm
// 	VANDPD zmm  zmm zmm
// 	VANDPD m128 xmm k xmm
// 	VANDPD m256 ymm k ymm
// 	VANDPD xmm  xmm k xmm
// 	VANDPD ymm  ymm k ymm
func VANDPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDPD: bad operands")
}

// VANDPD_BCST: Bitwise Logical AND of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VANDPD.BCST m64 zmm k zmm
// 	VANDPD.BCST m64 zmm zmm
// 	VANDPD.BCST m64 xmm k xmm
// 	VANDPD.BCST m64 xmm xmm
// 	VANDPD.BCST m64 ymm k ymm
// 	VANDPD.BCST m64 ymm ymm
func VANDPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDPD_BCST: bad operands")
}

// VANDPD_BCST_Z: Bitwise Logical AND of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VANDPD.BCST.Z m64 zmm k zmm
// 	VANDPD.BCST.Z m64 xmm k xmm
// 	VANDPD.BCST.Z m64 ymm k ymm
func VANDPD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDPD_BCST_Z: bad operands")
}

// VANDPD_Z: Bitwise Logical AND of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VANDPD.Z m512 zmm k zmm
// 	VANDPD.Z zmm  zmm k zmm
// 	VANDPD.Z m128 xmm k xmm
// 	VANDPD.Z m256 ymm k ymm
// 	VANDPD.Z xmm  xmm k xmm
// 	VANDPD.Z ymm  ymm k ymm
func VANDPD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDPD_Z: bad operands")
}

// VANDPS: Bitwise Logical AND of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VANDPS m128 xmm xmm
// 	VANDPS m256 ymm ymm
// 	VANDPS xmm  xmm xmm
// 	VANDPS ymm  ymm ymm
// 	VANDPS m512 zmm k zmm
// 	VANDPS m512 zmm zmm
// 	VANDPS zmm  zmm k zmm
// 	VANDPS zmm  zmm zmm
// 	VANDPS m128 xmm k xmm
// 	VANDPS m256 ymm k ymm
// 	VANDPS xmm  xmm k xmm
// 	VANDPS ymm  ymm k ymm
func VANDPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDPS: bad operands")
}

// VANDPS_BCST: Bitwise Logical AND of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VANDPS.BCST m32 zmm k zmm
// 	VANDPS.BCST m32 zmm zmm
// 	VANDPS.BCST m32 xmm k xmm
// 	VANDPS.BCST m32 xmm xmm
// 	VANDPS.BCST m32 ymm k ymm
// 	VANDPS.BCST m32 ymm ymm
func VANDPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VANDPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VANDPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDPS_BCST: bad operands")
}

// VANDPS_BCST_Z: Bitwise Logical AND of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VANDPS.BCST.Z m32 zmm k zmm
// 	VANDPS.BCST.Z m32 xmm k xmm
// 	VANDPS.BCST.Z m32 ymm k ymm
func VANDPS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDPS_BCST_Z: bad operands")
}

// VANDPS_Z: Bitwise Logical AND of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VANDPS.Z m512 zmm k zmm
// 	VANDPS.Z zmm  zmm k zmm
// 	VANDPS.Z m128 xmm k xmm
// 	VANDPS.Z m256 ymm k ymm
// 	VANDPS.Z xmm  xmm k xmm
// 	VANDPS.Z ymm  ymm k ymm
func VANDPS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VANDPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VANDPS_Z: bad operands")
}

// VBLENDMPD: Blend Packed Double-Precision Floating-Point Vectors Using an OpMask Control.
//
// Forms:
//
// 	VBLENDMPD m512 zmm k zmm
// 	VBLENDMPD m512 zmm zmm
// 	VBLENDMPD zmm  zmm k zmm
// 	VBLENDMPD zmm  zmm zmm
// 	VBLENDMPD m128 xmm k xmm
// 	VBLENDMPD m128 xmm xmm
// 	VBLENDMPD m256 ymm k ymm
// 	VBLENDMPD m256 ymm ymm
// 	VBLENDMPD xmm  xmm k xmm
// 	VBLENDMPD xmm  xmm xmm
// 	VBLENDMPD ymm  ymm k ymm
// 	VBLENDMPD ymm  ymm ymm
func VBLENDMPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VBLENDMPD: bad operands")
}

// VBLENDMPD_BCST: Blend Packed Double-Precision Floating-Point Vectors Using an OpMask Control (Broadcast).
//
// Forms:
//
// 	VBLENDMPD.BCST m64 zmm k zmm
// 	VBLENDMPD.BCST m64 zmm zmm
// 	VBLENDMPD.BCST m64 xmm k xmm
// 	VBLENDMPD.BCST m64 xmm xmm
// 	VBLENDMPD.BCST m64 ymm k ymm
// 	VBLENDMPD.BCST m64 ymm ymm
func VBLENDMPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VBLENDMPD_BCST: bad operands")
}

// VBLENDMPD_BCST_Z: Blend Packed Double-Precision Floating-Point Vectors Using an OpMask Control (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VBLENDMPD.BCST.Z m64 zmm k zmm
// 	VBLENDMPD.BCST.Z m64 xmm k xmm
// 	VBLENDMPD.BCST.Z m64 ymm k ymm
func VBLENDMPD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VBLENDMPD_BCST_Z: bad operands")
}

// VBLENDMPD_Z: Blend Packed Double-Precision Floating-Point Vectors Using an OpMask Control (Zeroing Masking).
//
// Forms:
//
// 	VBLENDMPD.Z m512 zmm k zmm
// 	VBLENDMPD.Z zmm  zmm k zmm
// 	VBLENDMPD.Z m128 xmm k xmm
// 	VBLENDMPD.Z m256 ymm k ymm
// 	VBLENDMPD.Z xmm  xmm k xmm
// 	VBLENDMPD.Z ymm  ymm k ymm
func VBLENDMPD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VBLENDMPD_Z: bad operands")
}

// VBLENDMPS: Blend Packed Single-Precision Floating-Point Vectors Using an OpMask Control.
//
// Forms:
//
// 	VBLENDMPS m512 zmm k zmm
// 	VBLENDMPS m512 zmm zmm
// 	VBLENDMPS zmm  zmm k zmm
// 	VBLENDMPS zmm  zmm zmm
// 	VBLENDMPS m128 xmm k xmm
// 	VBLENDMPS m128 xmm xmm
// 	VBLENDMPS m256 ymm k ymm
// 	VBLENDMPS m256 ymm ymm
// 	VBLENDMPS xmm  xmm k xmm
// 	VBLENDMPS xmm  xmm xmm
// 	VBLENDMPS ymm  ymm k ymm
// 	VBLENDMPS ymm  ymm ymm
func VBLENDMPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VBLENDMPS: bad operands")
}

// VBLENDMPS_BCST: Blend Packed Single-Precision Floating-Point Vectors Using an OpMask Control (Broadcast).
//
// Forms:
//
// 	VBLENDMPS.BCST m32 zmm k zmm
// 	VBLENDMPS.BCST m32 zmm zmm
// 	VBLENDMPS.BCST m32 xmm k xmm
// 	VBLENDMPS.BCST m32 xmm xmm
// 	VBLENDMPS.BCST m32 ymm k ymm
// 	VBLENDMPS.BCST m32 ymm ymm
func VBLENDMPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VBLENDMPS_BCST: bad operands")
}

// VBLENDMPS_BCST_Z: Blend Packed Single-Precision Floating-Point Vectors Using an OpMask Control (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VBLENDMPS.BCST.Z m32 zmm k zmm
// 	VBLENDMPS.BCST.Z m32 xmm k xmm
// 	VBLENDMPS.BCST.Z m32 ymm k ymm
func VBLENDMPS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VBLENDMPS_BCST_Z: bad operands")
}

// VBLENDMPS_Z: Blend Packed Single-Precision Floating-Point Vectors Using an OpMask Control (Zeroing Masking).
//
// Forms:
//
// 	VBLENDMPS.Z m512 zmm k zmm
// 	VBLENDMPS.Z zmm  zmm k zmm
// 	VBLENDMPS.Z m128 xmm k xmm
// 	VBLENDMPS.Z m256 ymm k ymm
// 	VBLENDMPS.Z xmm  xmm k xmm
// 	VBLENDMPS.Z ymm  ymm k ymm
func VBLENDMPS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VBLENDMPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VBLENDMPS_Z: bad operands")
}

// VBLENDPD: Blend Packed Double Precision Floating-Point Values.
//
// Forms:
//
// 	VBLENDPD imm8 m128 xmm xmm
// 	VBLENDPD imm8 m256 ymm ymm
// 	VBLENDPD imm8 xmm  xmm xmm
// 	VBLENDPD imm8 ymm  ymm ymm
func VBLENDPD(i, mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsIMM8(i) && operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsIMM8(i) && operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsIMM8(i) && operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VBLENDPD",
			Operands: []operand.Op{i, mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VBLENDPD: bad operands")
}

// VBLENDPS:  Blend Packed Single Precision Floating-Point Values.
//
// Forms:
//
// 	VBLENDPS imm8 m128 xmm xmm
// 	VBLENDPS imm8 m256 ymm ymm
// 	VBLENDPS imm8 xmm  xmm xmm
// 	VBLENDPS imm8 ymm  ymm ymm
func VBLENDPS(i, mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsIMM8(i) && operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsIMM8(i) && operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsIMM8(i) && operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VBLENDPS",
			Operands: []operand.Op{i, mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VBLENDPS: bad operands")
}

// VBLENDVPD:  Variable Blend Packed Double Precision Floating-Point Values.
//
// Forms:
//
// 	VBLENDVPD xmm m128 xmm xmm
// 	VBLENDVPD xmm xmm  xmm xmm
// 	VBLENDVPD ymm m256 ymm ymm
// 	VBLENDVPD ymm ymm  ymm ymm
func VBLENDVPD(xy, mxy, xy1, xy2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(xy) && operand.IsM128(mxy) && operand.IsXMM(xy1) && operand.IsXMM(xy2),
		operand.IsXMM(xy) && operand.IsXMM(mxy) && operand.IsXMM(xy1) && operand.IsXMM(xy2),
		operand.IsYMM(xy) && operand.IsM256(mxy) && operand.IsYMM(xy1) && operand.IsYMM(xy2),
		operand.IsYMM(xy) && operand.IsYMM(mxy) && operand.IsYMM(xy1) && operand.IsYMM(xy2):
		return &intrep.Instruction{
			Opcode:   "VBLENDVPD",
			Operands: []operand.Op{xy, mxy, xy1, xy2},
			Inputs:   []operand.Op{xy, mxy, xy1},
			Outputs:  []operand.Op{xy2},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VBLENDVPD: bad operands")
}

// VBLENDVPS:  Variable Blend Packed Single Precision Floating-Point Values.
//
// Forms:
//
// 	VBLENDVPS xmm m128 xmm xmm
// 	VBLENDVPS xmm xmm  xmm xmm
// 	VBLENDVPS ymm m256 ymm ymm
// 	VBLENDVPS ymm ymm  ymm ymm
func VBLENDVPS(xy, mxy, xy1, xy2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(xy) && operand.IsM128(mxy) && operand.IsXMM(xy1) && operand.IsXMM(xy2),
		operand.IsXMM(xy) && operand.IsXMM(mxy) && operand.IsXMM(xy1) && operand.IsXMM(xy2),
		operand.IsYMM(xy) && operand.IsM256(mxy) && operand.IsYMM(xy1) && operand.IsYMM(xy2),
		operand.IsYMM(xy) && operand.IsYMM(mxy) && operand.IsYMM(xy1) && operand.IsYMM(xy2):
		return &intrep.Instruction{
			Opcode:   "VBLENDVPS",
			Operands: []operand.Op{xy, mxy, xy1, xy2},
			Inputs:   []operand.Op{xy, mxy, xy1},
			Outputs:  []operand.Op{xy2},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VBLENDVPS: bad operands")
}

// VBROADCASTF128: Broadcast 128 Bit of Floating-Point Data.
//
// Forms:
//
// 	VBROADCASTF128 m128 ymm
func VBROADCASTF128(m, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(m) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF128",
			Operands: []operand.Op{m, y},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VBROADCASTF128: bad operands")
}

// VBROADCASTF32X2: Broadcast Two Single-Precision Floating-Point Elements.
//
// Forms:
//
// 	VBROADCASTF32X2 m64 k zmm
// 	VBROADCASTF32X2 m64 zmm
// 	VBROADCASTF32X2 xmm k zmm
// 	VBROADCASTF32X2 xmm zmm
// 	VBROADCASTF32X2 m64 k ymm
// 	VBROADCASTF32X2 m64 ymm
// 	VBROADCASTF32X2 xmm k ymm
// 	VBROADCASTF32X2 xmm ymm
func VBROADCASTF32X2(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VBROADCASTF32X2: bad operands")
}

// VBROADCASTF32X2_Z: Broadcast Two Single-Precision Floating-Point Elements (Zeroing Masking).
//
// Forms:
//
// 	VBROADCASTF32X2.Z m64 k zmm
// 	VBROADCASTF32X2.Z xmm k zmm
// 	VBROADCASTF32X2.Z m64 k ymm
// 	VBROADCASTF32X2.Z xmm k ymm
func VBROADCASTF32X2_Z(mx, k, yz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsK(k) && operand.IsZMM(yz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, yz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM64(mx) && operand.IsK(k) && operand.IsYMM(yz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, yz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VBROADCASTF32X2_Z: bad operands")
}

// VBROADCASTF32X4: Broadcast Four Single-Precision Floating-Point Elements.
//
// Forms:
//
// 	VBROADCASTF32X4 m128 k zmm
// 	VBROADCASTF32X4 m128 zmm
// 	VBROADCASTF32X4 m128 k ymm
// 	VBROADCASTF32X4 m128 ymm
func VBROADCASTF32X4(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VBROADCASTF32X4: bad operands")
}

// VBROADCASTF32X4_Z: Broadcast Four Single-Precision Floating-Point Elements (Zeroing Masking).
//
// Forms:
//
// 	VBROADCASTF32X4.Z m128 k zmm
// 	VBROADCASTF32X4.Z m128 k ymm
func VBROADCASTF32X4_Z(m, k, yz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(m) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{m, k, yz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(m) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{m, k, yz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VBROADCASTF32X4_Z: bad operands")
}

// VBROADCASTF32X8: Broadcast Eight Single-Precision Floating-Point Elements.
//
// Forms:
//
// 	VBROADCASTF32X8 m256 k zmm
// 	VBROADCASTF32X8 m256 zmm
func VBROADCASTF32X8(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X8",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X8",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VBROADCASTF32X8: bad operands")
}

// VBROADCASTF32X8_Z: Broadcast Eight Single-Precision Floating-Point Elements (Zeroing Masking).
//
// Forms:
//
// 	VBROADCASTF32X8.Z m256 k zmm
func VBROADCASTF32X8_Z(m, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(m) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF32X8",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{m, k, z},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VBROADCASTF32X8_Z: bad operands")
}

// VBROADCASTF64X2: Broadcast Two Double-Precision Floating-Point Elements.
//
// Forms:
//
// 	VBROADCASTF64X2 m128 k zmm
// 	VBROADCASTF64X2 m128 zmm
// 	VBROADCASTF64X2 m128 k ymm
// 	VBROADCASTF64X2 m128 ymm
func VBROADCASTF64X2(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VBROADCASTF64X2: bad operands")
}

// VBROADCASTF64X2_Z: Broadcast Two Double-Precision Floating-Point Elements (Zeroing Masking).
//
// Forms:
//
// 	VBROADCASTF64X2.Z m128 k zmm
// 	VBROADCASTF64X2.Z m128 k ymm
func VBROADCASTF64X2_Z(m, k, yz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(m) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{m, k, yz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(m) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{m, k, yz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VBROADCASTF64X2_Z: bad operands")
}

// VBROADCASTF64X4: Broadcast Four Double-Precision Floating-Point Elements.
//
// Forms:
//
// 	VBROADCASTF64X4 m256 k zmm
// 	VBROADCASTF64X4 m256 zmm
func VBROADCASTF64X4(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF64X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF64X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VBROADCASTF64X4: bad operands")
}

// VBROADCASTF64X4_Z: Broadcast Four Double-Precision Floating-Point Elements (Zeroing Masking).
//
// Forms:
//
// 	VBROADCASTF64X4.Z m256 k zmm
func VBROADCASTF64X4_Z(m, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(m) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTF64X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{m, k, z},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VBROADCASTF64X4_Z: bad operands")
}

// VBROADCASTI128: Broadcast 128 Bits of Integer Data.
//
// Forms:
//
// 	VBROADCASTI128 m128 ymm
func VBROADCASTI128(m, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(m) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI128",
			Operands: []operand.Op{m, y},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VBROADCASTI128: bad operands")
}

// VBROADCASTI32X2: Broadcast Two Doubleword Elements.
//
// Forms:
//
// 	VBROADCASTI32X2 m64 k zmm
// 	VBROADCASTI32X2 m64 zmm
// 	VBROADCASTI32X2 xmm k zmm
// 	VBROADCASTI32X2 xmm zmm
// 	VBROADCASTI32X2 m64 k xmm
// 	VBROADCASTI32X2 m64 k ymm
// 	VBROADCASTI32X2 m64 xmm
// 	VBROADCASTI32X2 m64 ymm
// 	VBROADCASTI32X2 xmm k xmm
// 	VBROADCASTI32X2 xmm k ymm
// 	VBROADCASTI32X2 xmm xmm
// 	VBROADCASTI32X2 xmm ymm
func VBROADCASTI32X2(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VBROADCASTI32X2: bad operands")
}

// VBROADCASTI32X2_Z: Broadcast Two Doubleword Elements (Zeroing Masking).
//
// Forms:
//
// 	VBROADCASTI32X2.Z m64 k zmm
// 	VBROADCASTI32X2.Z xmm k zmm
// 	VBROADCASTI32X2.Z m64 k xmm
// 	VBROADCASTI32X2.Z m64 k ymm
// 	VBROADCASTI32X2.Z xmm k xmm
// 	VBROADCASTI32X2.Z xmm k ymm
func VBROADCASTI32X2_Z(mx, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, xyz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM64(mx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(mx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, xyz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VBROADCASTI32X2_Z: bad operands")
}

// VBROADCASTI32X4: Broadcast Four Doubleword Elements.
//
// Forms:
//
// 	VBROADCASTI32X4 m128 k zmm
// 	VBROADCASTI32X4 m128 zmm
// 	VBROADCASTI32X4 m128 k ymm
// 	VBROADCASTI32X4 m128 ymm
func VBROADCASTI32X4(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VBROADCASTI32X4: bad operands")
}

// VBROADCASTI32X4_Z: Broadcast Four Doubleword Elements (Zeroing Masking).
//
// Forms:
//
// 	VBROADCASTI32X4.Z m128 k zmm
// 	VBROADCASTI32X4.Z m128 k ymm
func VBROADCASTI32X4_Z(m, k, yz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(m) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{m, k, yz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(m) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{m, k, yz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VBROADCASTI32X4_Z: bad operands")
}

// VBROADCASTI32X8: Broadcast Eight Doubleword Elements.
//
// Forms:
//
// 	VBROADCASTI32X8 m256 k zmm
// 	VBROADCASTI32X8 m256 zmm
func VBROADCASTI32X8(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X8",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X8",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VBROADCASTI32X8: bad operands")
}

// VBROADCASTI32X8_Z: Broadcast Eight Doubleword Elements (Zeroing Masking).
//
// Forms:
//
// 	VBROADCASTI32X8.Z m256 k zmm
func VBROADCASTI32X8_Z(m, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(m) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI32X8",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{m, k, z},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VBROADCASTI32X8_Z: bad operands")
}

// VBROADCASTI64X2: Broadcast Two Quadword Elements.
//
// Forms:
//
// 	VBROADCASTI64X2 m128 k zmm
// 	VBROADCASTI64X2 m128 zmm
// 	VBROADCASTI64X2 m128 k ymm
// 	VBROADCASTI64X2 m128 ymm
func VBROADCASTI64X2(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VBROADCASTI64X2: bad operands")
}

// VBROADCASTI64X2_Z: Broadcast Two Quadword Elements (Zeroing Masking).
//
// Forms:
//
// 	VBROADCASTI64X2.Z m128 k zmm
// 	VBROADCASTI64X2.Z m128 k ymm
func VBROADCASTI64X2_Z(m, k, yz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(m) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{m, k, yz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(m) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{m, k, yz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VBROADCASTI64X2_Z: bad operands")
}

// VBROADCASTI64X4: Broadcast Four Quadword Elements.
//
// Forms:
//
// 	VBROADCASTI64X4 m256 k zmm
// 	VBROADCASTI64X4 m256 zmm
func VBROADCASTI64X4(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI64X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI64X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VBROADCASTI64X4: bad operands")
}

// VBROADCASTI64X4_Z: Broadcast Four Quadword Elements (Zeroing Masking).
//
// Forms:
//
// 	VBROADCASTI64X4.Z m256 k zmm
func VBROADCASTI64X4_Z(m, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(m) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTI64X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{m, k, z},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VBROADCASTI64X4_Z: bad operands")
}

// VBROADCASTSD: Broadcast Double-Precision Floating-Point Element.
//
// Forms:
//
// 	VBROADCASTSD xmm ymm
// 	VBROADCASTSD m64 ymm
// 	VBROADCASTSD m64 k zmm
// 	VBROADCASTSD m64 zmm
// 	VBROADCASTSD xmm k zmm
// 	VBROADCASTSD xmm zmm
// 	VBROADCASTSD m64 k ymm
// 	VBROADCASTSD xmm k ymm
func VBROADCASTSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VBROADCASTSD: bad operands")
}

// VBROADCASTSD_Z: Broadcast Double-Precision Floating-Point Element (Zeroing Masking).
//
// Forms:
//
// 	VBROADCASTSD.Z m64 k zmm
// 	VBROADCASTSD.Z xmm k zmm
// 	VBROADCASTSD.Z m64 k ymm
// 	VBROADCASTSD.Z xmm k ymm
func VBROADCASTSD_Z(mx, k, yz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsK(k) && operand.IsZMM(yz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, yz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(mx) && operand.IsK(k) && operand.IsYMM(yz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, yz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VBROADCASTSD_Z: bad operands")
}

// VBROADCASTSS: Broadcast Single-Precision Floating-Point Element.
//
// Forms:
//
// 	VBROADCASTSS xmm xmm
// 	VBROADCASTSS xmm ymm
// 	VBROADCASTSS m32 xmm
// 	VBROADCASTSS m32 ymm
// 	VBROADCASTSS m32 k zmm
// 	VBROADCASTSS m32 zmm
// 	VBROADCASTSS xmm k zmm
// 	VBROADCASTSS xmm zmm
// 	VBROADCASTSS m32 k ymm
// 	VBROADCASTSS xmm k ymm
func VBROADCASTSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VBROADCASTSS: bad operands")
}

// VBROADCASTSS_Z: Broadcast Single-Precision Floating-Point Element (Zeroing Masking).
//
// Forms:
//
// 	VBROADCASTSS.Z m32 k zmm
// 	VBROADCASTSS.Z xmm k zmm
// 	VBROADCASTSS.Z m32 k ymm
// 	VBROADCASTSS.Z xmm k ymm
func VBROADCASTSS_Z(mx, k, yz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsK(k) && operand.IsZMM(yz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTSS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, yz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(mx) && operand.IsK(k) && operand.IsYMM(yz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VBROADCASTSS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, yz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VBROADCASTSS_Z: bad operands")
}

// VCMPPD: Compare Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VCMPPD imm8 m128 xmm xmm
// 	VCMPPD imm8 m256 ymm ymm
// 	VCMPPD imm8 xmm  xmm xmm
// 	VCMPPD imm8 ymm  ymm ymm
// 	VCMPPD imm8 m512 zmm k k
// 	VCMPPD imm8 m512 zmm k
// 	VCMPPD imm8 zmm  zmm k k
// 	VCMPPD imm8 zmm  zmm k
// 	VCMPPD imm8 m128 xmm k k
// 	VCMPPD imm8 m128 xmm k
// 	VCMPPD imm8 m256 ymm k k
// 	VCMPPD imm8 m256 ymm k
// 	VCMPPD imm8 xmm  xmm k k
// 	VCMPPD imm8 xmm  xmm k
// 	VCMPPD imm8 ymm  ymm k k
// 	VCMPPD imm8 ymm  ymm k
func VCMPPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VCMPPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VCMPPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCMPPD: bad operands")
}

// VCMPPD_BCST: Compare Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VCMPPD.BCST imm8 m64 zmm k k
// 	VCMPPD.BCST imm8 m64 zmm k
// 	VCMPPD.BCST imm8 m64 xmm k k
// 	VCMPPD.BCST imm8 m64 xmm k
// 	VCMPPD.BCST imm8 m64 ymm k k
// 	VCMPPD.BCST imm8 m64 ymm k
func VCMPPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VCMPPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VCMPPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCMPPD_BCST: bad operands")
}

// VCMPPD_SAE: Compare Packed Double-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VCMPPD.SAE imm8 zmm zmm k k
// 	VCMPPD.SAE imm8 zmm zmm k
func VCMPPD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VCMPPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCMPPD_SAE: bad operands")
}

// VCMPPS: Compare Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VCMPPS imm8 m128 xmm xmm
// 	VCMPPS imm8 m256 ymm ymm
// 	VCMPPS imm8 xmm  xmm xmm
// 	VCMPPS imm8 ymm  ymm ymm
// 	VCMPPS imm8 m512 zmm k k
// 	VCMPPS imm8 m512 zmm k
// 	VCMPPS imm8 zmm  zmm k k
// 	VCMPPS imm8 zmm  zmm k
// 	VCMPPS imm8 m128 xmm k k
// 	VCMPPS imm8 m128 xmm k
// 	VCMPPS imm8 m256 ymm k k
// 	VCMPPS imm8 m256 ymm k
// 	VCMPPS imm8 xmm  xmm k k
// 	VCMPPS imm8 xmm  xmm k
// 	VCMPPS imm8 ymm  ymm k k
// 	VCMPPS imm8 ymm  ymm k
func VCMPPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VCMPPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VCMPPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCMPPS: bad operands")
}

// VCMPPS_BCST: Compare Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VCMPPS.BCST imm8 m32 zmm k k
// 	VCMPPS.BCST imm8 m32 zmm k
// 	VCMPPS.BCST imm8 m32 xmm k k
// 	VCMPPS.BCST imm8 m32 xmm k
// 	VCMPPS.BCST imm8 m32 ymm k k
// 	VCMPPS.BCST imm8 m32 ymm k
func VCMPPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VCMPPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VCMPPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCMPPS_BCST: bad operands")
}

// VCMPPS_SAE: Compare Packed Single-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VCMPPS.SAE imm8 zmm zmm k k
// 	VCMPPS.SAE imm8 zmm zmm k
func VCMPPS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VCMPPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCMPPS_SAE: bad operands")
}

// VCMPSD: Compare Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VCMPSD imm8 m64 xmm xmm
// 	VCMPSD imm8 xmm xmm xmm
// 	VCMPSD imm8 m64 xmm k k
// 	VCMPSD imm8 m64 xmm k
// 	VCMPSD imm8 xmm xmm k k
// 	VCMPSD imm8 xmm xmm k
func VCMPSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VCMPSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCMPSD: bad operands")
}

// VCMPSD_SAE: Compare Scalar Double-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VCMPSD.SAE imm8 xmm xmm k k
// 	VCMPSD.SAE imm8 xmm xmm k
func VCMPSD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VCMPSD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPSD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCMPSD_SAE: bad operands")
}

// VCMPSS: Compare Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VCMPSS imm8 m32 xmm xmm
// 	VCMPSS imm8 xmm xmm xmm
// 	VCMPSS imm8 m32 xmm k k
// 	VCMPSS imm8 m32 xmm k
// 	VCMPSS imm8 xmm xmm k k
// 	VCMPSS imm8 xmm xmm k
func VCMPSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VCMPSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCMPSS: bad operands")
}

// VCMPSS_SAE: Compare Scalar Single-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VCMPSS.SAE imm8 xmm xmm k k
// 	VCMPSS.SAE imm8 xmm xmm k
func VCMPSS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VCMPSS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCMPSS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCMPSS_SAE: bad operands")
}

// VCOMISD: Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS.
//
// Forms:
//
// 	VCOMISD m64 xmm
// 	VCOMISD xmm xmm
func VCOMISD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCOMISD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCOMISD: bad operands")
}

// VCOMISD_SAE: Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS (Suppress All Exceptions).
//
// Forms:
//
// 	VCOMISD.SAE xmm xmm
func VCOMISD_SAE(x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCOMISD",
			Suffixes: []string{"SAE"},
			Operands: []operand.Op{x, x1},
			Inputs:   []operand.Op{x, x1},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCOMISD_SAE: bad operands")
}

// VCOMISS: Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS.
//
// Forms:
//
// 	VCOMISS m32 xmm
// 	VCOMISS xmm xmm
func VCOMISS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCOMISS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCOMISS: bad operands")
}

// VCOMISS_SAE: Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS (Suppress All Exceptions).
//
// Forms:
//
// 	VCOMISS.SAE xmm xmm
func VCOMISS_SAE(x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCOMISS",
			Suffixes: []string{"SAE"},
			Operands: []operand.Op{x, x1},
			Inputs:   []operand.Op{x, x1},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCOMISS_SAE: bad operands")
}

// VCOMPRESSPD: Store Sparse Packed Double-Precision Floating-Point Values into Dense Memory/Register.
//
// Forms:
//
// 	VCOMPRESSPD zmm k m512
// 	VCOMPRESSPD zmm k zmm
// 	VCOMPRESSPD zmm m512
// 	VCOMPRESSPD zmm zmm
// 	VCOMPRESSPD xmm k m128
// 	VCOMPRESSPD xmm k xmm
// 	VCOMPRESSPD xmm m128
// 	VCOMPRESSPD xmm xmm
// 	VCOMPRESSPD ymm k m256
// 	VCOMPRESSPD ymm k ymm
// 	VCOMPRESSPD ymm m256
// 	VCOMPRESSPD ymm ymm
func VCOMPRESSPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM512(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCOMPRESSPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCOMPRESSPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM512(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCOMPRESSPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCOMPRESSPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCOMPRESSPD: bad operands")
}

// VCOMPRESSPD_Z: Store Sparse Packed Double-Precision Floating-Point Values into Dense Memory/Register (Zeroing Masking).
//
// Forms:
//
// 	VCOMPRESSPD.Z zmm k m512
// 	VCOMPRESSPD.Z zmm k zmm
// 	VCOMPRESSPD.Z xmm k m128
// 	VCOMPRESSPD.Z xmm k xmm
// 	VCOMPRESSPD.Z ymm k m256
// 	VCOMPRESSPD.Z ymm k ymm
func VCOMPRESSPD_Z(xyz, k, mxyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM512(mxyz),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(mxyz):
		return &intrep.Instruction{
			Opcode:   "VCOMPRESSPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxyz},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM128(mxyz),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mxyz),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM256(mxyz),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(mxyz):
		return &intrep.Instruction{
			Opcode:   "VCOMPRESSPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxyz},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCOMPRESSPD_Z: bad operands")
}

// VCOMPRESSPS: Store Sparse Packed Single-Precision Floating-Point Values into Dense Memory/Register.
//
// Forms:
//
// 	VCOMPRESSPS zmm k m512
// 	VCOMPRESSPS zmm k zmm
// 	VCOMPRESSPS zmm m512
// 	VCOMPRESSPS zmm zmm
// 	VCOMPRESSPS xmm k m128
// 	VCOMPRESSPS xmm k xmm
// 	VCOMPRESSPS xmm m128
// 	VCOMPRESSPS xmm xmm
// 	VCOMPRESSPS ymm k m256
// 	VCOMPRESSPS ymm k ymm
// 	VCOMPRESSPS ymm m256
// 	VCOMPRESSPS ymm ymm
func VCOMPRESSPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM512(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCOMPRESSPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCOMPRESSPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM512(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCOMPRESSPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCOMPRESSPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCOMPRESSPS: bad operands")
}

// VCOMPRESSPS_Z: Store Sparse Packed Single-Precision Floating-Point Values into Dense Memory/Register (Zeroing Masking).
//
// Forms:
//
// 	VCOMPRESSPS.Z zmm k m512
// 	VCOMPRESSPS.Z zmm k zmm
// 	VCOMPRESSPS.Z xmm k m128
// 	VCOMPRESSPS.Z xmm k xmm
// 	VCOMPRESSPS.Z ymm k m256
// 	VCOMPRESSPS.Z ymm k ymm
func VCOMPRESSPS_Z(xyz, k, mxyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM512(mxyz),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(mxyz):
		return &intrep.Instruction{
			Opcode:   "VCOMPRESSPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxyz},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM128(mxyz),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mxyz),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM256(mxyz),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(mxyz):
		return &intrep.Instruction{
			Opcode:   "VCOMPRESSPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxyz},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCOMPRESSPS_Z: bad operands")
}

// VCVTDQ2PD: Convert Packed Dword Integers to Packed Double-Precision FP Values.
//
// Forms:
//
// 	VCVTDQ2PD m128 ymm
// 	VCVTDQ2PD m64  xmm
// 	VCVTDQ2PD xmm  xmm
// 	VCVTDQ2PD xmm  ymm
// 	VCVTDQ2PD m256 k zmm
// 	VCVTDQ2PD m256 zmm
// 	VCVTDQ2PD ymm  k zmm
// 	VCVTDQ2PD ymm  zmm
// 	VCVTDQ2PD m128 k ymm
// 	VCVTDQ2PD m64  k xmm
// 	VCVTDQ2PD xmm  k xmm
// 	VCVTDQ2PD xmm  k ymm
func VCVTDQ2PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PD: bad operands")
}

// VCVTDQ2PD_BCST: Convert Packed Dword Integers to Packed Double-Precision FP Values (Broadcast).
//
// Forms:
//
// 	VCVTDQ2PD.BCST m32 k zmm
// 	VCVTDQ2PD.BCST m32 zmm
// 	VCVTDQ2PD.BCST m32 k xmm
// 	VCVTDQ2PD.BCST m32 k ymm
// 	VCVTDQ2PD.BCST m32 xmm
// 	VCVTDQ2PD.BCST m32 ymm
func VCVTDQ2PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PD_BCST: bad operands")
}

// VCVTDQ2PD_BCST_Z: Convert Packed Dword Integers to Packed Double-Precision FP Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTDQ2PD.BCST.Z m32 k zmm
// 	VCVTDQ2PD.BCST.Z m32 k xmm
// 	VCVTDQ2PD.BCST.Z m32 k ymm
func VCVTDQ2PD_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PD_BCST_Z: bad operands")
}

// VCVTDQ2PD_Z: Convert Packed Dword Integers to Packed Double-Precision FP Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTDQ2PD.Z m256 k zmm
// 	VCVTDQ2PD.Z ymm  k zmm
// 	VCVTDQ2PD.Z m128 k ymm
// 	VCVTDQ2PD.Z m64  k xmm
// 	VCVTDQ2PD.Z xmm  k xmm
// 	VCVTDQ2PD.Z xmm  k ymm
func VCVTDQ2PD_Z(mxy, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(mxy) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsYMM(mxy) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxy) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsM64(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PD_Z: bad operands")
}

// VCVTDQ2PS: Convert Packed Dword Integers to Packed Single-Precision FP Values.
//
// Forms:
//
// 	VCVTDQ2PS m128 xmm
// 	VCVTDQ2PS m256 ymm
// 	VCVTDQ2PS xmm  xmm
// 	VCVTDQ2PS ymm  ymm
// 	VCVTDQ2PS m512 k zmm
// 	VCVTDQ2PS m512 zmm
// 	VCVTDQ2PS zmm  k zmm
// 	VCVTDQ2PS zmm  zmm
// 	VCVTDQ2PS m128 k xmm
// 	VCVTDQ2PS m256 k ymm
// 	VCVTDQ2PS xmm  k xmm
// 	VCVTDQ2PS ymm  k ymm
func VCVTDQ2PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PS: bad operands")
}

// VCVTDQ2PS_BCST: Convert Packed Dword Integers to Packed Single-Precision FP Values (Broadcast).
//
// Forms:
//
// 	VCVTDQ2PS.BCST m32 k zmm
// 	VCVTDQ2PS.BCST m32 zmm
// 	VCVTDQ2PS.BCST m32 k xmm
// 	VCVTDQ2PS.BCST m32 k ymm
// 	VCVTDQ2PS.BCST m32 xmm
// 	VCVTDQ2PS.BCST m32 ymm
func VCVTDQ2PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PS_BCST: bad operands")
}

// VCVTDQ2PS_BCST_Z: Convert Packed Dword Integers to Packed Single-Precision FP Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTDQ2PS.BCST.Z m32 k zmm
// 	VCVTDQ2PS.BCST.Z m32 k xmm
// 	VCVTDQ2PS.BCST.Z m32 k ymm
func VCVTDQ2PS_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PS_BCST_Z: bad operands")
}

// VCVTDQ2PS_RD_SAE: Convert Packed Dword Integers to Packed Single-Precision FP Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTDQ2PS.RD_SAE zmm k zmm
// 	VCVTDQ2PS.RD_SAE zmm zmm
func VCVTDQ2PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PS_RD_SAE: bad operands")
}

// VCVTDQ2PS_RD_SAE_Z: Convert Packed Dword Integers to Packed Single-Precision FP Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTDQ2PS.RD_SAE.Z zmm k zmm
func VCVTDQ2PS_RD_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PS_RD_SAE_Z: bad operands")
}

// VCVTDQ2PS_RN_SAE: Convert Packed Dword Integers to Packed Single-Precision FP Values (Round Towards Nearest).
//
// Forms:
//
// 	VCVTDQ2PS.RN_SAE zmm k zmm
// 	VCVTDQ2PS.RN_SAE zmm zmm
func VCVTDQ2PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PS_RN_SAE: bad operands")
}

// VCVTDQ2PS_RN_SAE_Z: Convert Packed Dword Integers to Packed Single-Precision FP Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTDQ2PS.RN_SAE.Z zmm k zmm
func VCVTDQ2PS_RN_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PS_RN_SAE_Z: bad operands")
}

// VCVTDQ2PS_RU_SAE: Convert Packed Dword Integers to Packed Single-Precision FP Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTDQ2PS.RU_SAE zmm k zmm
// 	VCVTDQ2PS.RU_SAE zmm zmm
func VCVTDQ2PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PS_RU_SAE: bad operands")
}

// VCVTDQ2PS_RU_SAE_Z: Convert Packed Dword Integers to Packed Single-Precision FP Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTDQ2PS.RU_SAE.Z zmm k zmm
func VCVTDQ2PS_RU_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PS_RU_SAE_Z: bad operands")
}

// VCVTDQ2PS_RZ_SAE: Convert Packed Dword Integers to Packed Single-Precision FP Values (Round Towards Zero).
//
// Forms:
//
// 	VCVTDQ2PS.RZ_SAE zmm k zmm
// 	VCVTDQ2PS.RZ_SAE zmm zmm
func VCVTDQ2PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PS_RZ_SAE: bad operands")
}

// VCVTDQ2PS_RZ_SAE_Z: Convert Packed Dword Integers to Packed Single-Precision FP Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTDQ2PS.RZ_SAE.Z zmm k zmm
func VCVTDQ2PS_RZ_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PS_RZ_SAE_Z: bad operands")
}

// VCVTDQ2PS_Z: Convert Packed Dword Integers to Packed Single-Precision FP Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTDQ2PS.Z m512 k zmm
// 	VCVTDQ2PS.Z zmm  k zmm
// 	VCVTDQ2PS.Z m128 k xmm
// 	VCVTDQ2PS.Z m256 k ymm
// 	VCVTDQ2PS.Z xmm  k xmm
// 	VCVTDQ2PS.Z ymm  k ymm
func VCVTDQ2PS_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTDQ2PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTDQ2PS_Z: bad operands")
}

// VCVTPD2DQ: Convert Packed Double-Precision FP Values to Packed Dword Integers.
//
// Forms:
//
// 	VCVTPD2DQ m512 k ymm
// 	VCVTPD2DQ m512 ymm
// 	VCVTPD2DQ zmm  k ymm
// 	VCVTPD2DQ zmm  ymm
func VCVTPD2DQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQ: bad operands")
}

// VCVTPD2DQX: Convert Packed Double-Precision FP Values to Packed Dword Integers.
//
// Forms:
//
// 	VCVTPD2DQX m128 xmm
// 	VCVTPD2DQX xmm  xmm
// 	VCVTPD2DQX m128 k xmm
// 	VCVTPD2DQX xmm  k xmm
func VCVTPD2DQX(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQX",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQX",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQX: bad operands")
}

// VCVTPD2DQX_BCST: Convert Packed Double-Precision FP Values to Packed Dword Integers (Broadcast).
//
// Forms:
//
// 	VCVTPD2DQX.BCST m64 k xmm
// 	VCVTPD2DQX.BCST m64 xmm
func VCVTPD2DQX_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQX_BCST: bad operands")
}

// VCVTPD2DQX_BCST_Z: Convert Packed Double-Precision FP Values to Packed Dword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2DQX.BCST.Z m64 k xmm
func VCVTPD2DQX_BCST_Z(m, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQX",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, x},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQX_BCST_Z: bad operands")
}

// VCVTPD2DQX_Z: Convert Packed Double-Precision FP Values to Packed Dword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2DQX.Z m128 k xmm
// 	VCVTPD2DQX.Z xmm  k xmm
func VCVTPD2DQX_Z(mx, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsK(k) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQX",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, x},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQX_Z: bad operands")
}

// VCVTPD2DQY: Convert Packed Double-Precision FP Values to Packed Dword Integers.
//
// Forms:
//
// 	VCVTPD2DQY m256 xmm
// 	VCVTPD2DQY ymm  xmm
// 	VCVTPD2DQY m256 k xmm
// 	VCVTPD2DQY ymm  k xmm
func VCVTPD2DQY(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQY",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQY",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQY: bad operands")
}

// VCVTPD2DQY_BCST: Convert Packed Double-Precision FP Values to Packed Dword Integers (Broadcast).
//
// Forms:
//
// 	VCVTPD2DQY.BCST m64 k xmm
// 	VCVTPD2DQY.BCST m64 xmm
func VCVTPD2DQY_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQY_BCST: bad operands")
}

// VCVTPD2DQY_BCST_Z: Convert Packed Double-Precision FP Values to Packed Dword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2DQY.BCST.Z m64 k xmm
func VCVTPD2DQY_BCST_Z(m, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQY",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, x},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQY_BCST_Z: bad operands")
}

// VCVTPD2DQY_Z: Convert Packed Double-Precision FP Values to Packed Dword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2DQY.Z m256 k xmm
// 	VCVTPD2DQY.Z ymm  k xmm
func VCVTPD2DQY_Z(my, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(my) && operand.IsK(k) && operand.IsXMM(x),
		operand.IsYMM(my) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQY",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{my, k, x},
			Inputs:   []operand.Op{my, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQY_Z: bad operands")
}

// VCVTPD2DQ_BCST: Convert Packed Double-Precision FP Values to Packed Dword Integers (Broadcast).
//
// Forms:
//
// 	VCVTPD2DQ.BCST m64 k ymm
// 	VCVTPD2DQ.BCST m64 ymm
func VCVTPD2DQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQ_BCST: bad operands")
}

// VCVTPD2DQ_BCST_Z: Convert Packed Double-Precision FP Values to Packed Dword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2DQ.BCST.Z m64 k ymm
func VCVTPD2DQ_BCST_Z(m, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, y},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQ_BCST_Z: bad operands")
}

// VCVTPD2DQ_RD_SAE: Convert Packed Double-Precision FP Values to Packed Dword Integers (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTPD2DQ.RD_SAE zmm k ymm
// 	VCVTPD2DQ.RD_SAE zmm ymm
func VCVTPD2DQ_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQ_RD_SAE: bad operands")
}

// VCVTPD2DQ_RD_SAE_Z: Convert Packed Double-Precision FP Values to Packed Dword Integers (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2DQ.RD_SAE.Z zmm k ymm
func VCVTPD2DQ_RD_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQ_RD_SAE_Z: bad operands")
}

// VCVTPD2DQ_RN_SAE: Convert Packed Double-Precision FP Values to Packed Dword Integers (Round Towards Nearest).
//
// Forms:
//
// 	VCVTPD2DQ.RN_SAE zmm k ymm
// 	VCVTPD2DQ.RN_SAE zmm ymm
func VCVTPD2DQ_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQ_RN_SAE: bad operands")
}

// VCVTPD2DQ_RN_SAE_Z: Convert Packed Double-Precision FP Values to Packed Dword Integers (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2DQ.RN_SAE.Z zmm k ymm
func VCVTPD2DQ_RN_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQ_RN_SAE_Z: bad operands")
}

// VCVTPD2DQ_RU_SAE: Convert Packed Double-Precision FP Values to Packed Dword Integers (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTPD2DQ.RU_SAE zmm k ymm
// 	VCVTPD2DQ.RU_SAE zmm ymm
func VCVTPD2DQ_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQ_RU_SAE: bad operands")
}

// VCVTPD2DQ_RU_SAE_Z: Convert Packed Double-Precision FP Values to Packed Dword Integers (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2DQ.RU_SAE.Z zmm k ymm
func VCVTPD2DQ_RU_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQ_RU_SAE_Z: bad operands")
}

// VCVTPD2DQ_RZ_SAE: Convert Packed Double-Precision FP Values to Packed Dword Integers (Round Towards Zero).
//
// Forms:
//
// 	VCVTPD2DQ.RZ_SAE zmm k ymm
// 	VCVTPD2DQ.RZ_SAE zmm ymm
func VCVTPD2DQ_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQ_RZ_SAE: bad operands")
}

// VCVTPD2DQ_RZ_SAE_Z: Convert Packed Double-Precision FP Values to Packed Dword Integers (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2DQ.RZ_SAE.Z zmm k ymm
func VCVTPD2DQ_RZ_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQ_RZ_SAE_Z: bad operands")
}

// VCVTPD2DQ_Z: Convert Packed Double-Precision FP Values to Packed Dword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2DQ.Z m512 k ymm
// 	VCVTPD2DQ.Z zmm  k ymm
func VCVTPD2DQ_Z(mz, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsYMM(y),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2DQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, y},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2DQ_Z: bad operands")
}

// VCVTPD2PS: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values.
//
// Forms:
//
// 	VCVTPD2PS m512 k ymm
// 	VCVTPD2PS m512 ymm
// 	VCVTPD2PS zmm  k ymm
// 	VCVTPD2PS zmm  ymm
func VCVTPD2PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PS: bad operands")
}

// VCVTPD2PSX: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values.
//
// Forms:
//
// 	VCVTPD2PSX m128 xmm
// 	VCVTPD2PSX xmm  xmm
// 	VCVTPD2PSX m128 k xmm
// 	VCVTPD2PSX xmm  k xmm
func VCVTPD2PSX(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PSX",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PSX",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PSX: bad operands")
}

// VCVTPD2PSX_BCST: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Broadcast).
//
// Forms:
//
// 	VCVTPD2PSX.BCST m64 k xmm
// 	VCVTPD2PSX.BCST m64 xmm
func VCVTPD2PSX_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PSX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PSX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PSX_BCST: bad operands")
}

// VCVTPD2PSX_BCST_Z: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2PSX.BCST.Z m64 k xmm
func VCVTPD2PSX_BCST_Z(m, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PSX",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, x},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PSX_BCST_Z: bad operands")
}

// VCVTPD2PSX_Z: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2PSX.Z m128 k xmm
// 	VCVTPD2PSX.Z xmm  k xmm
func VCVTPD2PSX_Z(mx, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsK(k) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PSX",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, x},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PSX_Z: bad operands")
}

// VCVTPD2PSY: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values.
//
// Forms:
//
// 	VCVTPD2PSY m256 xmm
// 	VCVTPD2PSY ymm  xmm
// 	VCVTPD2PSY m256 k xmm
// 	VCVTPD2PSY ymm  k xmm
func VCVTPD2PSY(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PSY",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PSY",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PSY: bad operands")
}

// VCVTPD2PSY_BCST: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Broadcast).
//
// Forms:
//
// 	VCVTPD2PSY.BCST m64 k xmm
// 	VCVTPD2PSY.BCST m64 xmm
func VCVTPD2PSY_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PSY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PSY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PSY_BCST: bad operands")
}

// VCVTPD2PSY_BCST_Z: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2PSY.BCST.Z m64 k xmm
func VCVTPD2PSY_BCST_Z(m, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PSY",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, x},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PSY_BCST_Z: bad operands")
}

// VCVTPD2PSY_Z: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2PSY.Z m256 k xmm
// 	VCVTPD2PSY.Z ymm  k xmm
func VCVTPD2PSY_Z(my, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(my) && operand.IsK(k) && operand.IsXMM(x),
		operand.IsYMM(my) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PSY",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{my, k, x},
			Inputs:   []operand.Op{my, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PSY_Z: bad operands")
}

// VCVTPD2PS_BCST: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Broadcast).
//
// Forms:
//
// 	VCVTPD2PS.BCST m64 k ymm
// 	VCVTPD2PS.BCST m64 ymm
func VCVTPD2PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PS_BCST: bad operands")
}

// VCVTPD2PS_BCST_Z: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2PS.BCST.Z m64 k ymm
func VCVTPD2PS_BCST_Z(m, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, y},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PS_BCST_Z: bad operands")
}

// VCVTPD2PS_RD_SAE: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTPD2PS.RD_SAE zmm k ymm
// 	VCVTPD2PS.RD_SAE zmm ymm
func VCVTPD2PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PS_RD_SAE: bad operands")
}

// VCVTPD2PS_RD_SAE_Z: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2PS.RD_SAE.Z zmm k ymm
func VCVTPD2PS_RD_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PS_RD_SAE_Z: bad operands")
}

// VCVTPD2PS_RN_SAE: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Round Towards Nearest).
//
// Forms:
//
// 	VCVTPD2PS.RN_SAE zmm k ymm
// 	VCVTPD2PS.RN_SAE zmm ymm
func VCVTPD2PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PS_RN_SAE: bad operands")
}

// VCVTPD2PS_RN_SAE_Z: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2PS.RN_SAE.Z zmm k ymm
func VCVTPD2PS_RN_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PS_RN_SAE_Z: bad operands")
}

// VCVTPD2PS_RU_SAE: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTPD2PS.RU_SAE zmm k ymm
// 	VCVTPD2PS.RU_SAE zmm ymm
func VCVTPD2PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PS_RU_SAE: bad operands")
}

// VCVTPD2PS_RU_SAE_Z: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2PS.RU_SAE.Z zmm k ymm
func VCVTPD2PS_RU_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PS_RU_SAE_Z: bad operands")
}

// VCVTPD2PS_RZ_SAE: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Round Towards Zero).
//
// Forms:
//
// 	VCVTPD2PS.RZ_SAE zmm k ymm
// 	VCVTPD2PS.RZ_SAE zmm ymm
func VCVTPD2PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PS_RZ_SAE: bad operands")
}

// VCVTPD2PS_RZ_SAE_Z: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2PS.RZ_SAE.Z zmm k ymm
func VCVTPD2PS_RZ_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PS_RZ_SAE_Z: bad operands")
}

// VCVTPD2PS_Z: Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2PS.Z m512 k ymm
// 	VCVTPD2PS.Z zmm  k ymm
func VCVTPD2PS_Z(mz, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsYMM(y),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, y},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2PS_Z: bad operands")
}

// VCVTPD2QQ: Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers.
//
// Forms:
//
// 	VCVTPD2QQ m512 k zmm
// 	VCVTPD2QQ m512 zmm
// 	VCVTPD2QQ zmm  k zmm
// 	VCVTPD2QQ zmm  zmm
// 	VCVTPD2QQ m128 k xmm
// 	VCVTPD2QQ m128 xmm
// 	VCVTPD2QQ m256 k ymm
// 	VCVTPD2QQ m256 ymm
// 	VCVTPD2QQ xmm  k xmm
// 	VCVTPD2QQ xmm  xmm
// 	VCVTPD2QQ ymm  k ymm
// 	VCVTPD2QQ ymm  ymm
func VCVTPD2QQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2QQ: bad operands")
}

// VCVTPD2QQ_BCST: Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Broadcast).
//
// Forms:
//
// 	VCVTPD2QQ.BCST m64 k zmm
// 	VCVTPD2QQ.BCST m64 zmm
// 	VCVTPD2QQ.BCST m64 k xmm
// 	VCVTPD2QQ.BCST m64 k ymm
// 	VCVTPD2QQ.BCST m64 xmm
// 	VCVTPD2QQ.BCST m64 ymm
func VCVTPD2QQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2QQ_BCST: bad operands")
}

// VCVTPD2QQ_BCST_Z: Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2QQ.BCST.Z m64 k zmm
// 	VCVTPD2QQ.BCST.Z m64 k xmm
// 	VCVTPD2QQ.BCST.Z m64 k ymm
func VCVTPD2QQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2QQ_BCST_Z: bad operands")
}

// VCVTPD2QQ_RD_SAE: Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTPD2QQ.RD_SAE zmm k zmm
// 	VCVTPD2QQ.RD_SAE zmm zmm
func VCVTPD2QQ_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2QQ_RD_SAE: bad operands")
}

// VCVTPD2QQ_RD_SAE_Z: Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2QQ.RD_SAE.Z zmm k zmm
func VCVTPD2QQ_RD_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2QQ_RD_SAE_Z: bad operands")
}

// VCVTPD2QQ_RN_SAE: Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Round Towards Nearest).
//
// Forms:
//
// 	VCVTPD2QQ.RN_SAE zmm k zmm
// 	VCVTPD2QQ.RN_SAE zmm zmm
func VCVTPD2QQ_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2QQ_RN_SAE: bad operands")
}

// VCVTPD2QQ_RN_SAE_Z: Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2QQ.RN_SAE.Z zmm k zmm
func VCVTPD2QQ_RN_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2QQ_RN_SAE_Z: bad operands")
}

// VCVTPD2QQ_RU_SAE: Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTPD2QQ.RU_SAE zmm k zmm
// 	VCVTPD2QQ.RU_SAE zmm zmm
func VCVTPD2QQ_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2QQ_RU_SAE: bad operands")
}

// VCVTPD2QQ_RU_SAE_Z: Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2QQ.RU_SAE.Z zmm k zmm
func VCVTPD2QQ_RU_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2QQ_RU_SAE_Z: bad operands")
}

// VCVTPD2QQ_RZ_SAE: Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Round Towards Zero).
//
// Forms:
//
// 	VCVTPD2QQ.RZ_SAE zmm k zmm
// 	VCVTPD2QQ.RZ_SAE zmm zmm
func VCVTPD2QQ_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2QQ_RZ_SAE: bad operands")
}

// VCVTPD2QQ_RZ_SAE_Z: Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2QQ.RZ_SAE.Z zmm k zmm
func VCVTPD2QQ_RZ_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2QQ_RZ_SAE_Z: bad operands")
}

// VCVTPD2QQ_Z: Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2QQ.Z m512 k zmm
// 	VCVTPD2QQ.Z zmm  k zmm
// 	VCVTPD2QQ.Z m128 k xmm
// 	VCVTPD2QQ.Z m256 k ymm
// 	VCVTPD2QQ.Z xmm  k xmm
// 	VCVTPD2QQ.Z ymm  k ymm
func VCVTPD2QQ_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2QQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2QQ_Z: bad operands")
}

// VCVTPD2UDQ: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers.
//
// Forms:
//
// 	VCVTPD2UDQ m512 k ymm
// 	VCVTPD2UDQ m512 ymm
// 	VCVTPD2UDQ zmm  k ymm
// 	VCVTPD2UDQ zmm  ymm
func VCVTPD2UDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQ: bad operands")
}

// VCVTPD2UDQX: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers.
//
// Forms:
//
// 	VCVTPD2UDQX m128 k xmm
// 	VCVTPD2UDQX m128 xmm
// 	VCVTPD2UDQX xmm  k xmm
// 	VCVTPD2UDQX xmm  xmm
func VCVTPD2UDQX(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQX",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQX",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQX: bad operands")
}

// VCVTPD2UDQX_BCST: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VCVTPD2UDQX.BCST m64 k xmm
// 	VCVTPD2UDQX.BCST m64 xmm
func VCVTPD2UDQX_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQX_BCST: bad operands")
}

// VCVTPD2UDQX_BCST_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UDQX.BCST.Z m64 k xmm
func VCVTPD2UDQX_BCST_Z(m, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQX",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, x},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQX_BCST_Z: bad operands")
}

// VCVTPD2UDQX_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UDQX.Z m128 k xmm
// 	VCVTPD2UDQX.Z xmm  k xmm
func VCVTPD2UDQX_Z(mx, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsK(k) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQX",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, x},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQX_Z: bad operands")
}

// VCVTPD2UDQY: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers.
//
// Forms:
//
// 	VCVTPD2UDQY m256 k xmm
// 	VCVTPD2UDQY m256 xmm
// 	VCVTPD2UDQY ymm  k xmm
// 	VCVTPD2UDQY ymm  xmm
func VCVTPD2UDQY(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQY",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQY",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQY: bad operands")
}

// VCVTPD2UDQY_BCST: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VCVTPD2UDQY.BCST m64 k xmm
// 	VCVTPD2UDQY.BCST m64 xmm
func VCVTPD2UDQY_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQY_BCST: bad operands")
}

// VCVTPD2UDQY_BCST_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UDQY.BCST.Z m64 k xmm
func VCVTPD2UDQY_BCST_Z(m, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQY",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, x},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQY_BCST_Z: bad operands")
}

// VCVTPD2UDQY_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UDQY.Z m256 k xmm
// 	VCVTPD2UDQY.Z ymm  k xmm
func VCVTPD2UDQY_Z(my, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(my) && operand.IsK(k) && operand.IsXMM(x),
		operand.IsYMM(my) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQY",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{my, k, x},
			Inputs:   []operand.Op{my, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQY_Z: bad operands")
}

// VCVTPD2UDQ_BCST: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VCVTPD2UDQ.BCST m64 k ymm
// 	VCVTPD2UDQ.BCST m64 ymm
func VCVTPD2UDQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQ_BCST: bad operands")
}

// VCVTPD2UDQ_BCST_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UDQ.BCST.Z m64 k ymm
func VCVTPD2UDQ_BCST_Z(m, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, y},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQ_BCST_Z: bad operands")
}

// VCVTPD2UDQ_RD_SAE: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTPD2UDQ.RD_SAE zmm k ymm
// 	VCVTPD2UDQ.RD_SAE zmm ymm
func VCVTPD2UDQ_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQ_RD_SAE: bad operands")
}

// VCVTPD2UDQ_RD_SAE_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UDQ.RD_SAE.Z zmm k ymm
func VCVTPD2UDQ_RD_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQ_RD_SAE_Z: bad operands")
}

// VCVTPD2UDQ_RN_SAE: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Round Towards Nearest).
//
// Forms:
//
// 	VCVTPD2UDQ.RN_SAE zmm k ymm
// 	VCVTPD2UDQ.RN_SAE zmm ymm
func VCVTPD2UDQ_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQ_RN_SAE: bad operands")
}

// VCVTPD2UDQ_RN_SAE_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UDQ.RN_SAE.Z zmm k ymm
func VCVTPD2UDQ_RN_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQ_RN_SAE_Z: bad operands")
}

// VCVTPD2UDQ_RU_SAE: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTPD2UDQ.RU_SAE zmm k ymm
// 	VCVTPD2UDQ.RU_SAE zmm ymm
func VCVTPD2UDQ_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQ_RU_SAE: bad operands")
}

// VCVTPD2UDQ_RU_SAE_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UDQ.RU_SAE.Z zmm k ymm
func VCVTPD2UDQ_RU_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQ_RU_SAE_Z: bad operands")
}

// VCVTPD2UDQ_RZ_SAE: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Round Towards Zero).
//
// Forms:
//
// 	VCVTPD2UDQ.RZ_SAE zmm k ymm
// 	VCVTPD2UDQ.RZ_SAE zmm ymm
func VCVTPD2UDQ_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQ_RZ_SAE: bad operands")
}

// VCVTPD2UDQ_RZ_SAE_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UDQ.RZ_SAE.Z zmm k ymm
func VCVTPD2UDQ_RZ_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQ_RZ_SAE_Z: bad operands")
}

// VCVTPD2UDQ_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UDQ.Z m512 k ymm
// 	VCVTPD2UDQ.Z zmm  k ymm
func VCVTPD2UDQ_Z(mz, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsYMM(y),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, y},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UDQ_Z: bad operands")
}

// VCVTPD2UQQ: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers.
//
// Forms:
//
// 	VCVTPD2UQQ m512 k zmm
// 	VCVTPD2UQQ m512 zmm
// 	VCVTPD2UQQ zmm  k zmm
// 	VCVTPD2UQQ zmm  zmm
// 	VCVTPD2UQQ m128 k xmm
// 	VCVTPD2UQQ m128 xmm
// 	VCVTPD2UQQ m256 k ymm
// 	VCVTPD2UQQ m256 ymm
// 	VCVTPD2UQQ xmm  k xmm
// 	VCVTPD2UQQ xmm  xmm
// 	VCVTPD2UQQ ymm  k ymm
// 	VCVTPD2UQQ ymm  ymm
func VCVTPD2UQQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UQQ: bad operands")
}

// VCVTPD2UQQ_BCST: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Broadcast).
//
// Forms:
//
// 	VCVTPD2UQQ.BCST m64 k zmm
// 	VCVTPD2UQQ.BCST m64 zmm
// 	VCVTPD2UQQ.BCST m64 k xmm
// 	VCVTPD2UQQ.BCST m64 k ymm
// 	VCVTPD2UQQ.BCST m64 xmm
// 	VCVTPD2UQQ.BCST m64 ymm
func VCVTPD2UQQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UQQ_BCST: bad operands")
}

// VCVTPD2UQQ_BCST_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UQQ.BCST.Z m64 k zmm
// 	VCVTPD2UQQ.BCST.Z m64 k xmm
// 	VCVTPD2UQQ.BCST.Z m64 k ymm
func VCVTPD2UQQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UQQ_BCST_Z: bad operands")
}

// VCVTPD2UQQ_RD_SAE: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTPD2UQQ.RD_SAE zmm k zmm
// 	VCVTPD2UQQ.RD_SAE zmm zmm
func VCVTPD2UQQ_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UQQ_RD_SAE: bad operands")
}

// VCVTPD2UQQ_RD_SAE_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UQQ.RD_SAE.Z zmm k zmm
func VCVTPD2UQQ_RD_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UQQ_RD_SAE_Z: bad operands")
}

// VCVTPD2UQQ_RN_SAE: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Round Towards Nearest).
//
// Forms:
//
// 	VCVTPD2UQQ.RN_SAE zmm k zmm
// 	VCVTPD2UQQ.RN_SAE zmm zmm
func VCVTPD2UQQ_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UQQ_RN_SAE: bad operands")
}

// VCVTPD2UQQ_RN_SAE_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UQQ.RN_SAE.Z zmm k zmm
func VCVTPD2UQQ_RN_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UQQ_RN_SAE_Z: bad operands")
}

// VCVTPD2UQQ_RU_SAE: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTPD2UQQ.RU_SAE zmm k zmm
// 	VCVTPD2UQQ.RU_SAE zmm zmm
func VCVTPD2UQQ_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UQQ_RU_SAE: bad operands")
}

// VCVTPD2UQQ_RU_SAE_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UQQ.RU_SAE.Z zmm k zmm
func VCVTPD2UQQ_RU_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UQQ_RU_SAE_Z: bad operands")
}

// VCVTPD2UQQ_RZ_SAE: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Round Towards Zero).
//
// Forms:
//
// 	VCVTPD2UQQ.RZ_SAE zmm k zmm
// 	VCVTPD2UQQ.RZ_SAE zmm zmm
func VCVTPD2UQQ_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UQQ_RZ_SAE: bad operands")
}

// VCVTPD2UQQ_RZ_SAE_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UQQ.RZ_SAE.Z zmm k zmm
func VCVTPD2UQQ_RZ_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UQQ_RZ_SAE_Z: bad operands")
}

// VCVTPD2UQQ_Z: Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTPD2UQQ.Z m512 k zmm
// 	VCVTPD2UQQ.Z zmm  k zmm
// 	VCVTPD2UQQ.Z m128 k xmm
// 	VCVTPD2UQQ.Z m256 k ymm
// 	VCVTPD2UQQ.Z xmm  k xmm
// 	VCVTPD2UQQ.Z ymm  k ymm
func VCVTPD2UQQ_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPD2UQQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPD2UQQ_Z: bad operands")
}

// VCVTPH2PS: Convert Half-Precision FP Values to Single-Precision FP Values.
//
// Forms:
//
// 	VCVTPH2PS m128 ymm
// 	VCVTPH2PS m64  xmm
// 	VCVTPH2PS xmm  xmm
// 	VCVTPH2PS xmm  ymm
// 	VCVTPH2PS m256 k zmm
// 	VCVTPH2PS m256 zmm
// 	VCVTPH2PS ymm  k zmm
// 	VCVTPH2PS ymm  zmm
// 	VCVTPH2PS m128 k ymm
// 	VCVTPH2PS m64  k xmm
// 	VCVTPH2PS xmm  k xmm
// 	VCVTPH2PS xmm  k ymm
func VCVTPH2PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPH2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPH2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPH2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPH2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"F16C"},
		}, nil
	}
	return nil, errors.New("VCVTPH2PS: bad operands")
}

// VCVTPH2PS_SAE: Convert Half-Precision FP Values to Single-Precision FP Values (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTPH2PS.SAE ymm k zmm
// 	VCVTPH2PS.SAE ymm zmm
func VCVTPH2PS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPH2PS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPH2PS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPH2PS_SAE: bad operands")
}

// VCVTPH2PS_SAE_Z: Convert Half-Precision FP Values to Single-Precision FP Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VCVTPH2PS.SAE.Z ymm k zmm
func VCVTPH2PS_SAE_Z(y, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsYMM(y) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VCVTPH2PS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{y, k, z},
			Inputs:   []operand.Op{y, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPH2PS_SAE_Z: bad operands")
}

// VCVTPH2PS_Z: Convert Half-Precision FP Values to Single-Precision FP Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTPH2PS.Z m256 k zmm
// 	VCVTPH2PS.Z ymm  k zmm
// 	VCVTPH2PS.Z m128 k ymm
// 	VCVTPH2PS.Z m64  k xmm
// 	VCVTPH2PS.Z xmm  k xmm
// 	VCVTPH2PS.Z xmm  k ymm
func VCVTPH2PS_Z(mxy, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(mxy) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsYMM(mxy) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPH2PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxy) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsM64(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPH2PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPH2PS_Z: bad operands")
}

// VCVTPS2DQ: Convert Packed Single-Precision FP Values to Packed Dword Integers.
//
// Forms:
//
// 	VCVTPS2DQ m128 xmm
// 	VCVTPS2DQ m256 ymm
// 	VCVTPS2DQ xmm  xmm
// 	VCVTPS2DQ ymm  ymm
// 	VCVTPS2DQ m512 k zmm
// 	VCVTPS2DQ m512 zmm
// 	VCVTPS2DQ zmm  k zmm
// 	VCVTPS2DQ zmm  zmm
// 	VCVTPS2DQ m128 k xmm
// 	VCVTPS2DQ m256 k ymm
// 	VCVTPS2DQ xmm  k xmm
// 	VCVTPS2DQ ymm  k ymm
func VCVTPS2DQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2DQ: bad operands")
}

// VCVTPS2DQ_BCST: Convert Packed Single-Precision FP Values to Packed Dword Integers (Broadcast).
//
// Forms:
//
// 	VCVTPS2DQ.BCST m32 k zmm
// 	VCVTPS2DQ.BCST m32 zmm
// 	VCVTPS2DQ.BCST m32 k xmm
// 	VCVTPS2DQ.BCST m32 k ymm
// 	VCVTPS2DQ.BCST m32 xmm
// 	VCVTPS2DQ.BCST m32 ymm
func VCVTPS2DQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2DQ_BCST: bad operands")
}

// VCVTPS2DQ_BCST_Z: Convert Packed Single-Precision FP Values to Packed Dword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2DQ.BCST.Z m32 k zmm
// 	VCVTPS2DQ.BCST.Z m32 k xmm
// 	VCVTPS2DQ.BCST.Z m32 k ymm
func VCVTPS2DQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2DQ_BCST_Z: bad operands")
}

// VCVTPS2DQ_RD_SAE: Convert Packed Single-Precision FP Values to Packed Dword Integers (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTPS2DQ.RD_SAE zmm k zmm
// 	VCVTPS2DQ.RD_SAE zmm zmm
func VCVTPS2DQ_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2DQ_RD_SAE: bad operands")
}

// VCVTPS2DQ_RD_SAE_Z: Convert Packed Single-Precision FP Values to Packed Dword Integers (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2DQ.RD_SAE.Z zmm k zmm
func VCVTPS2DQ_RD_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2DQ_RD_SAE_Z: bad operands")
}

// VCVTPS2DQ_RN_SAE: Convert Packed Single-Precision FP Values to Packed Dword Integers (Round Towards Nearest).
//
// Forms:
//
// 	VCVTPS2DQ.RN_SAE zmm k zmm
// 	VCVTPS2DQ.RN_SAE zmm zmm
func VCVTPS2DQ_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2DQ_RN_SAE: bad operands")
}

// VCVTPS2DQ_RN_SAE_Z: Convert Packed Single-Precision FP Values to Packed Dword Integers (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2DQ.RN_SAE.Z zmm k zmm
func VCVTPS2DQ_RN_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2DQ_RN_SAE_Z: bad operands")
}

// VCVTPS2DQ_RU_SAE: Convert Packed Single-Precision FP Values to Packed Dword Integers (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTPS2DQ.RU_SAE zmm k zmm
// 	VCVTPS2DQ.RU_SAE zmm zmm
func VCVTPS2DQ_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2DQ_RU_SAE: bad operands")
}

// VCVTPS2DQ_RU_SAE_Z: Convert Packed Single-Precision FP Values to Packed Dword Integers (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2DQ.RU_SAE.Z zmm k zmm
func VCVTPS2DQ_RU_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2DQ_RU_SAE_Z: bad operands")
}

// VCVTPS2DQ_RZ_SAE: Convert Packed Single-Precision FP Values to Packed Dword Integers (Round Towards Zero).
//
// Forms:
//
// 	VCVTPS2DQ.RZ_SAE zmm k zmm
// 	VCVTPS2DQ.RZ_SAE zmm zmm
func VCVTPS2DQ_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2DQ_RZ_SAE: bad operands")
}

// VCVTPS2DQ_RZ_SAE_Z: Convert Packed Single-Precision FP Values to Packed Dword Integers (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2DQ.RZ_SAE.Z zmm k zmm
func VCVTPS2DQ_RZ_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2DQ_RZ_SAE_Z: bad operands")
}

// VCVTPS2DQ_Z: Convert Packed Single-Precision FP Values to Packed Dword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2DQ.Z m512 k zmm
// 	VCVTPS2DQ.Z zmm  k zmm
// 	VCVTPS2DQ.Z m128 k xmm
// 	VCVTPS2DQ.Z m256 k ymm
// 	VCVTPS2DQ.Z xmm  k xmm
// 	VCVTPS2DQ.Z ymm  k ymm
func VCVTPS2DQ_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2DQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2DQ_Z: bad operands")
}

// VCVTPS2PD: Convert Packed Single-Precision FP Values to Packed Double-Precision FP Values.
//
// Forms:
//
// 	VCVTPS2PD m128 ymm
// 	VCVTPS2PD m64  xmm
// 	VCVTPS2PD xmm  xmm
// 	VCVTPS2PD xmm  ymm
// 	VCVTPS2PD m256 k zmm
// 	VCVTPS2PD m256 zmm
// 	VCVTPS2PD ymm  k zmm
// 	VCVTPS2PD ymm  zmm
// 	VCVTPS2PD m64  k xmm
// 	VCVTPS2PD xmm  k xmm
// 	VCVTPS2PD m128 k ymm
// 	VCVTPS2PD xmm  k ymm
func VCVTPS2PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2PD: bad operands")
}

// VCVTPS2PD_BCST: Convert Packed Single-Precision FP Values to Packed Double-Precision FP Values (Broadcast).
//
// Forms:
//
// 	VCVTPS2PD.BCST m32 k zmm
// 	VCVTPS2PD.BCST m32 zmm
// 	VCVTPS2PD.BCST m32 k xmm
// 	VCVTPS2PD.BCST m32 xmm
// 	VCVTPS2PD.BCST m32 k ymm
// 	VCVTPS2PD.BCST m32 ymm
func VCVTPS2PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL"},
		}, nil
	}
	return nil, errors.New("VCVTPS2PD_BCST: bad operands")
}

// VCVTPS2PD_BCST_Z: Convert Packed Single-Precision FP Values to Packed Double-Precision FP Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2PD.BCST.Z m32 k zmm
// 	VCVTPS2PD.BCST.Z m32 k xmm
// 	VCVTPS2PD.BCST.Z m32 k ymm
func VCVTPS2PD_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL"},
		}, nil
	}
	return nil, errors.New("VCVTPS2PD_BCST_Z: bad operands")
}

// VCVTPS2PD_SAE: Convert Packed Single-Precision FP Values to Packed Double-Precision FP Values (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTPS2PD.SAE ymm k zmm
// 	VCVTPS2PD.SAE ymm zmm
func VCVTPS2PD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2PD_SAE: bad operands")
}

// VCVTPS2PD_SAE_Z: Convert Packed Single-Precision FP Values to Packed Double-Precision FP Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2PD.SAE.Z ymm k zmm
func VCVTPS2PD_SAE_Z(y, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsYMM(y) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{y, k, z},
			Inputs:   []operand.Op{y, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2PD_SAE_Z: bad operands")
}

// VCVTPS2PD_Z: Convert Packed Single-Precision FP Values to Packed Double-Precision FP Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2PD.Z m256 k zmm
// 	VCVTPS2PD.Z ymm  k zmm
// 	VCVTPS2PD.Z m64  k xmm
// 	VCVTPS2PD.Z xmm  k xmm
// 	VCVTPS2PD.Z m128 k ymm
// 	VCVTPS2PD.Z xmm  k ymm
func VCVTPS2PD_Z(mxy, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(mxy) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsYMM(mxy) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsXMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsM128(mxy) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL"},
		}, nil
	}
	return nil, errors.New("VCVTPS2PD_Z: bad operands")
}

// VCVTPS2PH: Convert Single-Precision FP value to Half-Precision FP value.
//
// Forms:
//
// 	VCVTPS2PH imm8 xmm m64
// 	VCVTPS2PH imm8 xmm xmm
// 	VCVTPS2PH imm8 ymm m128
// 	VCVTPS2PH imm8 ymm xmm
// 	VCVTPS2PH imm8 zmm k m256
// 	VCVTPS2PH imm8 zmm k ymm
// 	VCVTPS2PH imm8 zmm m256
// 	VCVTPS2PH imm8 zmm ymm
// 	VCVTPS2PH imm8 xmm k m64
// 	VCVTPS2PH imm8 xmm k xmm
// 	VCVTPS2PH imm8 ymm k m128
// 	VCVTPS2PH imm8 ymm k xmm
func VCVTPS2PH(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM256(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PH",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM64(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM128(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PH",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PH",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PH",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"F16C"},
		}, nil
	}
	return nil, errors.New("VCVTPS2PH: bad operands")
}

// VCVTPS2PH_SAE: Convert Single-Precision FP value to Half-Precision FP value (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTPS2PH.SAE imm8 zmm k ymm
// 	VCVTPS2PH.SAE imm8 zmm ymm
func VCVTPS2PH_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PH",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PH",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2PH_SAE: bad operands")
}

// VCVTPS2PH_SAE_Z: Convert Single-Precision FP value to Half-Precision FP value (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2PH.SAE.Z imm8 zmm k ymm
func VCVTPS2PH_SAE_Z(i, z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PH",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2PH_SAE_Z: bad operands")
}

// VCVTPS2PH_Z: Convert Single-Precision FP value to Half-Precision FP value (Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2PH.Z imm8 zmm k m256
// 	VCVTPS2PH.Z imm8 zmm k ymm
// 	VCVTPS2PH.Z imm8 xmm k m64
// 	VCVTPS2PH.Z imm8 xmm k xmm
// 	VCVTPS2PH.Z imm8 ymm k m128
// 	VCVTPS2PH.Z imm8 ymm k xmm
func VCVTPS2PH_Z(i, xyz, k, mxy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM256(mxy),
		operand.IsIMM8(i) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsYMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PH",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM64(mxy),
		operand.IsIMM8(i) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy),
		operand.IsIMM8(i) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM128(mxy),
		operand.IsIMM8(i) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2PH",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2PH_Z: bad operands")
}

// VCVTPS2QQ: Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values.
//
// Forms:
//
// 	VCVTPS2QQ m256 k zmm
// 	VCVTPS2QQ m256 zmm
// 	VCVTPS2QQ ymm  k zmm
// 	VCVTPS2QQ ymm  zmm
// 	VCVTPS2QQ m128 k ymm
// 	VCVTPS2QQ m128 ymm
// 	VCVTPS2QQ m64  k xmm
// 	VCVTPS2QQ m64  xmm
// 	VCVTPS2QQ xmm  k xmm
// 	VCVTPS2QQ xmm  k ymm
// 	VCVTPS2QQ xmm  xmm
// 	VCVTPS2QQ xmm  ymm
func VCVTPS2QQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2QQ: bad operands")
}

// VCVTPS2QQ_BCST: Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Broadcast).
//
// Forms:
//
// 	VCVTPS2QQ.BCST m32 k zmm
// 	VCVTPS2QQ.BCST m32 zmm
// 	VCVTPS2QQ.BCST m32 k xmm
// 	VCVTPS2QQ.BCST m32 k ymm
// 	VCVTPS2QQ.BCST m32 xmm
// 	VCVTPS2QQ.BCST m32 ymm
func VCVTPS2QQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2QQ_BCST: bad operands")
}

// VCVTPS2QQ_BCST_Z: Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2QQ.BCST.Z m32 k zmm
// 	VCVTPS2QQ.BCST.Z m32 k xmm
// 	VCVTPS2QQ.BCST.Z m32 k ymm
func VCVTPS2QQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2QQ_BCST_Z: bad operands")
}

// VCVTPS2QQ_RD_SAE: Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTPS2QQ.RD_SAE ymm k zmm
// 	VCVTPS2QQ.RD_SAE ymm zmm
func VCVTPS2QQ_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2QQ_RD_SAE: bad operands")
}

// VCVTPS2QQ_RD_SAE_Z: Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2QQ.RD_SAE.Z ymm k zmm
func VCVTPS2QQ_RD_SAE_Z(y, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsYMM(y) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{y, k, z},
			Inputs:   []operand.Op{y, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2QQ_RD_SAE_Z: bad operands")
}

// VCVTPS2QQ_RN_SAE: Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Round Towards Nearest).
//
// Forms:
//
// 	VCVTPS2QQ.RN_SAE ymm k zmm
// 	VCVTPS2QQ.RN_SAE ymm zmm
func VCVTPS2QQ_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2QQ_RN_SAE: bad operands")
}

// VCVTPS2QQ_RN_SAE_Z: Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2QQ.RN_SAE.Z ymm k zmm
func VCVTPS2QQ_RN_SAE_Z(y, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsYMM(y) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{y, k, z},
			Inputs:   []operand.Op{y, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2QQ_RN_SAE_Z: bad operands")
}

// VCVTPS2QQ_RU_SAE: Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTPS2QQ.RU_SAE ymm k zmm
// 	VCVTPS2QQ.RU_SAE ymm zmm
func VCVTPS2QQ_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2QQ_RU_SAE: bad operands")
}

// VCVTPS2QQ_RU_SAE_Z: Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2QQ.RU_SAE.Z ymm k zmm
func VCVTPS2QQ_RU_SAE_Z(y, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsYMM(y) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{y, k, z},
			Inputs:   []operand.Op{y, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2QQ_RU_SAE_Z: bad operands")
}

// VCVTPS2QQ_RZ_SAE: Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Round Towards Zero).
//
// Forms:
//
// 	VCVTPS2QQ.RZ_SAE ymm k zmm
// 	VCVTPS2QQ.RZ_SAE ymm zmm
func VCVTPS2QQ_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2QQ_RZ_SAE: bad operands")
}

// VCVTPS2QQ_RZ_SAE_Z: Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2QQ.RZ_SAE.Z ymm k zmm
func VCVTPS2QQ_RZ_SAE_Z(y, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsYMM(y) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{y, k, z},
			Inputs:   []operand.Op{y, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2QQ_RZ_SAE_Z: bad operands")
}

// VCVTPS2QQ_Z: Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2QQ.Z m256 k zmm
// 	VCVTPS2QQ.Z ymm  k zmm
// 	VCVTPS2QQ.Z m128 k ymm
// 	VCVTPS2QQ.Z m64  k xmm
// 	VCVTPS2QQ.Z xmm  k xmm
// 	VCVTPS2QQ.Z xmm  k ymm
func VCVTPS2QQ_Z(mxy, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(mxy) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsYMM(mxy) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxy) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsM64(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2QQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2QQ_Z: bad operands")
}

// VCVTPS2UDQ: Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values.
//
// Forms:
//
// 	VCVTPS2UDQ m512 k zmm
// 	VCVTPS2UDQ m512 zmm
// 	VCVTPS2UDQ zmm  k zmm
// 	VCVTPS2UDQ zmm  zmm
// 	VCVTPS2UDQ m128 k xmm
// 	VCVTPS2UDQ m128 xmm
// 	VCVTPS2UDQ m256 k ymm
// 	VCVTPS2UDQ m256 ymm
// 	VCVTPS2UDQ xmm  k xmm
// 	VCVTPS2UDQ xmm  xmm
// 	VCVTPS2UDQ ymm  k ymm
// 	VCVTPS2UDQ ymm  ymm
func VCVTPS2UDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UDQ: bad operands")
}

// VCVTPS2UDQ_BCST: Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Broadcast).
//
// Forms:
//
// 	VCVTPS2UDQ.BCST m32 k zmm
// 	VCVTPS2UDQ.BCST m32 zmm
// 	VCVTPS2UDQ.BCST m32 k xmm
// 	VCVTPS2UDQ.BCST m32 k ymm
// 	VCVTPS2UDQ.BCST m32 xmm
// 	VCVTPS2UDQ.BCST m32 ymm
func VCVTPS2UDQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UDQ_BCST: bad operands")
}

// VCVTPS2UDQ_BCST_Z: Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2UDQ.BCST.Z m32 k zmm
// 	VCVTPS2UDQ.BCST.Z m32 k xmm
// 	VCVTPS2UDQ.BCST.Z m32 k ymm
func VCVTPS2UDQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UDQ_BCST_Z: bad operands")
}

// VCVTPS2UDQ_RD_SAE: Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTPS2UDQ.RD_SAE zmm k zmm
// 	VCVTPS2UDQ.RD_SAE zmm zmm
func VCVTPS2UDQ_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UDQ_RD_SAE: bad operands")
}

// VCVTPS2UDQ_RD_SAE_Z: Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2UDQ.RD_SAE.Z zmm k zmm
func VCVTPS2UDQ_RD_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UDQ_RD_SAE_Z: bad operands")
}

// VCVTPS2UDQ_RN_SAE: Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Round Towards Nearest).
//
// Forms:
//
// 	VCVTPS2UDQ.RN_SAE zmm k zmm
// 	VCVTPS2UDQ.RN_SAE zmm zmm
func VCVTPS2UDQ_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UDQ_RN_SAE: bad operands")
}

// VCVTPS2UDQ_RN_SAE_Z: Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2UDQ.RN_SAE.Z zmm k zmm
func VCVTPS2UDQ_RN_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UDQ_RN_SAE_Z: bad operands")
}

// VCVTPS2UDQ_RU_SAE: Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTPS2UDQ.RU_SAE zmm k zmm
// 	VCVTPS2UDQ.RU_SAE zmm zmm
func VCVTPS2UDQ_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UDQ_RU_SAE: bad operands")
}

// VCVTPS2UDQ_RU_SAE_Z: Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2UDQ.RU_SAE.Z zmm k zmm
func VCVTPS2UDQ_RU_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UDQ_RU_SAE_Z: bad operands")
}

// VCVTPS2UDQ_RZ_SAE: Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Round Towards Zero).
//
// Forms:
//
// 	VCVTPS2UDQ.RZ_SAE zmm k zmm
// 	VCVTPS2UDQ.RZ_SAE zmm zmm
func VCVTPS2UDQ_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UDQ_RZ_SAE: bad operands")
}

// VCVTPS2UDQ_RZ_SAE_Z: Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2UDQ.RZ_SAE.Z zmm k zmm
func VCVTPS2UDQ_RZ_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UDQ_RZ_SAE_Z: bad operands")
}

// VCVTPS2UDQ_Z: Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2UDQ.Z m512 k zmm
// 	VCVTPS2UDQ.Z zmm  k zmm
// 	VCVTPS2UDQ.Z m128 k xmm
// 	VCVTPS2UDQ.Z m256 k ymm
// 	VCVTPS2UDQ.Z xmm  k xmm
// 	VCVTPS2UDQ.Z ymm  k ymm
func VCVTPS2UDQ_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UDQ_Z: bad operands")
}

// VCVTPS2UQQ: Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values.
//
// Forms:
//
// 	VCVTPS2UQQ m256 k zmm
// 	VCVTPS2UQQ m256 zmm
// 	VCVTPS2UQQ ymm  k zmm
// 	VCVTPS2UQQ ymm  zmm
// 	VCVTPS2UQQ m128 k ymm
// 	VCVTPS2UQQ m128 ymm
// 	VCVTPS2UQQ m64  k xmm
// 	VCVTPS2UQQ m64  xmm
// 	VCVTPS2UQQ xmm  k xmm
// 	VCVTPS2UQQ xmm  k ymm
// 	VCVTPS2UQQ xmm  xmm
// 	VCVTPS2UQQ xmm  ymm
func VCVTPS2UQQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UQQ: bad operands")
}

// VCVTPS2UQQ_BCST: Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Broadcast).
//
// Forms:
//
// 	VCVTPS2UQQ.BCST m32 k zmm
// 	VCVTPS2UQQ.BCST m32 zmm
// 	VCVTPS2UQQ.BCST m32 k xmm
// 	VCVTPS2UQQ.BCST m32 k ymm
// 	VCVTPS2UQQ.BCST m32 xmm
// 	VCVTPS2UQQ.BCST m32 ymm
func VCVTPS2UQQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UQQ_BCST: bad operands")
}

// VCVTPS2UQQ_BCST_Z: Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2UQQ.BCST.Z m32 k zmm
// 	VCVTPS2UQQ.BCST.Z m32 k xmm
// 	VCVTPS2UQQ.BCST.Z m32 k ymm
func VCVTPS2UQQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UQQ_BCST_Z: bad operands")
}

// VCVTPS2UQQ_RD_SAE: Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTPS2UQQ.RD_SAE ymm k zmm
// 	VCVTPS2UQQ.RD_SAE ymm zmm
func VCVTPS2UQQ_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UQQ_RD_SAE: bad operands")
}

// VCVTPS2UQQ_RD_SAE_Z: Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2UQQ.RD_SAE.Z ymm k zmm
func VCVTPS2UQQ_RD_SAE_Z(y, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsYMM(y) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{y, k, z},
			Inputs:   []operand.Op{y, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UQQ_RD_SAE_Z: bad operands")
}

// VCVTPS2UQQ_RN_SAE: Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Round Towards Nearest).
//
// Forms:
//
// 	VCVTPS2UQQ.RN_SAE ymm k zmm
// 	VCVTPS2UQQ.RN_SAE ymm zmm
func VCVTPS2UQQ_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UQQ_RN_SAE: bad operands")
}

// VCVTPS2UQQ_RN_SAE_Z: Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2UQQ.RN_SAE.Z ymm k zmm
func VCVTPS2UQQ_RN_SAE_Z(y, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsYMM(y) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{y, k, z},
			Inputs:   []operand.Op{y, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UQQ_RN_SAE_Z: bad operands")
}

// VCVTPS2UQQ_RU_SAE: Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTPS2UQQ.RU_SAE ymm k zmm
// 	VCVTPS2UQQ.RU_SAE ymm zmm
func VCVTPS2UQQ_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UQQ_RU_SAE: bad operands")
}

// VCVTPS2UQQ_RU_SAE_Z: Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2UQQ.RU_SAE.Z ymm k zmm
func VCVTPS2UQQ_RU_SAE_Z(y, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsYMM(y) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{y, k, z},
			Inputs:   []operand.Op{y, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UQQ_RU_SAE_Z: bad operands")
}

// VCVTPS2UQQ_RZ_SAE: Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Round Towards Zero).
//
// Forms:
//
// 	VCVTPS2UQQ.RZ_SAE ymm k zmm
// 	VCVTPS2UQQ.RZ_SAE ymm zmm
func VCVTPS2UQQ_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UQQ_RZ_SAE: bad operands")
}

// VCVTPS2UQQ_RZ_SAE_Z: Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2UQQ.RZ_SAE.Z ymm k zmm
func VCVTPS2UQQ_RZ_SAE_Z(y, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsYMM(y) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{y, k, z},
			Inputs:   []operand.Op{y, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UQQ_RZ_SAE_Z: bad operands")
}

// VCVTPS2UQQ_Z: Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTPS2UQQ.Z m256 k zmm
// 	VCVTPS2UQQ.Z ymm  k zmm
// 	VCVTPS2UQQ.Z m128 k ymm
// 	VCVTPS2UQQ.Z m64  k xmm
// 	VCVTPS2UQQ.Z xmm  k xmm
// 	VCVTPS2UQQ.Z xmm  k ymm
func VCVTPS2UQQ_Z(mxy, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(mxy) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsYMM(mxy) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxy) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsM64(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTPS2UQQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTPS2UQQ_Z: bad operands")
}

// VCVTQQ2PD: Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VCVTQQ2PD m512 k zmm
// 	VCVTQQ2PD m512 zmm
// 	VCVTQQ2PD zmm  k zmm
// 	VCVTQQ2PD zmm  zmm
// 	VCVTQQ2PD m128 k xmm
// 	VCVTQQ2PD m128 xmm
// 	VCVTQQ2PD m256 k ymm
// 	VCVTQQ2PD m256 ymm
// 	VCVTQQ2PD xmm  k xmm
// 	VCVTQQ2PD xmm  xmm
// 	VCVTQQ2PD ymm  k ymm
// 	VCVTQQ2PD ymm  ymm
func VCVTQQ2PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PD: bad operands")
}

// VCVTQQ2PD_BCST: Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VCVTQQ2PD.BCST m64 k zmm
// 	VCVTQQ2PD.BCST m64 zmm
// 	VCVTQQ2PD.BCST m64 k xmm
// 	VCVTQQ2PD.BCST m64 k ymm
// 	VCVTQQ2PD.BCST m64 xmm
// 	VCVTQQ2PD.BCST m64 ymm
func VCVTQQ2PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PD_BCST: bad operands")
}

// VCVTQQ2PD_BCST_Z: Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PD.BCST.Z m64 k zmm
// 	VCVTQQ2PD.BCST.Z m64 k xmm
// 	VCVTQQ2PD.BCST.Z m64 k ymm
func VCVTQQ2PD_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PD_BCST_Z: bad operands")
}

// VCVTQQ2PD_RD_SAE: Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTQQ2PD.RD_SAE zmm k zmm
// 	VCVTQQ2PD.RD_SAE zmm zmm
func VCVTQQ2PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PD_RD_SAE: bad operands")
}

// VCVTQQ2PD_RD_SAE_Z: Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PD.RD_SAE.Z zmm k zmm
func VCVTQQ2PD_RD_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PD_RD_SAE_Z: bad operands")
}

// VCVTQQ2PD_RN_SAE: Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VCVTQQ2PD.RN_SAE zmm k zmm
// 	VCVTQQ2PD.RN_SAE zmm zmm
func VCVTQQ2PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PD_RN_SAE: bad operands")
}

// VCVTQQ2PD_RN_SAE_Z: Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PD.RN_SAE.Z zmm k zmm
func VCVTQQ2PD_RN_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PD_RN_SAE_Z: bad operands")
}

// VCVTQQ2PD_RU_SAE: Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTQQ2PD.RU_SAE zmm k zmm
// 	VCVTQQ2PD.RU_SAE zmm zmm
func VCVTQQ2PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PD_RU_SAE: bad operands")
}

// VCVTQQ2PD_RU_SAE_Z: Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PD.RU_SAE.Z zmm k zmm
func VCVTQQ2PD_RU_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PD_RU_SAE_Z: bad operands")
}

// VCVTQQ2PD_RZ_SAE: Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VCVTQQ2PD.RZ_SAE zmm k zmm
// 	VCVTQQ2PD.RZ_SAE zmm zmm
func VCVTQQ2PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PD_RZ_SAE: bad operands")
}

// VCVTQQ2PD_RZ_SAE_Z: Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PD.RZ_SAE.Z zmm k zmm
func VCVTQQ2PD_RZ_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PD_RZ_SAE_Z: bad operands")
}

// VCVTQQ2PD_Z: Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PD.Z m512 k zmm
// 	VCVTQQ2PD.Z zmm  k zmm
// 	VCVTQQ2PD.Z m128 k xmm
// 	VCVTQQ2PD.Z m256 k ymm
// 	VCVTQQ2PD.Z xmm  k xmm
// 	VCVTQQ2PD.Z ymm  k ymm
func VCVTQQ2PD_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PD_Z: bad operands")
}

// VCVTQQ2PS: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VCVTQQ2PS m512 k ymm
// 	VCVTQQ2PS m512 ymm
// 	VCVTQQ2PS zmm  k ymm
// 	VCVTQQ2PS zmm  ymm
func VCVTQQ2PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PS: bad operands")
}

// VCVTQQ2PSX: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VCVTQQ2PSX m128 k xmm
// 	VCVTQQ2PSX m128 xmm
// 	VCVTQQ2PSX xmm  k xmm
// 	VCVTQQ2PSX xmm  xmm
func VCVTQQ2PSX(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PSX",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PSX",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PSX: bad operands")
}

// VCVTQQ2PSX_BCST: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VCVTQQ2PSX.BCST m64 k xmm
// 	VCVTQQ2PSX.BCST m64 xmm
func VCVTQQ2PSX_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PSX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PSX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PSX_BCST: bad operands")
}

// VCVTQQ2PSX_BCST_Z: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PSX.BCST.Z m64 k xmm
func VCVTQQ2PSX_BCST_Z(m, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PSX",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, x},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PSX_BCST_Z: bad operands")
}

// VCVTQQ2PSX_Z: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PSX.Z m128 k xmm
// 	VCVTQQ2PSX.Z xmm  k xmm
func VCVTQQ2PSX_Z(mx, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsK(k) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PSX",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, x},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PSX_Z: bad operands")
}

// VCVTQQ2PSY: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VCVTQQ2PSY m256 k xmm
// 	VCVTQQ2PSY m256 xmm
// 	VCVTQQ2PSY ymm  k xmm
// 	VCVTQQ2PSY ymm  xmm
func VCVTQQ2PSY(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PSY",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PSY",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PSY: bad operands")
}

// VCVTQQ2PSY_BCST: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VCVTQQ2PSY.BCST m64 k xmm
// 	VCVTQQ2PSY.BCST m64 xmm
func VCVTQQ2PSY_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PSY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PSY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PSY_BCST: bad operands")
}

// VCVTQQ2PSY_BCST_Z: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PSY.BCST.Z m64 k xmm
func VCVTQQ2PSY_BCST_Z(m, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PSY",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, x},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PSY_BCST_Z: bad operands")
}

// VCVTQQ2PSY_Z: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PSY.Z m256 k xmm
// 	VCVTQQ2PSY.Z ymm  k xmm
func VCVTQQ2PSY_Z(my, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(my) && operand.IsK(k) && operand.IsXMM(x),
		operand.IsYMM(my) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PSY",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{my, k, x},
			Inputs:   []operand.Op{my, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PSY_Z: bad operands")
}

// VCVTQQ2PS_BCST: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VCVTQQ2PS.BCST m64 k ymm
// 	VCVTQQ2PS.BCST m64 ymm
func VCVTQQ2PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PS_BCST: bad operands")
}

// VCVTQQ2PS_BCST_Z: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PS.BCST.Z m64 k ymm
func VCVTQQ2PS_BCST_Z(m, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, y},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PS_BCST_Z: bad operands")
}

// VCVTQQ2PS_RD_SAE: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTQQ2PS.RD_SAE zmm k ymm
// 	VCVTQQ2PS.RD_SAE zmm ymm
func VCVTQQ2PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PS_RD_SAE: bad operands")
}

// VCVTQQ2PS_RD_SAE_Z: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PS.RD_SAE.Z zmm k ymm
func VCVTQQ2PS_RD_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PS_RD_SAE_Z: bad operands")
}

// VCVTQQ2PS_RN_SAE: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VCVTQQ2PS.RN_SAE zmm k ymm
// 	VCVTQQ2PS.RN_SAE zmm ymm
func VCVTQQ2PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PS_RN_SAE: bad operands")
}

// VCVTQQ2PS_RN_SAE_Z: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PS.RN_SAE.Z zmm k ymm
func VCVTQQ2PS_RN_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PS_RN_SAE_Z: bad operands")
}

// VCVTQQ2PS_RU_SAE: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTQQ2PS.RU_SAE zmm k ymm
// 	VCVTQQ2PS.RU_SAE zmm ymm
func VCVTQQ2PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PS_RU_SAE: bad operands")
}

// VCVTQQ2PS_RU_SAE_Z: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PS.RU_SAE.Z zmm k ymm
func VCVTQQ2PS_RU_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PS_RU_SAE_Z: bad operands")
}

// VCVTQQ2PS_RZ_SAE: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VCVTQQ2PS.RZ_SAE zmm k ymm
// 	VCVTQQ2PS.RZ_SAE zmm ymm
func VCVTQQ2PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PS_RZ_SAE: bad operands")
}

// VCVTQQ2PS_RZ_SAE_Z: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PS.RZ_SAE.Z zmm k ymm
func VCVTQQ2PS_RZ_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PS_RZ_SAE_Z: bad operands")
}

// VCVTQQ2PS_Z: Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTQQ2PS.Z m512 k ymm
// 	VCVTQQ2PS.Z zmm  k ymm
func VCVTQQ2PS_Z(mz, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsYMM(y),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTQQ2PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, y},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTQQ2PS_Z: bad operands")
}

// VCVTSD2SI: Convert Scalar Double-Precision FP Value to Integer.
//
// Forms:
//
// 	VCVTSD2SI m64 r32
// 	VCVTSD2SI xmm r32
func VCVTSD2SI(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsR32(r),
		operand.IsXMM(mx) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SI",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SI: bad operands")
}

// VCVTSD2SIQ: Convert Scalar Double-Precision FP Value to Integer.
//
// Forms:
//
// 	VCVTSD2SIQ m64 r64
// 	VCVTSD2SIQ xmm r64
func VCVTSD2SIQ(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsR64(r),
		operand.IsXMM(mx) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SIQ",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SIQ: bad operands")
}

// VCVTSD2SIQ_RD_SAE: Convert Scalar Double-Precision FP Value to Integer (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTSD2SIQ.RD_SAE xmm r64
func VCVTSD2SIQ_RD_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SIQ",
			Suffixes: []string{"RD_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SIQ_RD_SAE: bad operands")
}

// VCVTSD2SIQ_RN_SAE: Convert Scalar Double-Precision FP Value to Integer (Round Towards Nearest).
//
// Forms:
//
// 	VCVTSD2SIQ.RN_SAE xmm r64
func VCVTSD2SIQ_RN_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SIQ",
			Suffixes: []string{"RN_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SIQ_RN_SAE: bad operands")
}

// VCVTSD2SIQ_RU_SAE: Convert Scalar Double-Precision FP Value to Integer (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTSD2SIQ.RU_SAE xmm r64
func VCVTSD2SIQ_RU_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SIQ",
			Suffixes: []string{"RU_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SIQ_RU_SAE: bad operands")
}

// VCVTSD2SIQ_RZ_SAE: Convert Scalar Double-Precision FP Value to Integer (Round Towards Zero).
//
// Forms:
//
// 	VCVTSD2SIQ.RZ_SAE xmm r64
func VCVTSD2SIQ_RZ_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SIQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SIQ_RZ_SAE: bad operands")
}

// VCVTSD2SI_RD_SAE: Convert Scalar Double-Precision FP Value to Integer (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTSD2SI.RD_SAE xmm r32
func VCVTSD2SI_RD_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SI",
			Suffixes: []string{"RD_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SI_RD_SAE: bad operands")
}

// VCVTSD2SI_RN_SAE: Convert Scalar Double-Precision FP Value to Integer (Round Towards Nearest).
//
// Forms:
//
// 	VCVTSD2SI.RN_SAE xmm r32
func VCVTSD2SI_RN_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SI",
			Suffixes: []string{"RN_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SI_RN_SAE: bad operands")
}

// VCVTSD2SI_RU_SAE: Convert Scalar Double-Precision FP Value to Integer (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTSD2SI.RU_SAE xmm r32
func VCVTSD2SI_RU_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SI",
			Suffixes: []string{"RU_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SI_RU_SAE: bad operands")
}

// VCVTSD2SI_RZ_SAE: Convert Scalar Double-Precision FP Value to Integer (Round Towards Zero).
//
// Forms:
//
// 	VCVTSD2SI.RZ_SAE xmm r32
func VCVTSD2SI_RZ_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SI",
			Suffixes: []string{"RZ_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SI_RZ_SAE: bad operands")
}

// VCVTSD2SS: Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value.
//
// Forms:
//
// 	VCVTSD2SS m64 xmm xmm
// 	VCVTSD2SS xmm xmm xmm
// 	VCVTSD2SS m64 xmm k xmm
// 	VCVTSD2SS xmm xmm k xmm
func VCVTSD2SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SS: bad operands")
}

// VCVTSD2SS_RD_SAE: Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTSD2SS.RD_SAE xmm xmm k xmm
// 	VCVTSD2SS.RD_SAE xmm xmm xmm
func VCVTSD2SS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SS_RD_SAE: bad operands")
}

// VCVTSD2SS_RD_SAE_Z: Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTSD2SS.RD_SAE.Z xmm xmm k xmm
func VCVTSD2SS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SS_RD_SAE_Z: bad operands")
}

// VCVTSD2SS_RN_SAE: Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value (Round Towards Nearest).
//
// Forms:
//
// 	VCVTSD2SS.RN_SAE xmm xmm k xmm
// 	VCVTSD2SS.RN_SAE xmm xmm xmm
func VCVTSD2SS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SS_RN_SAE: bad operands")
}

// VCVTSD2SS_RN_SAE_Z: Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTSD2SS.RN_SAE.Z xmm xmm k xmm
func VCVTSD2SS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SS_RN_SAE_Z: bad operands")
}

// VCVTSD2SS_RU_SAE: Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTSD2SS.RU_SAE xmm xmm k xmm
// 	VCVTSD2SS.RU_SAE xmm xmm xmm
func VCVTSD2SS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SS_RU_SAE: bad operands")
}

// VCVTSD2SS_RU_SAE_Z: Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTSD2SS.RU_SAE.Z xmm xmm k xmm
func VCVTSD2SS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SS_RU_SAE_Z: bad operands")
}

// VCVTSD2SS_RZ_SAE: Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value (Round Towards Zero).
//
// Forms:
//
// 	VCVTSD2SS.RZ_SAE xmm xmm k xmm
// 	VCVTSD2SS.RZ_SAE xmm xmm xmm
func VCVTSD2SS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SS_RZ_SAE: bad operands")
}

// VCVTSD2SS_RZ_SAE_Z: Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTSD2SS.RZ_SAE.Z xmm xmm k xmm
func VCVTSD2SS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SS_RZ_SAE_Z: bad operands")
}

// VCVTSD2SS_Z: Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value (Zeroing Masking).
//
// Forms:
//
// 	VCVTSD2SS.Z m64 xmm k xmm
// 	VCVTSD2SS.Z xmm xmm k xmm
func VCVTSD2SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2SS_Z: bad operands")
}

// VCVTSD2USIL: Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer.
//
// Forms:
//
// 	VCVTSD2USIL m64 r32
// 	VCVTSD2USIL xmm r32
func VCVTSD2USIL(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsR32(r),
		operand.IsXMM(mx) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2USIL",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2USIL: bad operands")
}

// VCVTSD2USIL_RD_SAE: Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTSD2USIL.RD_SAE xmm r32
func VCVTSD2USIL_RD_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2USIL",
			Suffixes: []string{"RD_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2USIL_RD_SAE: bad operands")
}

// VCVTSD2USIL_RN_SAE: Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Nearest).
//
// Forms:
//
// 	VCVTSD2USIL.RN_SAE xmm r32
func VCVTSD2USIL_RN_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2USIL",
			Suffixes: []string{"RN_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2USIL_RN_SAE: bad operands")
}

// VCVTSD2USIL_RU_SAE: Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTSD2USIL.RU_SAE xmm r32
func VCVTSD2USIL_RU_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2USIL",
			Suffixes: []string{"RU_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2USIL_RU_SAE: bad operands")
}

// VCVTSD2USIL_RZ_SAE: Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Zero).
//
// Forms:
//
// 	VCVTSD2USIL.RZ_SAE xmm r32
func VCVTSD2USIL_RZ_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2USIL",
			Suffixes: []string{"RZ_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2USIL_RZ_SAE: bad operands")
}

// VCVTSD2USIQ: Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer.
//
// Forms:
//
// 	VCVTSD2USIQ m64 r64
// 	VCVTSD2USIQ xmm r64
func VCVTSD2USIQ(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsR64(r),
		operand.IsXMM(mx) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2USIQ",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2USIQ: bad operands")
}

// VCVTSD2USIQ_RD_SAE: Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTSD2USIQ.RD_SAE xmm r64
func VCVTSD2USIQ_RD_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2USIQ",
			Suffixes: []string{"RD_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2USIQ_RD_SAE: bad operands")
}

// VCVTSD2USIQ_RN_SAE: Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Nearest).
//
// Forms:
//
// 	VCVTSD2USIQ.RN_SAE xmm r64
func VCVTSD2USIQ_RN_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2USIQ",
			Suffixes: []string{"RN_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2USIQ_RN_SAE: bad operands")
}

// VCVTSD2USIQ_RU_SAE: Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTSD2USIQ.RU_SAE xmm r64
func VCVTSD2USIQ_RU_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2USIQ",
			Suffixes: []string{"RU_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2USIQ_RU_SAE: bad operands")
}

// VCVTSD2USIQ_RZ_SAE: Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Zero).
//
// Forms:
//
// 	VCVTSD2USIQ.RZ_SAE xmm r64
func VCVTSD2USIQ_RZ_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSD2USIQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSD2USIQ_RZ_SAE: bad operands")
}

// VCVTSI2SDL: Convert Dword Integer to Scalar Double-Precision FP Value.
//
// Forms:
//
// 	VCVTSI2SDL m32 xmm xmm
// 	VCVTSI2SDL r32 xmm xmm
func VCVTSI2SDL(mr, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsR32(mr) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SDL",
			Operands: []operand.Op{mr, x, x1},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SDL: bad operands")
}

// VCVTSI2SDQ: Convert Dword Integer to Scalar Double-Precision FP Value.
//
// Forms:
//
// 	VCVTSI2SDQ m64 xmm xmm
// 	VCVTSI2SDQ r64 xmm xmm
func VCVTSI2SDQ(mr, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsR64(mr) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SDQ",
			Operands: []operand.Op{mr, x, x1},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SDQ: bad operands")
}

// VCVTSI2SDQ_RD_SAE: Convert Dword Integer to Scalar Double-Precision FP Value (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTSI2SDQ.RD_SAE r64 xmm xmm
func VCVTSI2SDQ_RD_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SDQ",
			Suffixes: []string{"RD_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SDQ_RD_SAE: bad operands")
}

// VCVTSI2SDQ_RN_SAE: Convert Dword Integer to Scalar Double-Precision FP Value (Round Towards Nearest).
//
// Forms:
//
// 	VCVTSI2SDQ.RN_SAE r64 xmm xmm
func VCVTSI2SDQ_RN_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SDQ",
			Suffixes: []string{"RN_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SDQ_RN_SAE: bad operands")
}

// VCVTSI2SDQ_RU_SAE: Convert Dword Integer to Scalar Double-Precision FP Value (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTSI2SDQ.RU_SAE r64 xmm xmm
func VCVTSI2SDQ_RU_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SDQ",
			Suffixes: []string{"RU_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SDQ_RU_SAE: bad operands")
}

// VCVTSI2SDQ_RZ_SAE: Convert Dword Integer to Scalar Double-Precision FP Value (Round Towards Zero).
//
// Forms:
//
// 	VCVTSI2SDQ.RZ_SAE r64 xmm xmm
func VCVTSI2SDQ_RZ_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SDQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SDQ_RZ_SAE: bad operands")
}

// VCVTSI2SSL: Convert Dword Integer to Scalar Single-Precision FP Value.
//
// Forms:
//
// 	VCVTSI2SSL m32 xmm xmm
// 	VCVTSI2SSL r32 xmm xmm
func VCVTSI2SSL(mr, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsR32(mr) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SSL",
			Operands: []operand.Op{mr, x, x1},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SSL: bad operands")
}

// VCVTSI2SSL_RD_SAE: Convert Dword Integer to Scalar Single-Precision FP Value (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTSI2SSL.RD_SAE r32 xmm xmm
func VCVTSI2SSL_RD_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SSL",
			Suffixes: []string{"RD_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SSL_RD_SAE: bad operands")
}

// VCVTSI2SSL_RN_SAE: Convert Dword Integer to Scalar Single-Precision FP Value (Round Towards Nearest).
//
// Forms:
//
// 	VCVTSI2SSL.RN_SAE r32 xmm xmm
func VCVTSI2SSL_RN_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SSL",
			Suffixes: []string{"RN_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SSL_RN_SAE: bad operands")
}

// VCVTSI2SSL_RU_SAE: Convert Dword Integer to Scalar Single-Precision FP Value (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTSI2SSL.RU_SAE r32 xmm xmm
func VCVTSI2SSL_RU_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SSL",
			Suffixes: []string{"RU_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SSL_RU_SAE: bad operands")
}

// VCVTSI2SSL_RZ_SAE: Convert Dword Integer to Scalar Single-Precision FP Value (Round Towards Zero).
//
// Forms:
//
// 	VCVTSI2SSL.RZ_SAE r32 xmm xmm
func VCVTSI2SSL_RZ_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SSL",
			Suffixes: []string{"RZ_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SSL_RZ_SAE: bad operands")
}

// VCVTSI2SSQ: Convert Dword Integer to Scalar Single-Precision FP Value.
//
// Forms:
//
// 	VCVTSI2SSQ m64 xmm xmm
// 	VCVTSI2SSQ r64 xmm xmm
func VCVTSI2SSQ(mr, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsR64(mr) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SSQ",
			Operands: []operand.Op{mr, x, x1},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SSQ: bad operands")
}

// VCVTSI2SSQ_RD_SAE: Convert Dword Integer to Scalar Single-Precision FP Value (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTSI2SSQ.RD_SAE r64 xmm xmm
func VCVTSI2SSQ_RD_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SSQ",
			Suffixes: []string{"RD_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SSQ_RD_SAE: bad operands")
}

// VCVTSI2SSQ_RN_SAE: Convert Dword Integer to Scalar Single-Precision FP Value (Round Towards Nearest).
//
// Forms:
//
// 	VCVTSI2SSQ.RN_SAE r64 xmm xmm
func VCVTSI2SSQ_RN_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SSQ",
			Suffixes: []string{"RN_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SSQ_RN_SAE: bad operands")
}

// VCVTSI2SSQ_RU_SAE: Convert Dword Integer to Scalar Single-Precision FP Value (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTSI2SSQ.RU_SAE r64 xmm xmm
func VCVTSI2SSQ_RU_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SSQ",
			Suffixes: []string{"RU_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SSQ_RU_SAE: bad operands")
}

// VCVTSI2SSQ_RZ_SAE: Convert Dword Integer to Scalar Single-Precision FP Value (Round Towards Zero).
//
// Forms:
//
// 	VCVTSI2SSQ.RZ_SAE r64 xmm xmm
func VCVTSI2SSQ_RZ_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSI2SSQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSI2SSQ_RZ_SAE: bad operands")
}

// VCVTSS2SD: Convert Scalar Single-Precision FP Value to Scalar Double-Precision FP Value.
//
// Forms:
//
// 	VCVTSS2SD m32 xmm xmm
// 	VCVTSS2SD xmm xmm xmm
// 	VCVTSS2SD m32 xmm k xmm
// 	VCVTSS2SD xmm xmm k xmm
func VCVTSS2SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTSS2SD: bad operands")
}

// VCVTSS2SD_SAE: Convert Scalar Single-Precision FP Value to Scalar Double-Precision FP Value (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTSS2SD.SAE xmm xmm k xmm
// 	VCVTSS2SD.SAE xmm xmm xmm
func VCVTSS2SD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2SD_SAE: bad operands")
}

// VCVTSS2SD_SAE_Z: Convert Scalar Single-Precision FP Value to Scalar Double-Precision FP Value (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VCVTSS2SD.SAE.Z xmm xmm k xmm
func VCVTSS2SD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2SD_SAE_Z: bad operands")
}

// VCVTSS2SD_Z: Convert Scalar Single-Precision FP Value to Scalar Double-Precision FP Value (Zeroing Masking).
//
// Forms:
//
// 	VCVTSS2SD.Z m32 xmm k xmm
// 	VCVTSS2SD.Z xmm xmm k xmm
func VCVTSS2SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2SD_Z: bad operands")
}

// VCVTSS2SI: Convert Scalar Single-Precision FP Value to Dword Integer.
//
// Forms:
//
// 	VCVTSS2SI m32 r32
// 	VCVTSS2SI xmm r32
func VCVTSS2SI(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsR32(r),
		operand.IsXMM(mx) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SI",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTSS2SI: bad operands")
}

// VCVTSS2SIQ: Convert Scalar Single-Precision FP Value to Dword Integer.
//
// Forms:
//
// 	VCVTSS2SIQ m32 r64
// 	VCVTSS2SIQ xmm r64
func VCVTSS2SIQ(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsR64(r),
		operand.IsXMM(mx) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SIQ",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTSS2SIQ: bad operands")
}

// VCVTSS2SIQ_RD_SAE: Convert Scalar Single-Precision FP Value to Dword Integer (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTSS2SIQ.RD_SAE xmm r64
func VCVTSS2SIQ_RD_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SIQ",
			Suffixes: []string{"RD_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2SIQ_RD_SAE: bad operands")
}

// VCVTSS2SIQ_RN_SAE: Convert Scalar Single-Precision FP Value to Dword Integer (Round Towards Nearest).
//
// Forms:
//
// 	VCVTSS2SIQ.RN_SAE xmm r64
func VCVTSS2SIQ_RN_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SIQ",
			Suffixes: []string{"RN_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2SIQ_RN_SAE: bad operands")
}

// VCVTSS2SIQ_RU_SAE: Convert Scalar Single-Precision FP Value to Dword Integer (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTSS2SIQ.RU_SAE xmm r64
func VCVTSS2SIQ_RU_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SIQ",
			Suffixes: []string{"RU_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2SIQ_RU_SAE: bad operands")
}

// VCVTSS2SIQ_RZ_SAE: Convert Scalar Single-Precision FP Value to Dword Integer (Round Towards Zero).
//
// Forms:
//
// 	VCVTSS2SIQ.RZ_SAE xmm r64
func VCVTSS2SIQ_RZ_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SIQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2SIQ_RZ_SAE: bad operands")
}

// VCVTSS2SI_RD_SAE: Convert Scalar Single-Precision FP Value to Dword Integer (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTSS2SI.RD_SAE xmm r32
func VCVTSS2SI_RD_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SI",
			Suffixes: []string{"RD_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2SI_RD_SAE: bad operands")
}

// VCVTSS2SI_RN_SAE: Convert Scalar Single-Precision FP Value to Dword Integer (Round Towards Nearest).
//
// Forms:
//
// 	VCVTSS2SI.RN_SAE xmm r32
func VCVTSS2SI_RN_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SI",
			Suffixes: []string{"RN_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2SI_RN_SAE: bad operands")
}

// VCVTSS2SI_RU_SAE: Convert Scalar Single-Precision FP Value to Dword Integer (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTSS2SI.RU_SAE xmm r32
func VCVTSS2SI_RU_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SI",
			Suffixes: []string{"RU_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2SI_RU_SAE: bad operands")
}

// VCVTSS2SI_RZ_SAE: Convert Scalar Single-Precision FP Value to Dword Integer (Round Towards Zero).
//
// Forms:
//
// 	VCVTSS2SI.RZ_SAE xmm r32
func VCVTSS2SI_RZ_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2SI",
			Suffixes: []string{"RZ_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2SI_RZ_SAE: bad operands")
}

// VCVTSS2USIL: Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer.
//
// Forms:
//
// 	VCVTSS2USIL m32 r32
// 	VCVTSS2USIL xmm r32
func VCVTSS2USIL(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsR32(r),
		operand.IsXMM(mx) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2USIL",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2USIL: bad operands")
}

// VCVTSS2USIL_RD_SAE: Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTSS2USIL.RD_SAE xmm r32
func VCVTSS2USIL_RD_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2USIL",
			Suffixes: []string{"RD_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2USIL_RD_SAE: bad operands")
}

// VCVTSS2USIL_RN_SAE: Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Nearest).
//
// Forms:
//
// 	VCVTSS2USIL.RN_SAE xmm r32
func VCVTSS2USIL_RN_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2USIL",
			Suffixes: []string{"RN_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2USIL_RN_SAE: bad operands")
}

// VCVTSS2USIL_RU_SAE: Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTSS2USIL.RU_SAE xmm r32
func VCVTSS2USIL_RU_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2USIL",
			Suffixes: []string{"RU_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2USIL_RU_SAE: bad operands")
}

// VCVTSS2USIL_RZ_SAE: Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Zero).
//
// Forms:
//
// 	VCVTSS2USIL.RZ_SAE xmm r32
func VCVTSS2USIL_RZ_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2USIL",
			Suffixes: []string{"RZ_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2USIL_RZ_SAE: bad operands")
}

// VCVTSS2USIQ: Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer.
//
// Forms:
//
// 	VCVTSS2USIQ m32 r64
// 	VCVTSS2USIQ xmm r64
func VCVTSS2USIQ(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsR64(r),
		operand.IsXMM(mx) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2USIQ",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2USIQ: bad operands")
}

// VCVTSS2USIQ_RD_SAE: Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTSS2USIQ.RD_SAE xmm r64
func VCVTSS2USIQ_RD_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2USIQ",
			Suffixes: []string{"RD_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2USIQ_RD_SAE: bad operands")
}

// VCVTSS2USIQ_RN_SAE: Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Nearest).
//
// Forms:
//
// 	VCVTSS2USIQ.RN_SAE xmm r64
func VCVTSS2USIQ_RN_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2USIQ",
			Suffixes: []string{"RN_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2USIQ_RN_SAE: bad operands")
}

// VCVTSS2USIQ_RU_SAE: Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTSS2USIQ.RU_SAE xmm r64
func VCVTSS2USIQ_RU_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2USIQ",
			Suffixes: []string{"RU_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2USIQ_RU_SAE: bad operands")
}

// VCVTSS2USIQ_RZ_SAE: Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer (Round Towards Zero).
//
// Forms:
//
// 	VCVTSS2USIQ.RZ_SAE xmm r64
func VCVTSS2USIQ_RZ_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTSS2USIQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTSS2USIQ_RZ_SAE: bad operands")
}

// VCVTTPD2DQ: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers.
//
// Forms:
//
// 	VCVTTPD2DQ m512 k ymm
// 	VCVTTPD2DQ m512 ymm
// 	VCVTTPD2DQ zmm  k ymm
// 	VCVTTPD2DQ zmm  ymm
func VCVTTPD2DQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2DQ: bad operands")
}

// VCVTTPD2DQX: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers.
//
// Forms:
//
// 	VCVTTPD2DQX m128 xmm
// 	VCVTTPD2DQX xmm  xmm
// 	VCVTTPD2DQX m128 k xmm
// 	VCVTTPD2DQX xmm  k xmm
func VCVTTPD2DQX(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQX",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQX",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2DQX: bad operands")
}

// VCVTTPD2DQX_BCST: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers (Broadcast).
//
// Forms:
//
// 	VCVTTPD2DQX.BCST m64 k xmm
// 	VCVTTPD2DQX.BCST m64 xmm
func VCVTTPD2DQX_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2DQX_BCST: bad operands")
}

// VCVTTPD2DQX_BCST_Z: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2DQX.BCST.Z m64 k xmm
func VCVTTPD2DQX_BCST_Z(m, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQX",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, x},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2DQX_BCST_Z: bad operands")
}

// VCVTTPD2DQX_Z: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2DQX.Z m128 k xmm
// 	VCVTTPD2DQX.Z xmm  k xmm
func VCVTTPD2DQX_Z(mx, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsK(k) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQX",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, x},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2DQX_Z: bad operands")
}

// VCVTTPD2DQY: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers.
//
// Forms:
//
// 	VCVTTPD2DQY m256 xmm
// 	VCVTTPD2DQY ymm  xmm
// 	VCVTTPD2DQY m256 k xmm
// 	VCVTTPD2DQY ymm  k xmm
func VCVTTPD2DQY(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQY",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQY",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2DQY: bad operands")
}

// VCVTTPD2DQY_BCST: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers (Broadcast).
//
// Forms:
//
// 	VCVTTPD2DQY.BCST m64 k xmm
// 	VCVTTPD2DQY.BCST m64 xmm
func VCVTTPD2DQY_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2DQY_BCST: bad operands")
}

// VCVTTPD2DQY_BCST_Z: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2DQY.BCST.Z m64 k xmm
func VCVTTPD2DQY_BCST_Z(m, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQY",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, x},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2DQY_BCST_Z: bad operands")
}

// VCVTTPD2DQY_Z: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2DQY.Z m256 k xmm
// 	VCVTTPD2DQY.Z ymm  k xmm
func VCVTTPD2DQY_Z(my, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(my) && operand.IsK(k) && operand.IsXMM(x),
		operand.IsYMM(my) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQY",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{my, k, x},
			Inputs:   []operand.Op{my, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2DQY_Z: bad operands")
}

// VCVTTPD2DQ_BCST: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers (Broadcast).
//
// Forms:
//
// 	VCVTTPD2DQ.BCST m64 k ymm
// 	VCVTTPD2DQ.BCST m64 ymm
func VCVTTPD2DQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2DQ_BCST: bad operands")
}

// VCVTTPD2DQ_BCST_Z: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2DQ.BCST.Z m64 k ymm
func VCVTTPD2DQ_BCST_Z(m, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, y},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2DQ_BCST_Z: bad operands")
}

// VCVTTPD2DQ_SAE: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTPD2DQ.SAE zmm k ymm
// 	VCVTTPD2DQ.SAE zmm ymm
func VCVTTPD2DQ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2DQ_SAE: bad operands")
}

// VCVTTPD2DQ_SAE_Z: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2DQ.SAE.Z zmm k ymm
func VCVTTPD2DQ_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQ",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2DQ_SAE_Z: bad operands")
}

// VCVTTPD2DQ_Z: Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2DQ.Z m512 k ymm
// 	VCVTTPD2DQ.Z zmm  k ymm
func VCVTTPD2DQ_Z(mz, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsYMM(y),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2DQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, y},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2DQ_Z: bad operands")
}

// VCVTTPD2QQ: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Quadword Integers.
//
// Forms:
//
// 	VCVTTPD2QQ m512 k zmm
// 	VCVTTPD2QQ m512 zmm
// 	VCVTTPD2QQ zmm  k zmm
// 	VCVTTPD2QQ zmm  zmm
// 	VCVTTPD2QQ m128 k xmm
// 	VCVTTPD2QQ m128 xmm
// 	VCVTTPD2QQ m256 k ymm
// 	VCVTTPD2QQ m256 ymm
// 	VCVTTPD2QQ xmm  k xmm
// 	VCVTTPD2QQ xmm  xmm
// 	VCVTTPD2QQ ymm  k ymm
// 	VCVTTPD2QQ ymm  ymm
func VCVTTPD2QQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2QQ: bad operands")
}

// VCVTTPD2QQ_BCST: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Broadcast).
//
// Forms:
//
// 	VCVTTPD2QQ.BCST m64 k zmm
// 	VCVTTPD2QQ.BCST m64 zmm
// 	VCVTTPD2QQ.BCST m64 k xmm
// 	VCVTTPD2QQ.BCST m64 k ymm
// 	VCVTTPD2QQ.BCST m64 xmm
// 	VCVTTPD2QQ.BCST m64 ymm
func VCVTTPD2QQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2QQ_BCST: bad operands")
}

// VCVTTPD2QQ_BCST_Z: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2QQ.BCST.Z m64 k zmm
// 	VCVTTPD2QQ.BCST.Z m64 k xmm
// 	VCVTTPD2QQ.BCST.Z m64 k ymm
func VCVTTPD2QQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2QQ_BCST_Z: bad operands")
}

// VCVTTPD2QQ_SAE: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTPD2QQ.SAE zmm k zmm
// 	VCVTTPD2QQ.SAE zmm zmm
func VCVTTPD2QQ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2QQ_SAE: bad operands")
}

// VCVTTPD2QQ_SAE_Z: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2QQ.SAE.Z zmm k zmm
func VCVTTPD2QQ_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2QQ_SAE_Z: bad operands")
}

// VCVTTPD2QQ_Z: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2QQ.Z m512 k zmm
// 	VCVTTPD2QQ.Z zmm  k zmm
// 	VCVTTPD2QQ.Z m128 k xmm
// 	VCVTTPD2QQ.Z m256 k ymm
// 	VCVTTPD2QQ.Z xmm  k xmm
// 	VCVTTPD2QQ.Z ymm  k ymm
func VCVTTPD2QQ_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2QQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2QQ_Z: bad operands")
}

// VCVTTPD2UDQ: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers.
//
// Forms:
//
// 	VCVTTPD2UDQ m512 k ymm
// 	VCVTTPD2UDQ m512 ymm
// 	VCVTTPD2UDQ zmm  k ymm
// 	VCVTTPD2UDQ zmm  ymm
func VCVTTPD2UDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UDQ: bad operands")
}

// VCVTTPD2UDQX: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers.
//
// Forms:
//
// 	VCVTTPD2UDQX m128 k xmm
// 	VCVTTPD2UDQX m128 xmm
// 	VCVTTPD2UDQX xmm  k xmm
// 	VCVTTPD2UDQX xmm  xmm
func VCVTTPD2UDQX(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQX",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQX",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UDQX: bad operands")
}

// VCVTTPD2UDQX_BCST: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VCVTTPD2UDQX.BCST m64 k xmm
// 	VCVTTPD2UDQX.BCST m64 xmm
func VCVTTPD2UDQX_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UDQX_BCST: bad operands")
}

// VCVTTPD2UDQX_BCST_Z: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2UDQX.BCST.Z m64 k xmm
func VCVTTPD2UDQX_BCST_Z(m, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQX",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, x},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UDQX_BCST_Z: bad operands")
}

// VCVTTPD2UDQX_Z: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2UDQX.Z m128 k xmm
// 	VCVTTPD2UDQX.Z xmm  k xmm
func VCVTTPD2UDQX_Z(mx, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsK(k) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQX",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, x},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UDQX_Z: bad operands")
}

// VCVTTPD2UDQY: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers.
//
// Forms:
//
// 	VCVTTPD2UDQY m256 k xmm
// 	VCVTTPD2UDQY m256 xmm
// 	VCVTTPD2UDQY ymm  k xmm
// 	VCVTTPD2UDQY ymm  xmm
func VCVTTPD2UDQY(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQY",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQY",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UDQY: bad operands")
}

// VCVTTPD2UDQY_BCST: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VCVTTPD2UDQY.BCST m64 k xmm
// 	VCVTTPD2UDQY.BCST m64 xmm
func VCVTTPD2UDQY_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UDQY_BCST: bad operands")
}

// VCVTTPD2UDQY_BCST_Z: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2UDQY.BCST.Z m64 k xmm
func VCVTTPD2UDQY_BCST_Z(m, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQY",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, x},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UDQY_BCST_Z: bad operands")
}

// VCVTTPD2UDQY_Z: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2UDQY.Z m256 k xmm
// 	VCVTTPD2UDQY.Z ymm  k xmm
func VCVTTPD2UDQY_Z(my, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(my) && operand.IsK(k) && operand.IsXMM(x),
		operand.IsYMM(my) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQY",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{my, k, x},
			Inputs:   []operand.Op{my, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UDQY_Z: bad operands")
}

// VCVTTPD2UDQ_BCST: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VCVTTPD2UDQ.BCST m64 k ymm
// 	VCVTTPD2UDQ.BCST m64 ymm
func VCVTTPD2UDQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UDQ_BCST: bad operands")
}

// VCVTTPD2UDQ_BCST_Z: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2UDQ.BCST.Z m64 k ymm
func VCVTTPD2UDQ_BCST_Z(m, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, y},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UDQ_BCST_Z: bad operands")
}

// VCVTTPD2UDQ_SAE: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTPD2UDQ.SAE zmm k ymm
// 	VCVTTPD2UDQ.SAE zmm ymm
func VCVTTPD2UDQ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UDQ_SAE: bad operands")
}

// VCVTTPD2UDQ_SAE_Z: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2UDQ.SAE.Z zmm k ymm
func VCVTTPD2UDQ_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQ",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UDQ_SAE_Z: bad operands")
}

// VCVTTPD2UDQ_Z: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2UDQ.Z m512 k ymm
// 	VCVTTPD2UDQ.Z zmm  k ymm
func VCVTTPD2UDQ_Z(mz, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsYMM(y),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, y},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UDQ_Z: bad operands")
}

// VCVTTPD2UQQ: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers.
//
// Forms:
//
// 	VCVTTPD2UQQ m512 k zmm
// 	VCVTTPD2UQQ m512 zmm
// 	VCVTTPD2UQQ zmm  k zmm
// 	VCVTTPD2UQQ zmm  zmm
// 	VCVTTPD2UQQ m128 k xmm
// 	VCVTTPD2UQQ m128 xmm
// 	VCVTTPD2UQQ m256 k ymm
// 	VCVTTPD2UQQ m256 ymm
// 	VCVTTPD2UQQ xmm  k xmm
// 	VCVTTPD2UQQ xmm  xmm
// 	VCVTTPD2UQQ ymm  k ymm
// 	VCVTTPD2UQQ ymm  ymm
func VCVTTPD2UQQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UQQ: bad operands")
}

// VCVTTPD2UQQ_BCST: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Broadcast).
//
// Forms:
//
// 	VCVTTPD2UQQ.BCST m64 k zmm
// 	VCVTTPD2UQQ.BCST m64 zmm
// 	VCVTTPD2UQQ.BCST m64 k xmm
// 	VCVTTPD2UQQ.BCST m64 k ymm
// 	VCVTTPD2UQQ.BCST m64 xmm
// 	VCVTTPD2UQQ.BCST m64 ymm
func VCVTTPD2UQQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UQQ_BCST: bad operands")
}

// VCVTTPD2UQQ_BCST_Z: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2UQQ.BCST.Z m64 k zmm
// 	VCVTTPD2UQQ.BCST.Z m64 k xmm
// 	VCVTTPD2UQQ.BCST.Z m64 k ymm
func VCVTTPD2UQQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UQQ_BCST_Z: bad operands")
}

// VCVTTPD2UQQ_SAE: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTPD2UQQ.SAE zmm k zmm
// 	VCVTTPD2UQQ.SAE zmm zmm
func VCVTTPD2UQQ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UQQ_SAE: bad operands")
}

// VCVTTPD2UQQ_SAE_Z: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2UQQ.SAE.Z zmm k zmm
func VCVTTPD2UQQ_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UQQ_SAE_Z: bad operands")
}

// VCVTTPD2UQQ_Z: Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTTPD2UQQ.Z m512 k zmm
// 	VCVTTPD2UQQ.Z zmm  k zmm
// 	VCVTTPD2UQQ.Z m128 k xmm
// 	VCVTTPD2UQQ.Z m256 k ymm
// 	VCVTTPD2UQQ.Z xmm  k xmm
// 	VCVTTPD2UQQ.Z ymm  k ymm
func VCVTTPD2UQQ_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPD2UQQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPD2UQQ_Z: bad operands")
}

// VCVTTPS2DQ: Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers.
//
// Forms:
//
// 	VCVTTPS2DQ m128 xmm
// 	VCVTTPS2DQ m256 ymm
// 	VCVTTPS2DQ xmm  xmm
// 	VCVTTPS2DQ ymm  ymm
// 	VCVTTPS2DQ m512 k zmm
// 	VCVTTPS2DQ m512 zmm
// 	VCVTTPS2DQ zmm  k zmm
// 	VCVTTPS2DQ zmm  zmm
// 	VCVTTPS2DQ m128 k xmm
// 	VCVTTPS2DQ m256 k ymm
// 	VCVTTPS2DQ xmm  k xmm
// 	VCVTTPS2DQ ymm  k ymm
func VCVTTPS2DQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2DQ: bad operands")
}

// VCVTTPS2DQ_BCST: Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers (Broadcast).
//
// Forms:
//
// 	VCVTTPS2DQ.BCST m32 k zmm
// 	VCVTTPS2DQ.BCST m32 zmm
// 	VCVTTPS2DQ.BCST m32 k xmm
// 	VCVTTPS2DQ.BCST m32 k ymm
// 	VCVTTPS2DQ.BCST m32 xmm
// 	VCVTTPS2DQ.BCST m32 ymm
func VCVTTPS2DQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2DQ_BCST: bad operands")
}

// VCVTTPS2DQ_BCST_Z: Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPS2DQ.BCST.Z m32 k zmm
// 	VCVTTPS2DQ.BCST.Z m32 k xmm
// 	VCVTTPS2DQ.BCST.Z m32 k ymm
func VCVTTPS2DQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2DQ_BCST_Z: bad operands")
}

// VCVTTPS2DQ_SAE: Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTPS2DQ.SAE zmm k zmm
// 	VCVTTPS2DQ.SAE zmm zmm
func VCVTTPS2DQ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2DQ_SAE: bad operands")
}

// VCVTTPS2DQ_SAE_Z: Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPS2DQ.SAE.Z zmm k zmm
func VCVTTPS2DQ_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2DQ_SAE_Z: bad operands")
}

// VCVTTPS2DQ_Z: Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers (Zeroing Masking).
//
// Forms:
//
// 	VCVTTPS2DQ.Z m512 k zmm
// 	VCVTTPS2DQ.Z zmm  k zmm
// 	VCVTTPS2DQ.Z m128 k xmm
// 	VCVTTPS2DQ.Z m256 k ymm
// 	VCVTTPS2DQ.Z xmm  k xmm
// 	VCVTTPS2DQ.Z ymm  k ymm
func VCVTTPS2DQ_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2DQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2DQ_Z: bad operands")
}

// VCVTTPS2QQ: Convert with Truncation Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values.
//
// Forms:
//
// 	VCVTTPS2QQ m256 k zmm
// 	VCVTTPS2QQ m256 zmm
// 	VCVTTPS2QQ ymm  k zmm
// 	VCVTTPS2QQ ymm  zmm
// 	VCVTTPS2QQ m128 k ymm
// 	VCVTTPS2QQ m128 ymm
// 	VCVTTPS2QQ m64  k xmm
// 	VCVTTPS2QQ m64  xmm
// 	VCVTTPS2QQ xmm  k xmm
// 	VCVTTPS2QQ xmm  k ymm
// 	VCVTTPS2QQ xmm  xmm
// 	VCVTTPS2QQ xmm  ymm
func VCVTTPS2QQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2QQ: bad operands")
}

// VCVTTPS2QQ_BCST: Convert with Truncation Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Broadcast).
//
// Forms:
//
// 	VCVTTPS2QQ.BCST m32 k zmm
// 	VCVTTPS2QQ.BCST m32 zmm
// 	VCVTTPS2QQ.BCST m32 k xmm
// 	VCVTTPS2QQ.BCST m32 k ymm
// 	VCVTTPS2QQ.BCST m32 xmm
// 	VCVTTPS2QQ.BCST m32 ymm
func VCVTTPS2QQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2QQ_BCST: bad operands")
}

// VCVTTPS2QQ_BCST_Z: Convert with Truncation Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPS2QQ.BCST.Z m32 k zmm
// 	VCVTTPS2QQ.BCST.Z m32 k xmm
// 	VCVTTPS2QQ.BCST.Z m32 k ymm
func VCVTTPS2QQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2QQ_BCST_Z: bad operands")
}

// VCVTTPS2QQ_SAE: Convert with Truncation Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTPS2QQ.SAE ymm k zmm
// 	VCVTTPS2QQ.SAE ymm zmm
func VCVTTPS2QQ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2QQ_SAE: bad operands")
}

// VCVTTPS2QQ_SAE_Z: Convert with Truncation Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPS2QQ.SAE.Z ymm k zmm
func VCVTTPS2QQ_SAE_Z(y, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsYMM(y) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{y, k, z},
			Inputs:   []operand.Op{y, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2QQ_SAE_Z: bad operands")
}

// VCVTTPS2QQ_Z: Convert with Truncation Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTTPS2QQ.Z m256 k zmm
// 	VCVTTPS2QQ.Z ymm  k zmm
// 	VCVTTPS2QQ.Z m128 k ymm
// 	VCVTTPS2QQ.Z m64  k xmm
// 	VCVTTPS2QQ.Z xmm  k xmm
// 	VCVTTPS2QQ.Z xmm  k ymm
func VCVTTPS2QQ_Z(mxy, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(mxy) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsYMM(mxy) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxy) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsM64(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2QQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2QQ_Z: bad operands")
}

// VCVTTPS2UDQ: Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values.
//
// Forms:
//
// 	VCVTTPS2UDQ m512 k zmm
// 	VCVTTPS2UDQ m512 zmm
// 	VCVTTPS2UDQ zmm  k zmm
// 	VCVTTPS2UDQ zmm  zmm
// 	VCVTTPS2UDQ m128 k xmm
// 	VCVTTPS2UDQ m128 xmm
// 	VCVTTPS2UDQ m256 k ymm
// 	VCVTTPS2UDQ m256 ymm
// 	VCVTTPS2UDQ xmm  k xmm
// 	VCVTTPS2UDQ xmm  xmm
// 	VCVTTPS2UDQ ymm  k ymm
// 	VCVTTPS2UDQ ymm  ymm
func VCVTTPS2UDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2UDQ: bad operands")
}

// VCVTTPS2UDQ_BCST: Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Broadcast).
//
// Forms:
//
// 	VCVTTPS2UDQ.BCST m32 k zmm
// 	VCVTTPS2UDQ.BCST m32 zmm
// 	VCVTTPS2UDQ.BCST m32 k xmm
// 	VCVTTPS2UDQ.BCST m32 k ymm
// 	VCVTTPS2UDQ.BCST m32 xmm
// 	VCVTTPS2UDQ.BCST m32 ymm
func VCVTTPS2UDQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2UDQ_BCST: bad operands")
}

// VCVTTPS2UDQ_BCST_Z: Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPS2UDQ.BCST.Z m32 k zmm
// 	VCVTTPS2UDQ.BCST.Z m32 k xmm
// 	VCVTTPS2UDQ.BCST.Z m32 k ymm
func VCVTTPS2UDQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2UDQ_BCST_Z: bad operands")
}

// VCVTTPS2UDQ_SAE: Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTPS2UDQ.SAE zmm k zmm
// 	VCVTTPS2UDQ.SAE zmm zmm
func VCVTTPS2UDQ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2UDQ_SAE: bad operands")
}

// VCVTTPS2UDQ_SAE_Z: Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPS2UDQ.SAE.Z zmm k zmm
func VCVTTPS2UDQ_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2UDQ_SAE_Z: bad operands")
}

// VCVTTPS2UDQ_Z: Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTTPS2UDQ.Z m512 k zmm
// 	VCVTTPS2UDQ.Z zmm  k zmm
// 	VCVTTPS2UDQ.Z m128 k xmm
// 	VCVTTPS2UDQ.Z m256 k ymm
// 	VCVTTPS2UDQ.Z xmm  k xmm
// 	VCVTTPS2UDQ.Z ymm  k ymm
func VCVTTPS2UDQ_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2UDQ_Z: bad operands")
}

// VCVTTPS2UQQ: Convert with Truncation Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values.
//
// Forms:
//
// 	VCVTTPS2UQQ m256 k zmm
// 	VCVTTPS2UQQ m256 zmm
// 	VCVTTPS2UQQ ymm  k zmm
// 	VCVTTPS2UQQ ymm  zmm
// 	VCVTTPS2UQQ m128 k ymm
// 	VCVTTPS2UQQ m128 ymm
// 	VCVTTPS2UQQ m64  k xmm
// 	VCVTTPS2UQQ m64  xmm
// 	VCVTTPS2UQQ xmm  k xmm
// 	VCVTTPS2UQQ xmm  k ymm
// 	VCVTTPS2UQQ xmm  xmm
// 	VCVTTPS2UQQ xmm  ymm
func VCVTTPS2UQQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2UQQ: bad operands")
}

// VCVTTPS2UQQ_BCST: Convert with Truncation Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Broadcast).
//
// Forms:
//
// 	VCVTTPS2UQQ.BCST m32 k zmm
// 	VCVTTPS2UQQ.BCST m32 zmm
// 	VCVTTPS2UQQ.BCST m32 k xmm
// 	VCVTTPS2UQQ.BCST m32 k ymm
// 	VCVTTPS2UQQ.BCST m32 xmm
// 	VCVTTPS2UQQ.BCST m32 ymm
func VCVTTPS2UQQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2UQQ_BCST: bad operands")
}

// VCVTTPS2UQQ_BCST_Z: Convert with Truncation Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPS2UQQ.BCST.Z m32 k zmm
// 	VCVTTPS2UQQ.BCST.Z m32 k xmm
// 	VCVTTPS2UQQ.BCST.Z m32 k ymm
func VCVTTPS2UQQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2UQQ_BCST_Z: bad operands")
}

// VCVTTPS2UQQ_SAE: Convert with Truncation Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTPS2UQQ.SAE ymm k zmm
// 	VCVTTPS2UQQ.SAE ymm zmm
func VCVTTPS2UQQ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2UQQ_SAE: bad operands")
}

// VCVTTPS2UQQ_SAE_Z: Convert with Truncation Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VCVTTPS2UQQ.SAE.Z ymm k zmm
func VCVTTPS2UQQ_SAE_Z(y, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsYMM(y) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{y, k, z},
			Inputs:   []operand.Op{y, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2UQQ_SAE_Z: bad operands")
}

// VCVTTPS2UQQ_Z: Convert with Truncation Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTTPS2UQQ.Z m256 k zmm
// 	VCVTTPS2UQQ.Z ymm  k zmm
// 	VCVTTPS2UQQ.Z m128 k ymm
// 	VCVTTPS2UQQ.Z m64  k xmm
// 	VCVTTPS2UQQ.Z xmm  k xmm
// 	VCVTTPS2UQQ.Z xmm  k ymm
func VCVTTPS2UQQ_Z(mxy, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(mxy) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsYMM(mxy) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxy) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsM64(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTTPS2UQQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTTPS2UQQ_Z: bad operands")
}

// VCVTTSD2SI: Convert with Truncation Scalar Double-Precision FP Value to Signed Integer.
//
// Forms:
//
// 	VCVTTSD2SI m64 r32
// 	VCVTTSD2SI xmm r32
func VCVTTSD2SI(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsR32(r),
		operand.IsXMM(mx) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSD2SI",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTTSD2SI: bad operands")
}

// VCVTTSD2SIQ: Convert with Truncation Scalar Double-Precision FP Value to Signed Integer.
//
// Forms:
//
// 	VCVTTSD2SIQ m64 r64
// 	VCVTTSD2SIQ xmm r64
func VCVTTSD2SIQ(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsR64(r),
		operand.IsXMM(mx) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSD2SIQ",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTTSD2SIQ: bad operands")
}

// VCVTTSD2SIQ_SAE: Convert with Truncation Scalar Double-Precision FP Value to Signed Integer (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTSD2SIQ.SAE xmm r64
func VCVTTSD2SIQ_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSD2SIQ",
			Suffixes: []string{"SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTSD2SIQ_SAE: bad operands")
}

// VCVTTSD2SI_SAE: Convert with Truncation Scalar Double-Precision FP Value to Signed Integer (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTSD2SI.SAE xmm r32
func VCVTTSD2SI_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSD2SI",
			Suffixes: []string{"SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTSD2SI_SAE: bad operands")
}

// VCVTTSD2USIL: Convert with Truncation Scalar Double-Precision Floating-Point Value to Unsigned Integer.
//
// Forms:
//
// 	VCVTTSD2USIL m64 r32
// 	VCVTTSD2USIL xmm r32
func VCVTTSD2USIL(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsR32(r),
		operand.IsXMM(mx) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSD2USIL",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTSD2USIL: bad operands")
}

// VCVTTSD2USIL_SAE: Convert with Truncation Scalar Double-Precision Floating-Point Value to Unsigned Integer (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTSD2USIL.SAE xmm r32
func VCVTTSD2USIL_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSD2USIL",
			Suffixes: []string{"SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTSD2USIL_SAE: bad operands")
}

// VCVTTSD2USIQ: Convert with Truncation Scalar Double-Precision Floating-Point Value to Unsigned Integer.
//
// Forms:
//
// 	VCVTTSD2USIQ m64 r64
// 	VCVTTSD2USIQ xmm r64
func VCVTTSD2USIQ(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsR64(r),
		operand.IsXMM(mx) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSD2USIQ",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTSD2USIQ: bad operands")
}

// VCVTTSD2USIQ_SAE: Convert with Truncation Scalar Double-Precision Floating-Point Value to Unsigned Integer (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTSD2USIQ.SAE xmm r64
func VCVTTSD2USIQ_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSD2USIQ",
			Suffixes: []string{"SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTSD2USIQ_SAE: bad operands")
}

// VCVTTSS2SI: Convert with Truncation Scalar Single-Precision FP Value to Dword Integer.
//
// Forms:
//
// 	VCVTTSS2SI m32 r32
// 	VCVTTSS2SI xmm r32
func VCVTTSS2SI(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsR32(r),
		operand.IsXMM(mx) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSS2SI",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTTSS2SI: bad operands")
}

// VCVTTSS2SIQ: Convert with Truncation Scalar Single-Precision FP Value to Dword Integer.
//
// Forms:
//
// 	VCVTTSS2SIQ m32 r64
// 	VCVTTSS2SIQ xmm r64
func VCVTTSS2SIQ(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsR64(r),
		operand.IsXMM(mx) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSS2SIQ",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VCVTTSS2SIQ: bad operands")
}

// VCVTTSS2SIQ_SAE: Convert with Truncation Scalar Single-Precision FP Value to Dword Integer (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTSS2SIQ.SAE xmm r64
func VCVTTSS2SIQ_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSS2SIQ",
			Suffixes: []string{"SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTSS2SIQ_SAE: bad operands")
}

// VCVTTSS2SI_SAE: Convert with Truncation Scalar Single-Precision FP Value to Dword Integer (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTSS2SI.SAE xmm r32
func VCVTTSS2SI_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSS2SI",
			Suffixes: []string{"SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTSS2SI_SAE: bad operands")
}

// VCVTTSS2USIL: Convert with Truncation Scalar Single-Precision Floating-Point Value to Unsigned Integer.
//
// Forms:
//
// 	VCVTTSS2USIL m32 r32
// 	VCVTTSS2USIL xmm r32
func VCVTTSS2USIL(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsR32(r),
		operand.IsXMM(mx) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSS2USIL",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTSS2USIL: bad operands")
}

// VCVTTSS2USIL_SAE: Convert with Truncation Scalar Single-Precision Floating-Point Value to Unsigned Integer (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTSS2USIL.SAE xmm r32
func VCVTTSS2USIL_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSS2USIL",
			Suffixes: []string{"SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTSS2USIL_SAE: bad operands")
}

// VCVTTSS2USIQ: Convert with Truncation Scalar Single-Precision Floating-Point Value to Unsigned Integer.
//
// Forms:
//
// 	VCVTTSS2USIQ m32 r64
// 	VCVTTSS2USIQ xmm r64
func VCVTTSS2USIQ(mx, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsR64(r),
		operand.IsXMM(mx) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSS2USIQ",
			Operands: []operand.Op{mx, r},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTSS2USIQ: bad operands")
}

// VCVTTSS2USIQ_SAE: Convert with Truncation Scalar Single-Precision Floating-Point Value to Unsigned Integer (Suppress All Exceptions).
//
// Forms:
//
// 	VCVTTSS2USIQ.SAE xmm r64
func VCVTTSS2USIQ_SAE(x, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsR64(r):
		return &intrep.Instruction{
			Opcode:   "VCVTTSS2USIQ",
			Suffixes: []string{"SAE"},
			Operands: []operand.Op{x, r},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTTSS2USIQ_SAE: bad operands")
}

// VCVTUDQ2PD: Convert Packed Unsigned Doubleword Integers to Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VCVTUDQ2PD m256 k zmm
// 	VCVTUDQ2PD m256 zmm
// 	VCVTUDQ2PD ymm  k zmm
// 	VCVTUDQ2PD ymm  zmm
// 	VCVTUDQ2PD m128 k ymm
// 	VCVTUDQ2PD m128 ymm
// 	VCVTUDQ2PD m64  k xmm
// 	VCVTUDQ2PD m64  xmm
// 	VCVTUDQ2PD xmm  k xmm
// 	VCVTUDQ2PD xmm  k ymm
// 	VCVTUDQ2PD xmm  xmm
// 	VCVTUDQ2PD xmm  ymm
func VCVTUDQ2PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PD: bad operands")
}

// VCVTUDQ2PD_BCST: Convert Packed Unsigned Doubleword Integers to Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VCVTUDQ2PD.BCST m32 k zmm
// 	VCVTUDQ2PD.BCST m32 zmm
// 	VCVTUDQ2PD.BCST m32 k xmm
// 	VCVTUDQ2PD.BCST m32 k ymm
// 	VCVTUDQ2PD.BCST m32 xmm
// 	VCVTUDQ2PD.BCST m32 ymm
func VCVTUDQ2PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PD_BCST: bad operands")
}

// VCVTUDQ2PD_BCST_Z: Convert Packed Unsigned Doubleword Integers to Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTUDQ2PD.BCST.Z m32 k zmm
// 	VCVTUDQ2PD.BCST.Z m32 k xmm
// 	VCVTUDQ2PD.BCST.Z m32 k ymm
func VCVTUDQ2PD_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PD_BCST_Z: bad operands")
}

// VCVTUDQ2PD_Z: Convert Packed Unsigned Doubleword Integers to Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTUDQ2PD.Z m256 k zmm
// 	VCVTUDQ2PD.Z ymm  k zmm
// 	VCVTUDQ2PD.Z m128 k ymm
// 	VCVTUDQ2PD.Z m64  k xmm
// 	VCVTUDQ2PD.Z xmm  k xmm
// 	VCVTUDQ2PD.Z xmm  k ymm
func VCVTUDQ2PD_Z(mxy, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(mxy) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsYMM(mxy) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxy) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsM64(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PD_Z: bad operands")
}

// VCVTUDQ2PS: Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VCVTUDQ2PS m512 k zmm
// 	VCVTUDQ2PS m512 zmm
// 	VCVTUDQ2PS zmm  k zmm
// 	VCVTUDQ2PS zmm  zmm
// 	VCVTUDQ2PS m128 k xmm
// 	VCVTUDQ2PS m128 xmm
// 	VCVTUDQ2PS m256 k ymm
// 	VCVTUDQ2PS m256 ymm
// 	VCVTUDQ2PS xmm  k xmm
// 	VCVTUDQ2PS xmm  xmm
// 	VCVTUDQ2PS ymm  k ymm
// 	VCVTUDQ2PS ymm  ymm
func VCVTUDQ2PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PS: bad operands")
}

// VCVTUDQ2PS_BCST: Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VCVTUDQ2PS.BCST m32 k zmm
// 	VCVTUDQ2PS.BCST m32 zmm
// 	VCVTUDQ2PS.BCST m32 k xmm
// 	VCVTUDQ2PS.BCST m32 k ymm
// 	VCVTUDQ2PS.BCST m32 xmm
// 	VCVTUDQ2PS.BCST m32 ymm
func VCVTUDQ2PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PS_BCST: bad operands")
}

// VCVTUDQ2PS_BCST_Z: Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTUDQ2PS.BCST.Z m32 k zmm
// 	VCVTUDQ2PS.BCST.Z m32 k xmm
// 	VCVTUDQ2PS.BCST.Z m32 k ymm
func VCVTUDQ2PS_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PS_BCST_Z: bad operands")
}

// VCVTUDQ2PS_RD_SAE: Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTUDQ2PS.RD_SAE zmm k zmm
// 	VCVTUDQ2PS.RD_SAE zmm zmm
func VCVTUDQ2PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PS_RD_SAE: bad operands")
}

// VCVTUDQ2PS_RD_SAE_Z: Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTUDQ2PS.RD_SAE.Z zmm k zmm
func VCVTUDQ2PS_RD_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PS_RD_SAE_Z: bad operands")
}

// VCVTUDQ2PS_RN_SAE: Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VCVTUDQ2PS.RN_SAE zmm k zmm
// 	VCVTUDQ2PS.RN_SAE zmm zmm
func VCVTUDQ2PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PS_RN_SAE: bad operands")
}

// VCVTUDQ2PS_RN_SAE_Z: Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTUDQ2PS.RN_SAE.Z zmm k zmm
func VCVTUDQ2PS_RN_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PS_RN_SAE_Z: bad operands")
}

// VCVTUDQ2PS_RU_SAE: Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTUDQ2PS.RU_SAE zmm k zmm
// 	VCVTUDQ2PS.RU_SAE zmm zmm
func VCVTUDQ2PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PS_RU_SAE: bad operands")
}

// VCVTUDQ2PS_RU_SAE_Z: Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTUDQ2PS.RU_SAE.Z zmm k zmm
func VCVTUDQ2PS_RU_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PS_RU_SAE_Z: bad operands")
}

// VCVTUDQ2PS_RZ_SAE: Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VCVTUDQ2PS.RZ_SAE zmm k zmm
// 	VCVTUDQ2PS.RZ_SAE zmm zmm
func VCVTUDQ2PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PS_RZ_SAE: bad operands")
}

// VCVTUDQ2PS_RZ_SAE_Z: Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTUDQ2PS.RZ_SAE.Z zmm k zmm
func VCVTUDQ2PS_RZ_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PS_RZ_SAE_Z: bad operands")
}

// VCVTUDQ2PS_Z: Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTUDQ2PS.Z m512 k zmm
// 	VCVTUDQ2PS.Z zmm  k zmm
// 	VCVTUDQ2PS.Z m128 k xmm
// 	VCVTUDQ2PS.Z m256 k ymm
// 	VCVTUDQ2PS.Z xmm  k xmm
// 	VCVTUDQ2PS.Z ymm  k ymm
func VCVTUDQ2PS_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTUDQ2PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUDQ2PS_Z: bad operands")
}

// VCVTUQQ2PD: Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VCVTUQQ2PD m512 k zmm
// 	VCVTUQQ2PD m512 zmm
// 	VCVTUQQ2PD zmm  k zmm
// 	VCVTUQQ2PD zmm  zmm
// 	VCVTUQQ2PD m128 k xmm
// 	VCVTUQQ2PD m128 xmm
// 	VCVTUQQ2PD m256 k ymm
// 	VCVTUQQ2PD m256 ymm
// 	VCVTUQQ2PD xmm  k xmm
// 	VCVTUQQ2PD xmm  xmm
// 	VCVTUQQ2PD ymm  k ymm
// 	VCVTUQQ2PD ymm  ymm
func VCVTUQQ2PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PD: bad operands")
}

// VCVTUQQ2PD_BCST: Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VCVTUQQ2PD.BCST m64 k zmm
// 	VCVTUQQ2PD.BCST m64 zmm
// 	VCVTUQQ2PD.BCST m64 k xmm
// 	VCVTUQQ2PD.BCST m64 k ymm
// 	VCVTUQQ2PD.BCST m64 xmm
// 	VCVTUQQ2PD.BCST m64 ymm
func VCVTUQQ2PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PD_BCST: bad operands")
}

// VCVTUQQ2PD_BCST_Z: Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PD.BCST.Z m64 k zmm
// 	VCVTUQQ2PD.BCST.Z m64 k xmm
// 	VCVTUQQ2PD.BCST.Z m64 k ymm
func VCVTUQQ2PD_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PD_BCST_Z: bad operands")
}

// VCVTUQQ2PD_RD_SAE: Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTUQQ2PD.RD_SAE zmm k zmm
// 	VCVTUQQ2PD.RD_SAE zmm zmm
func VCVTUQQ2PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PD_RD_SAE: bad operands")
}

// VCVTUQQ2PD_RD_SAE_Z: Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PD.RD_SAE.Z zmm k zmm
func VCVTUQQ2PD_RD_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PD_RD_SAE_Z: bad operands")
}

// VCVTUQQ2PD_RN_SAE: Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VCVTUQQ2PD.RN_SAE zmm k zmm
// 	VCVTUQQ2PD.RN_SAE zmm zmm
func VCVTUQQ2PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PD_RN_SAE: bad operands")
}

// VCVTUQQ2PD_RN_SAE_Z: Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PD.RN_SAE.Z zmm k zmm
func VCVTUQQ2PD_RN_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PD_RN_SAE_Z: bad operands")
}

// VCVTUQQ2PD_RU_SAE: Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTUQQ2PD.RU_SAE zmm k zmm
// 	VCVTUQQ2PD.RU_SAE zmm zmm
func VCVTUQQ2PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PD_RU_SAE: bad operands")
}

// VCVTUQQ2PD_RU_SAE_Z: Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PD.RU_SAE.Z zmm k zmm
func VCVTUQQ2PD_RU_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PD_RU_SAE_Z: bad operands")
}

// VCVTUQQ2PD_RZ_SAE: Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VCVTUQQ2PD.RZ_SAE zmm k zmm
// 	VCVTUQQ2PD.RZ_SAE zmm zmm
func VCVTUQQ2PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PD_RZ_SAE: bad operands")
}

// VCVTUQQ2PD_RZ_SAE_Z: Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PD.RZ_SAE.Z zmm k zmm
func VCVTUQQ2PD_RZ_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PD_RZ_SAE_Z: bad operands")
}

// VCVTUQQ2PD_Z: Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PD.Z m512 k zmm
// 	VCVTUQQ2PD.Z zmm  k zmm
// 	VCVTUQQ2PD.Z m128 k xmm
// 	VCVTUQQ2PD.Z m256 k ymm
// 	VCVTUQQ2PD.Z xmm  k xmm
// 	VCVTUQQ2PD.Z ymm  k ymm
func VCVTUQQ2PD_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PD_Z: bad operands")
}

// VCVTUQQ2PS: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VCVTUQQ2PS m512 k ymm
// 	VCVTUQQ2PS m512 ymm
// 	VCVTUQQ2PS zmm  k ymm
// 	VCVTUQQ2PS zmm  ymm
func VCVTUQQ2PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PS: bad operands")
}

// VCVTUQQ2PSX: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VCVTUQQ2PSX m128 k xmm
// 	VCVTUQQ2PSX m128 xmm
// 	VCVTUQQ2PSX xmm  k xmm
// 	VCVTUQQ2PSX xmm  xmm
func VCVTUQQ2PSX(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PSX",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PSX",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PSX: bad operands")
}

// VCVTUQQ2PSX_BCST: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VCVTUQQ2PSX.BCST m64 k xmm
// 	VCVTUQQ2PSX.BCST m64 xmm
func VCVTUQQ2PSX_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PSX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PSX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PSX_BCST: bad operands")
}

// VCVTUQQ2PSX_BCST_Z: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PSX.BCST.Z m64 k xmm
func VCVTUQQ2PSX_BCST_Z(m, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PSX",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, x},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PSX_BCST_Z: bad operands")
}

// VCVTUQQ2PSX_Z: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PSX.Z m128 k xmm
// 	VCVTUQQ2PSX.Z xmm  k xmm
func VCVTUQQ2PSX_Z(mx, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsK(k) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PSX",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, x},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PSX_Z: bad operands")
}

// VCVTUQQ2PSY: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VCVTUQQ2PSY m256 k xmm
// 	VCVTUQQ2PSY m256 xmm
// 	VCVTUQQ2PSY ymm  k xmm
// 	VCVTUQQ2PSY ymm  xmm
func VCVTUQQ2PSY(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PSY",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PSY",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PSY: bad operands")
}

// VCVTUQQ2PSY_BCST: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VCVTUQQ2PSY.BCST m64 k xmm
// 	VCVTUQQ2PSY.BCST m64 xmm
func VCVTUQQ2PSY_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PSY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PSY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PSY_BCST: bad operands")
}

// VCVTUQQ2PSY_BCST_Z: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PSY.BCST.Z m64 k xmm
func VCVTUQQ2PSY_BCST_Z(m, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PSY",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, x},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PSY_BCST_Z: bad operands")
}

// VCVTUQQ2PSY_Z: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PSY.Z m256 k xmm
// 	VCVTUQQ2PSY.Z ymm  k xmm
func VCVTUQQ2PSY_Z(my, k, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(my) && operand.IsK(k) && operand.IsXMM(x),
		operand.IsYMM(my) && operand.IsK(k) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PSY",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{my, k, x},
			Inputs:   []operand.Op{my, k},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PSY_Z: bad operands")
}

// VCVTUQQ2PS_BCST: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VCVTUQQ2PS.BCST m64 k ymm
// 	VCVTUQQ2PS.BCST m64 ymm
func VCVTUQQ2PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PS_BCST: bad operands")
}

// VCVTUQQ2PS_BCST_Z: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PS.BCST.Z m64 k ymm
func VCVTUQQ2PS_BCST_Z(m, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, y},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PS_BCST_Z: bad operands")
}

// VCVTUQQ2PS_RD_SAE: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTUQQ2PS.RD_SAE zmm k ymm
// 	VCVTUQQ2PS.RD_SAE zmm ymm
func VCVTUQQ2PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PS_RD_SAE: bad operands")
}

// VCVTUQQ2PS_RD_SAE_Z: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PS.RD_SAE.Z zmm k ymm
func VCVTUQQ2PS_RD_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PS_RD_SAE_Z: bad operands")
}

// VCVTUQQ2PS_RN_SAE: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VCVTUQQ2PS.RN_SAE zmm k ymm
// 	VCVTUQQ2PS.RN_SAE zmm ymm
func VCVTUQQ2PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PS_RN_SAE: bad operands")
}

// VCVTUQQ2PS_RN_SAE_Z: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PS.RN_SAE.Z zmm k ymm
func VCVTUQQ2PS_RN_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PS_RN_SAE_Z: bad operands")
}

// VCVTUQQ2PS_RU_SAE: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTUQQ2PS.RU_SAE zmm k ymm
// 	VCVTUQQ2PS.RU_SAE zmm ymm
func VCVTUQQ2PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PS_RU_SAE: bad operands")
}

// VCVTUQQ2PS_RU_SAE_Z: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PS.RU_SAE.Z zmm k ymm
func VCVTUQQ2PS_RU_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PS_RU_SAE_Z: bad operands")
}

// VCVTUQQ2PS_RZ_SAE: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VCVTUQQ2PS.RZ_SAE zmm k ymm
// 	VCVTUQQ2PS.RZ_SAE zmm ymm
func VCVTUQQ2PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PS_RZ_SAE: bad operands")
}

// VCVTUQQ2PS_RZ_SAE_Z: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PS.RZ_SAE.Z zmm k ymm
func VCVTUQQ2PS_RZ_SAE_Z(z, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, y},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PS_RZ_SAE_Z: bad operands")
}

// VCVTUQQ2PS_Z: Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VCVTUQQ2PS.Z m512 k ymm
// 	VCVTUQQ2PS.Z zmm  k ymm
func VCVTUQQ2PS_Z(mz, k, y operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsYMM(y),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsYMM(y):
		return &intrep.Instruction{
			Opcode:   "VCVTUQQ2PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, y},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{y},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VCVTUQQ2PS_Z: bad operands")
}

// VCVTUSI2SDL: Convert Unsigned Integer to Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VCVTUSI2SDL m32 xmm xmm
// 	VCVTUSI2SDL r32 xmm xmm
func VCVTUSI2SDL(mr, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsR32(mr) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SDL",
			Operands: []operand.Op{mr, x, x1},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SDL: bad operands")
}

// VCVTUSI2SDQ: Convert Unsigned Integer to Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VCVTUSI2SDQ m64 xmm xmm
// 	VCVTUSI2SDQ r64 xmm xmm
func VCVTUSI2SDQ(mr, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsR64(mr) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SDQ",
			Operands: []operand.Op{mr, x, x1},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SDQ: bad operands")
}

// VCVTUSI2SDQ_RD_SAE: Convert Unsigned Integer to Scalar Double-Precision Floating-Point Value (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTUSI2SDQ.RD_SAE r64 xmm xmm
func VCVTUSI2SDQ_RD_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SDQ",
			Suffixes: []string{"RD_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SDQ_RD_SAE: bad operands")
}

// VCVTUSI2SDQ_RN_SAE: Convert Unsigned Integer to Scalar Double-Precision Floating-Point Value (Round Towards Nearest).
//
// Forms:
//
// 	VCVTUSI2SDQ.RN_SAE r64 xmm xmm
func VCVTUSI2SDQ_RN_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SDQ",
			Suffixes: []string{"RN_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SDQ_RN_SAE: bad operands")
}

// VCVTUSI2SDQ_RU_SAE: Convert Unsigned Integer to Scalar Double-Precision Floating-Point Value (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTUSI2SDQ.RU_SAE r64 xmm xmm
func VCVTUSI2SDQ_RU_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SDQ",
			Suffixes: []string{"RU_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SDQ_RU_SAE: bad operands")
}

// VCVTUSI2SDQ_RZ_SAE: Convert Unsigned Integer to Scalar Double-Precision Floating-Point Value (Round Towards Zero).
//
// Forms:
//
// 	VCVTUSI2SDQ.RZ_SAE r64 xmm xmm
func VCVTUSI2SDQ_RZ_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SDQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SDQ_RZ_SAE: bad operands")
}

// VCVTUSI2SSL: Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	VCVTUSI2SSL m32 xmm xmm
// 	VCVTUSI2SSL r32 xmm xmm
func VCVTUSI2SSL(mr, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mr) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsR32(mr) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SSL",
			Operands: []operand.Op{mr, x, x1},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SSL: bad operands")
}

// VCVTUSI2SSL_RD_SAE: Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTUSI2SSL.RD_SAE r32 xmm xmm
func VCVTUSI2SSL_RD_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SSL",
			Suffixes: []string{"RD_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SSL_RD_SAE: bad operands")
}

// VCVTUSI2SSL_RN_SAE: Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value (Round Towards Nearest).
//
// Forms:
//
// 	VCVTUSI2SSL.RN_SAE r32 xmm xmm
func VCVTUSI2SSL_RN_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SSL",
			Suffixes: []string{"RN_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SSL_RN_SAE: bad operands")
}

// VCVTUSI2SSL_RU_SAE: Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTUSI2SSL.RU_SAE r32 xmm xmm
func VCVTUSI2SSL_RU_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SSL",
			Suffixes: []string{"RU_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SSL_RU_SAE: bad operands")
}

// VCVTUSI2SSL_RZ_SAE: Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value (Round Towards Zero).
//
// Forms:
//
// 	VCVTUSI2SSL.RZ_SAE r32 xmm xmm
func VCVTUSI2SSL_RZ_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SSL",
			Suffixes: []string{"RZ_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SSL_RZ_SAE: bad operands")
}

// VCVTUSI2SSQ: Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	VCVTUSI2SSQ m64 xmm xmm
// 	VCVTUSI2SSQ r64 xmm xmm
func VCVTUSI2SSQ(mr, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsR64(mr) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SSQ",
			Operands: []operand.Op{mr, x, x1},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SSQ: bad operands")
}

// VCVTUSI2SSQ_RD_SAE: Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value (Round Towards Negative Infinity).
//
// Forms:
//
// 	VCVTUSI2SSQ.RD_SAE r64 xmm xmm
func VCVTUSI2SSQ_RD_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SSQ",
			Suffixes: []string{"RD_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SSQ_RD_SAE: bad operands")
}

// VCVTUSI2SSQ_RN_SAE: Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value (Round Towards Nearest).
//
// Forms:
//
// 	VCVTUSI2SSQ.RN_SAE r64 xmm xmm
func VCVTUSI2SSQ_RN_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SSQ",
			Suffixes: []string{"RN_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SSQ_RN_SAE: bad operands")
}

// VCVTUSI2SSQ_RU_SAE: Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value (Round Towards Positive Infinity).
//
// Forms:
//
// 	VCVTUSI2SSQ.RU_SAE r64 xmm xmm
func VCVTUSI2SSQ_RU_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SSQ",
			Suffixes: []string{"RU_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SSQ_RU_SAE: bad operands")
}

// VCVTUSI2SSQ_RZ_SAE: Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value (Round Towards Zero).
//
// Forms:
//
// 	VCVTUSI2SSQ.RZ_SAE r64 xmm xmm
func VCVTUSI2SSQ_RZ_SAE(r, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VCVTUSI2SSQ",
			Suffixes: []string{"RZ_SAE"},
			Operands: []operand.Op{r, x, x1},
			Inputs:   []operand.Op{r, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VCVTUSI2SSQ_RZ_SAE: bad operands")
}

// VDBPSADBW: Double Block Packed Sum-Absolute-Differences on Unsigned Bytes.
//
// Forms:
//
// 	VDBPSADBW imm8 m512 zmm k zmm
// 	VDBPSADBW imm8 m512 zmm zmm
// 	VDBPSADBW imm8 zmm  zmm k zmm
// 	VDBPSADBW imm8 zmm  zmm zmm
// 	VDBPSADBW imm8 m128 xmm k xmm
// 	VDBPSADBW imm8 m128 xmm xmm
// 	VDBPSADBW imm8 m256 ymm k ymm
// 	VDBPSADBW imm8 m256 ymm ymm
// 	VDBPSADBW imm8 xmm  xmm k xmm
// 	VDBPSADBW imm8 xmm  xmm xmm
// 	VDBPSADBW imm8 ymm  ymm k ymm
// 	VDBPSADBW imm8 ymm  ymm ymm
func VDBPSADBW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VDBPSADBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VDBPSADBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDBPSADBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDBPSADBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VDBPSADBW: bad operands")
}

// VDBPSADBW_Z: Double Block Packed Sum-Absolute-Differences on Unsigned Bytes (Zeroing Masking).
//
// Forms:
//
// 	VDBPSADBW.Z imm8 m512 zmm k zmm
// 	VDBPSADBW.Z imm8 zmm  zmm k zmm
// 	VDBPSADBW.Z imm8 m128 xmm k xmm
// 	VDBPSADBW.Z imm8 m256 ymm k ymm
// 	VDBPSADBW.Z imm8 xmm  xmm k xmm
// 	VDBPSADBW.Z imm8 ymm  ymm k ymm
func VDBPSADBW_Z(i, mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VDBPSADBW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VDBPSADBW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VDBPSADBW_Z: bad operands")
}

// VDIVPD: Divide Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VDIVPD m128 xmm xmm
// 	VDIVPD m256 ymm ymm
// 	VDIVPD xmm  xmm xmm
// 	VDIVPD ymm  ymm ymm
// 	VDIVPD m512 zmm k zmm
// 	VDIVPD m512 zmm zmm
// 	VDIVPD zmm  zmm k zmm
// 	VDIVPD zmm  zmm zmm
// 	VDIVPD m128 xmm k xmm
// 	VDIVPD m256 ymm k ymm
// 	VDIVPD xmm  xmm k xmm
// 	VDIVPD ymm  ymm k ymm
func VDIVPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPD: bad operands")
}

// VDIVPD_BCST: Divide Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VDIVPD.BCST m64 zmm k zmm
// 	VDIVPD.BCST m64 zmm zmm
// 	VDIVPD.BCST m64 xmm k xmm
// 	VDIVPD.BCST m64 xmm xmm
// 	VDIVPD.BCST m64 ymm k ymm
// 	VDIVPD.BCST m64 ymm ymm
func VDIVPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPD_BCST: bad operands")
}

// VDIVPD_BCST_Z: Divide Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VDIVPD.BCST.Z m64 zmm k zmm
// 	VDIVPD.BCST.Z m64 xmm k xmm
// 	VDIVPD.BCST.Z m64 ymm k ymm
func VDIVPD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPD_BCST_Z: bad operands")
}

// VDIVPD_RD_SAE: Divide Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VDIVPD.RD_SAE zmm zmm k zmm
// 	VDIVPD.RD_SAE zmm zmm zmm
func VDIVPD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPD_RD_SAE: bad operands")
}

// VDIVPD_RD_SAE_Z: Divide Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VDIVPD.RD_SAE.Z zmm zmm k zmm
func VDIVPD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPD_RD_SAE_Z: bad operands")
}

// VDIVPD_RN_SAE: Divide Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VDIVPD.RN_SAE zmm zmm k zmm
// 	VDIVPD.RN_SAE zmm zmm zmm
func VDIVPD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPD_RN_SAE: bad operands")
}

// VDIVPD_RN_SAE_Z: Divide Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VDIVPD.RN_SAE.Z zmm zmm k zmm
func VDIVPD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPD_RN_SAE_Z: bad operands")
}

// VDIVPD_RU_SAE: Divide Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VDIVPD.RU_SAE zmm zmm k zmm
// 	VDIVPD.RU_SAE zmm zmm zmm
func VDIVPD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPD_RU_SAE: bad operands")
}

// VDIVPD_RU_SAE_Z: Divide Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VDIVPD.RU_SAE.Z zmm zmm k zmm
func VDIVPD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPD_RU_SAE_Z: bad operands")
}

// VDIVPD_RZ_SAE: Divide Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VDIVPD.RZ_SAE zmm zmm k zmm
// 	VDIVPD.RZ_SAE zmm zmm zmm
func VDIVPD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPD_RZ_SAE: bad operands")
}

// VDIVPD_RZ_SAE_Z: Divide Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VDIVPD.RZ_SAE.Z zmm zmm k zmm
func VDIVPD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPD_RZ_SAE_Z: bad operands")
}

// VDIVPD_Z: Divide Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VDIVPD.Z m512 zmm k zmm
// 	VDIVPD.Z zmm  zmm k zmm
// 	VDIVPD.Z m128 xmm k xmm
// 	VDIVPD.Z m256 ymm k ymm
// 	VDIVPD.Z xmm  xmm k xmm
// 	VDIVPD.Z ymm  ymm k ymm
func VDIVPD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VDIVPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPD_Z: bad operands")
}

// VDIVPS: Divide Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VDIVPS m128 xmm xmm
// 	VDIVPS m256 ymm ymm
// 	VDIVPS xmm  xmm xmm
// 	VDIVPS ymm  ymm ymm
// 	VDIVPS m512 zmm k zmm
// 	VDIVPS m512 zmm zmm
// 	VDIVPS zmm  zmm k zmm
// 	VDIVPS zmm  zmm zmm
// 	VDIVPS m128 xmm k xmm
// 	VDIVPS m256 ymm k ymm
// 	VDIVPS xmm  xmm k xmm
// 	VDIVPS ymm  ymm k ymm
func VDIVPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPS: bad operands")
}

// VDIVPS_BCST: Divide Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VDIVPS.BCST m32 zmm k zmm
// 	VDIVPS.BCST m32 zmm zmm
// 	VDIVPS.BCST m32 xmm k xmm
// 	VDIVPS.BCST m32 xmm xmm
// 	VDIVPS.BCST m32 ymm k ymm
// 	VDIVPS.BCST m32 ymm ymm
func VDIVPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPS_BCST: bad operands")
}

// VDIVPS_BCST_Z: Divide Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VDIVPS.BCST.Z m32 zmm k zmm
// 	VDIVPS.BCST.Z m32 xmm k xmm
// 	VDIVPS.BCST.Z m32 ymm k ymm
func VDIVPS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPS_BCST_Z: bad operands")
}

// VDIVPS_RD_SAE: Divide Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VDIVPS.RD_SAE zmm zmm k zmm
// 	VDIVPS.RD_SAE zmm zmm zmm
func VDIVPS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPS_RD_SAE: bad operands")
}

// VDIVPS_RD_SAE_Z: Divide Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VDIVPS.RD_SAE.Z zmm zmm k zmm
func VDIVPS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPS_RD_SAE_Z: bad operands")
}

// VDIVPS_RN_SAE: Divide Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VDIVPS.RN_SAE zmm zmm k zmm
// 	VDIVPS.RN_SAE zmm zmm zmm
func VDIVPS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPS_RN_SAE: bad operands")
}

// VDIVPS_RN_SAE_Z: Divide Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VDIVPS.RN_SAE.Z zmm zmm k zmm
func VDIVPS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPS_RN_SAE_Z: bad operands")
}

// VDIVPS_RU_SAE: Divide Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VDIVPS.RU_SAE zmm zmm k zmm
// 	VDIVPS.RU_SAE zmm zmm zmm
func VDIVPS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPS_RU_SAE: bad operands")
}

// VDIVPS_RU_SAE_Z: Divide Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VDIVPS.RU_SAE.Z zmm zmm k zmm
func VDIVPS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPS_RU_SAE_Z: bad operands")
}

// VDIVPS_RZ_SAE: Divide Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VDIVPS.RZ_SAE zmm zmm k zmm
// 	VDIVPS.RZ_SAE zmm zmm zmm
func VDIVPS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPS_RZ_SAE: bad operands")
}

// VDIVPS_RZ_SAE_Z: Divide Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VDIVPS.RZ_SAE.Z zmm zmm k zmm
func VDIVPS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPS_RZ_SAE_Z: bad operands")
}

// VDIVPS_Z: Divide Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VDIVPS.Z m512 zmm k zmm
// 	VDIVPS.Z zmm  zmm k zmm
// 	VDIVPS.Z m128 xmm k xmm
// 	VDIVPS.Z m256 ymm k ymm
// 	VDIVPS.Z xmm  xmm k xmm
// 	VDIVPS.Z ymm  ymm k ymm
func VDIVPS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VDIVPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVPS_Z: bad operands")
}

// VDIVSD: Divide Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VDIVSD m64 xmm xmm
// 	VDIVSD xmm xmm xmm
// 	VDIVSD m64 xmm k xmm
// 	VDIVSD xmm xmm k xmm
func VDIVSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VDIVSD: bad operands")
}

// VDIVSD_RD_SAE: Divide Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VDIVSD.RD_SAE xmm xmm k xmm
// 	VDIVSD.RD_SAE xmm xmm xmm
func VDIVSD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSD_RD_SAE: bad operands")
}

// VDIVSD_RD_SAE_Z: Divide Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VDIVSD.RD_SAE.Z xmm xmm k xmm
func VDIVSD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSD_RD_SAE_Z: bad operands")
}

// VDIVSD_RN_SAE: Divide Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VDIVSD.RN_SAE xmm xmm k xmm
// 	VDIVSD.RN_SAE xmm xmm xmm
func VDIVSD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSD_RN_SAE: bad operands")
}

// VDIVSD_RN_SAE_Z: Divide Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VDIVSD.RN_SAE.Z xmm xmm k xmm
func VDIVSD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSD_RN_SAE_Z: bad operands")
}

// VDIVSD_RU_SAE: Divide Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VDIVSD.RU_SAE xmm xmm k xmm
// 	VDIVSD.RU_SAE xmm xmm xmm
func VDIVSD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSD_RU_SAE: bad operands")
}

// VDIVSD_RU_SAE_Z: Divide Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VDIVSD.RU_SAE.Z xmm xmm k xmm
func VDIVSD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSD_RU_SAE_Z: bad operands")
}

// VDIVSD_RZ_SAE: Divide Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VDIVSD.RZ_SAE xmm xmm k xmm
// 	VDIVSD.RZ_SAE xmm xmm xmm
func VDIVSD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSD_RZ_SAE: bad operands")
}

// VDIVSD_RZ_SAE_Z: Divide Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VDIVSD.RZ_SAE.Z xmm xmm k xmm
func VDIVSD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSD_RZ_SAE_Z: bad operands")
}

// VDIVSD_Z: Divide Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VDIVSD.Z m64 xmm k xmm
// 	VDIVSD.Z xmm xmm k xmm
func VDIVSD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VDIVSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSD_Z: bad operands")
}

// VDIVSS: Divide Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VDIVSS m32 xmm xmm
// 	VDIVSS xmm xmm xmm
// 	VDIVSS m32 xmm k xmm
// 	VDIVSS xmm xmm k xmm
func VDIVSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VDIVSS: bad operands")
}

// VDIVSS_RD_SAE: Divide Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VDIVSS.RD_SAE xmm xmm k xmm
// 	VDIVSS.RD_SAE xmm xmm xmm
func VDIVSS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSS_RD_SAE: bad operands")
}

// VDIVSS_RD_SAE_Z: Divide Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VDIVSS.RD_SAE.Z xmm xmm k xmm
func VDIVSS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSS_RD_SAE_Z: bad operands")
}

// VDIVSS_RN_SAE: Divide Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VDIVSS.RN_SAE xmm xmm k xmm
// 	VDIVSS.RN_SAE xmm xmm xmm
func VDIVSS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSS_RN_SAE: bad operands")
}

// VDIVSS_RN_SAE_Z: Divide Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VDIVSS.RN_SAE.Z xmm xmm k xmm
func VDIVSS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSS_RN_SAE_Z: bad operands")
}

// VDIVSS_RU_SAE: Divide Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VDIVSS.RU_SAE xmm xmm k xmm
// 	VDIVSS.RU_SAE xmm xmm xmm
func VDIVSS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSS_RU_SAE: bad operands")
}

// VDIVSS_RU_SAE_Z: Divide Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VDIVSS.RU_SAE.Z xmm xmm k xmm
func VDIVSS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSS_RU_SAE_Z: bad operands")
}

// VDIVSS_RZ_SAE: Divide Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VDIVSS.RZ_SAE xmm xmm k xmm
// 	VDIVSS.RZ_SAE xmm xmm xmm
func VDIVSS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSS_RZ_SAE: bad operands")
}

// VDIVSS_RZ_SAE_Z: Divide Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VDIVSS.RZ_SAE.Z xmm xmm k xmm
func VDIVSS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSS_RZ_SAE_Z: bad operands")
}

// VDIVSS_Z: Divide Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VDIVSS.Z m32 xmm k xmm
// 	VDIVSS.Z xmm xmm k xmm
func VDIVSS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VDIVSS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VDIVSS_Z: bad operands")
}

// VDPPD: Dot Product of Packed Double Precision Floating-Point Values.
//
// Forms:
//
// 	VDPPD imm8 m128 xmm xmm
// 	VDPPD imm8 xmm  xmm xmm
func VDPPD(i, mx, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VDPPD",
			Operands: []operand.Op{i, mx, x, x1},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VDPPD: bad operands")
}

// VDPPS: Dot Product of Packed Single Precision Floating-Point Values.
//
// Forms:
//
// 	VDPPS imm8 m128 xmm xmm
// 	VDPPS imm8 m256 ymm ymm
// 	VDPPS imm8 xmm  xmm xmm
// 	VDPPS imm8 ymm  ymm ymm
func VDPPS(i, mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsIMM8(i) && operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsIMM8(i) && operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsIMM8(i) && operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VDPPS",
			Operands: []operand.Op{i, mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VDPPS: bad operands")
}

// VEXP2PD: Approximation to the Exponential 2^x of Packed Double-Precision Floating-Point Values with Less Than 2^-23 Relative Error.
//
// Forms:
//
// 	VEXP2PD m512 k zmm
// 	VEXP2PD m512 zmm
// 	VEXP2PD zmm  k zmm
// 	VEXP2PD zmm  zmm
func VEXP2PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXP2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VEXP2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VEXP2PD: bad operands")
}

// VEXP2PD_BCST: Approximation to the Exponential 2^x of Packed Double-Precision Floating-Point Values with Less Than 2^-23 Relative Error (Broadcast).
//
// Forms:
//
// 	VEXP2PD.BCST m64 k zmm
// 	VEXP2PD.BCST m64 zmm
func VEXP2PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXP2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VEXP2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VEXP2PD_BCST: bad operands")
}

// VEXP2PD_BCST_Z: Approximation to the Exponential 2^x of Packed Double-Precision Floating-Point Values with Less Than 2^-23 Relative Error (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VEXP2PD.BCST.Z m64 k zmm
func VEXP2PD_BCST_Z(m, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VEXP2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, z},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VEXP2PD_BCST_Z: bad operands")
}

// VEXP2PD_SAE: Approximation to the Exponential 2^x of Packed Double-Precision Floating-Point Values with Less Than 2^-23 Relative Error (Suppress All Exceptions).
//
// Forms:
//
// 	VEXP2PD.SAE zmm k zmm
// 	VEXP2PD.SAE zmm zmm
func VEXP2PD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXP2PD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VEXP2PD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VEXP2PD_SAE: bad operands")
}

// VEXP2PD_SAE_Z: Approximation to the Exponential 2^x of Packed Double-Precision Floating-Point Values with Less Than 2^-23 Relative Error (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VEXP2PD.SAE.Z zmm k zmm
func VEXP2PD_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VEXP2PD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VEXP2PD_SAE_Z: bad operands")
}

// VEXP2PD_Z: Approximation to the Exponential 2^x of Packed Double-Precision Floating-Point Values with Less Than 2^-23 Relative Error (Zeroing Masking).
//
// Forms:
//
// 	VEXP2PD.Z m512 k zmm
// 	VEXP2PD.Z zmm  k zmm
func VEXP2PD_Z(mz, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsZMM(z),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VEXP2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, z},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VEXP2PD_Z: bad operands")
}

// VEXP2PS: Approximation to the Exponential 2^x of Packed Single-Precision Floating-Point Values with Less Than 2^-23 Relative Error.
//
// Forms:
//
// 	VEXP2PS m512 k zmm
// 	VEXP2PS m512 zmm
// 	VEXP2PS zmm  k zmm
// 	VEXP2PS zmm  zmm
func VEXP2PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXP2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VEXP2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VEXP2PS: bad operands")
}

// VEXP2PS_BCST: Approximation to the Exponential 2^x of Packed Single-Precision Floating-Point Values with Less Than 2^-23 Relative Error (Broadcast).
//
// Forms:
//
// 	VEXP2PS.BCST m32 k zmm
// 	VEXP2PS.BCST m32 zmm
func VEXP2PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXP2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VEXP2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VEXP2PS_BCST: bad operands")
}

// VEXP2PS_BCST_Z: Approximation to the Exponential 2^x of Packed Single-Precision Floating-Point Values with Less Than 2^-23 Relative Error (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VEXP2PS.BCST.Z m32 k zmm
func VEXP2PS_BCST_Z(m, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VEXP2PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, z},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VEXP2PS_BCST_Z: bad operands")
}

// VEXP2PS_SAE: Approximation to the Exponential 2^x of Packed Single-Precision Floating-Point Values with Less Than 2^-23 Relative Error (Suppress All Exceptions).
//
// Forms:
//
// 	VEXP2PS.SAE zmm k zmm
// 	VEXP2PS.SAE zmm zmm
func VEXP2PS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXP2PS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VEXP2PS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VEXP2PS_SAE: bad operands")
}

// VEXP2PS_SAE_Z: Approximation to the Exponential 2^x of Packed Single-Precision Floating-Point Values with Less Than 2^-23 Relative Error (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VEXP2PS.SAE.Z zmm k zmm
func VEXP2PS_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VEXP2PS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VEXP2PS_SAE_Z: bad operands")
}

// VEXP2PS_Z: Approximation to the Exponential 2^x of Packed Single-Precision Floating-Point Values with Less Than 2^-23 Relative Error (Zeroing Masking).
//
// Forms:
//
// 	VEXP2PS.Z m512 k zmm
// 	VEXP2PS.Z zmm  k zmm
func VEXP2PS_Z(mz, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsZMM(z),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VEXP2PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, z},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VEXP2PS_Z: bad operands")
}

// VEXPANDPD: Load Sparse Packed Double-Precision Floating-Point Values from Dense Memory.
//
// Forms:
//
// 	VEXPANDPD m512 k zmm
// 	VEXPANDPD m512 zmm
// 	VEXPANDPD zmm  k zmm
// 	VEXPANDPD zmm  zmm
// 	VEXPANDPD m256 k ymm
// 	VEXPANDPD m256 ymm
// 	VEXPANDPD ymm  k ymm
// 	VEXPANDPD ymm  ymm
// 	VEXPANDPD m128 k xmm
// 	VEXPANDPD m128 xmm
// 	VEXPANDPD xmm  k xmm
// 	VEXPANDPD xmm  xmm
func VEXPANDPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL"},
		}, nil
	}
	return nil, errors.New("VEXPANDPD: bad operands")
}

// VEXPANDPD_Z: Load Sparse Packed Double-Precision Floating-Point Values from Dense Memory (Zeroing Masking).
//
// Forms:
//
// 	VEXPANDPD.Z m512 k zmm
// 	VEXPANDPD.Z zmm  k zmm
// 	VEXPANDPD.Z m256 k ymm
// 	VEXPANDPD.Z ymm  k ymm
// 	VEXPANDPD.Z m128 k xmm
// 	VEXPANDPD.Z xmm  k xmm
func VEXPANDPD_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL"},
		}, nil
	}
	return nil, errors.New("VEXPANDPD_Z: bad operands")
}

// VEXPANDPS: Load Sparse Packed Single-Precision Floating-Point Values from Dense Memory.
//
// Forms:
//
// 	VEXPANDPS m512 k zmm
// 	VEXPANDPS m512 zmm
// 	VEXPANDPS zmm  k zmm
// 	VEXPANDPS zmm  zmm
// 	VEXPANDPS m128 k xmm
// 	VEXPANDPS m128 xmm
// 	VEXPANDPS m256 k ymm
// 	VEXPANDPS m256 ymm
// 	VEXPANDPS xmm  k xmm
// 	VEXPANDPS xmm  xmm
// 	VEXPANDPS ymm  k ymm
// 	VEXPANDPS ymm  ymm
func VEXPANDPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VEXPANDPS: bad operands")
}

// VEXPANDPS_Z: Load Sparse Packed Single-Precision Floating-Point Values from Dense Memory (Zeroing Masking).
//
// Forms:
//
// 	VEXPANDPS.Z m512 k zmm
// 	VEXPANDPS.Z zmm  k zmm
// 	VEXPANDPS.Z m128 k xmm
// 	VEXPANDPS.Z m256 k ymm
// 	VEXPANDPS.Z xmm  k xmm
// 	VEXPANDPS.Z ymm  k ymm
func VEXPANDPS_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VEXPANDPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VEXPANDPS_Z: bad operands")
}

// VEXTRACTF128: Extract Packed Floating-Point Values.
//
// Forms:
//
// 	VEXTRACTF128 imm8 ymm m128
// 	VEXTRACTF128 imm8 ymm xmm
func VEXTRACTF128(i, y, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsYMM(y) && operand.IsM128(mx),
		operand.IsIMM8(i) && operand.IsYMM(y) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF128",
			Operands: []operand.Op{i, y, mx},
			Inputs:   []operand.Op{y},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VEXTRACTF128: bad operands")
}

// VEXTRACTF32X4: Extract 128 Bits of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VEXTRACTF32X4 imm8 zmm k m128
// 	VEXTRACTF32X4 imm8 zmm k xmm
// 	VEXTRACTF32X4 imm8 zmm m128
// 	VEXTRACTF32X4 imm8 zmm xmm
// 	VEXTRACTF32X4 imm8 ymm k m128
// 	VEXTRACTF32X4 imm8 ymm k xmm
// 	VEXTRACTF32X4 imm8 ymm m128
// 	VEXTRACTF32X4 imm8 ymm xmm
func VEXTRACTF32X4(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM128(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM128(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VEXTRACTF32X4: bad operands")
}

// VEXTRACTF32X4_Z: Extract 128 Bits of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VEXTRACTF32X4.Z imm8 zmm k m128
// 	VEXTRACTF32X4.Z imm8 zmm k xmm
// 	VEXTRACTF32X4.Z imm8 ymm k m128
// 	VEXTRACTF32X4.Z imm8 ymm k xmm
func VEXTRACTF32X4_Z(i, yz, k, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsM128(mx),
		operand.IsIMM8(i) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, yz, k, mx},
			Inputs:   []operand.Op{yz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsM128(mx),
		operand.IsIMM8(i) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, yz, k, mx},
			Inputs:   []operand.Op{yz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VEXTRACTF32X4_Z: bad operands")
}

// VEXTRACTF32X8: Extract 256 Bits of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VEXTRACTF32X8 imm8 zmm k m256
// 	VEXTRACTF32X8 imm8 zmm k ymm
// 	VEXTRACTF32X8 imm8 zmm m256
// 	VEXTRACTF32X8 imm8 zmm ymm
func VEXTRACTF32X8(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM256(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF32X8",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF32X8",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VEXTRACTF32X8: bad operands")
}

// VEXTRACTF32X8_Z: Extract 256 Bits of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VEXTRACTF32X8.Z imm8 zmm k m256
// 	VEXTRACTF32X8.Z imm8 zmm k ymm
func VEXTRACTF32X8_Z(i, z, k, my operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsK(k) && operand.IsM256(my),
		operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(my):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF32X8",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, z, k, my},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{my},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VEXTRACTF32X8_Z: bad operands")
}

// VEXTRACTF64X2: Extract 128 Bits of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VEXTRACTF64X2 imm8 zmm k m128
// 	VEXTRACTF64X2 imm8 zmm k xmm
// 	VEXTRACTF64X2 imm8 zmm m128
// 	VEXTRACTF64X2 imm8 zmm xmm
// 	VEXTRACTF64X2 imm8 ymm k m128
// 	VEXTRACTF64X2 imm8 ymm k xmm
// 	VEXTRACTF64X2 imm8 ymm m128
// 	VEXTRACTF64X2 imm8 ymm xmm
func VEXTRACTF64X2(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM128(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM128(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VEXTRACTF64X2: bad operands")
}

// VEXTRACTF64X2_Z: Extract 128 Bits of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VEXTRACTF64X2.Z imm8 zmm k m128
// 	VEXTRACTF64X2.Z imm8 zmm k xmm
// 	VEXTRACTF64X2.Z imm8 ymm k m128
// 	VEXTRACTF64X2.Z imm8 ymm k xmm
func VEXTRACTF64X2_Z(i, yz, k, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsM128(mx),
		operand.IsIMM8(i) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, yz, k, mx},
			Inputs:   []operand.Op{yz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsIMM8(i) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsM128(mx),
		operand.IsIMM8(i) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, yz, k, mx},
			Inputs:   []operand.Op{yz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VEXTRACTF64X2_Z: bad operands")
}

// VEXTRACTF64X4: Extract 256 Bits of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VEXTRACTF64X4 imm8 zmm k m256
// 	VEXTRACTF64X4 imm8 zmm k ymm
// 	VEXTRACTF64X4 imm8 zmm m256
// 	VEXTRACTF64X4 imm8 zmm ymm
func VEXTRACTF64X4(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM256(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF64X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF64X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VEXTRACTF64X4: bad operands")
}

// VEXTRACTF64X4_Z: Extract 256 Bits of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VEXTRACTF64X4.Z imm8 zmm k m256
// 	VEXTRACTF64X4.Z imm8 zmm k ymm
func VEXTRACTF64X4_Z(i, z, k, my operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsK(k) && operand.IsM256(my),
		operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(my):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTF64X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, z, k, my},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{my},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VEXTRACTF64X4_Z: bad operands")
}

// VEXTRACTI128: Extract Packed Integer Values.
//
// Forms:
//
// 	VEXTRACTI128 imm8 ymm m128
// 	VEXTRACTI128 imm8 ymm xmm
func VEXTRACTI128(i, y, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsYMM(y) && operand.IsM128(mx),
		operand.IsIMM8(i) && operand.IsYMM(y) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI128",
			Operands: []operand.Op{i, y, mx},
			Inputs:   []operand.Op{y},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VEXTRACTI128: bad operands")
}

// VEXTRACTI32X4: Extract 128 Bits of Packed Doubleword Integer Values.
//
// Forms:
//
// 	VEXTRACTI32X4 imm8 zmm k m128
// 	VEXTRACTI32X4 imm8 zmm k xmm
// 	VEXTRACTI32X4 imm8 zmm m128
// 	VEXTRACTI32X4 imm8 zmm xmm
// 	VEXTRACTI32X4 imm8 ymm k m128
// 	VEXTRACTI32X4 imm8 ymm k xmm
// 	VEXTRACTI32X4 imm8 ymm m128
// 	VEXTRACTI32X4 imm8 ymm xmm
func VEXTRACTI32X4(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM128(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM128(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VEXTRACTI32X4: bad operands")
}

// VEXTRACTI32X4_Z: Extract 128 Bits of Packed Doubleword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VEXTRACTI32X4.Z imm8 zmm k m128
// 	VEXTRACTI32X4.Z imm8 zmm k xmm
// 	VEXTRACTI32X4.Z imm8 ymm k m128
// 	VEXTRACTI32X4.Z imm8 ymm k xmm
func VEXTRACTI32X4_Z(i, yz, k, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsM128(mx),
		operand.IsIMM8(i) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, yz, k, mx},
			Inputs:   []operand.Op{yz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsM128(mx),
		operand.IsIMM8(i) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, yz, k, mx},
			Inputs:   []operand.Op{yz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VEXTRACTI32X4_Z: bad operands")
}

// VEXTRACTI32X8: Extract 256 Bits of Packed Doubleword Integer Values.
//
// Forms:
//
// 	VEXTRACTI32X8 imm8 zmm k m256
// 	VEXTRACTI32X8 imm8 zmm k ymm
// 	VEXTRACTI32X8 imm8 zmm m256
// 	VEXTRACTI32X8 imm8 zmm ymm
func VEXTRACTI32X8(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM256(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI32X8",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI32X8",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VEXTRACTI32X8: bad operands")
}

// VEXTRACTI32X8_Z: Extract 256 Bits of Packed Doubleword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VEXTRACTI32X8.Z imm8 zmm k m256
// 	VEXTRACTI32X8.Z imm8 zmm k ymm
func VEXTRACTI32X8_Z(i, z, k, my operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsK(k) && operand.IsM256(my),
		operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(my):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI32X8",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, z, k, my},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{my},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VEXTRACTI32X8_Z: bad operands")
}

// VEXTRACTI64X2: Extract 128 Bits of Packed Quadword Integer Values.
//
// Forms:
//
// 	VEXTRACTI64X2 imm8 zmm k m128
// 	VEXTRACTI64X2 imm8 zmm k xmm
// 	VEXTRACTI64X2 imm8 zmm m128
// 	VEXTRACTI64X2 imm8 zmm xmm
// 	VEXTRACTI64X2 imm8 ymm k m128
// 	VEXTRACTI64X2 imm8 ymm k xmm
// 	VEXTRACTI64X2 imm8 ymm m128
// 	VEXTRACTI64X2 imm8 ymm xmm
func VEXTRACTI64X2(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM128(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM128(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VEXTRACTI64X2: bad operands")
}

// VEXTRACTI64X2_Z: Extract 128 Bits of Packed Quadword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VEXTRACTI64X2.Z imm8 zmm k m128
// 	VEXTRACTI64X2.Z imm8 zmm k xmm
// 	VEXTRACTI64X2.Z imm8 ymm k m128
// 	VEXTRACTI64X2.Z imm8 ymm k xmm
func VEXTRACTI64X2_Z(i, yz, k, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsM128(mx),
		operand.IsIMM8(i) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, yz, k, mx},
			Inputs:   []operand.Op{yz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsIMM8(i) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsM128(mx),
		operand.IsIMM8(i) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, yz, k, mx},
			Inputs:   []operand.Op{yz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VEXTRACTI64X2_Z: bad operands")
}

// VEXTRACTI64X4: Extract 256 Bits of Packed Quadword Integer Values.
//
// Forms:
//
// 	VEXTRACTI64X4 imm8 zmm k m256
// 	VEXTRACTI64X4 imm8 zmm k ymm
// 	VEXTRACTI64X4 imm8 zmm m256
// 	VEXTRACTI64X4 imm8 zmm ymm
func VEXTRACTI64X4(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsM256(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI64X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI64X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VEXTRACTI64X4: bad operands")
}

// VEXTRACTI64X4_Z: Extract 256 Bits of Packed Quadword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VEXTRACTI64X4.Z imm8 zmm k m256
// 	VEXTRACTI64X4.Z imm8 zmm k ymm
func VEXTRACTI64X4_Z(i, z, k, my operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsK(k) && operand.IsM256(my),
		operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsK(k) && operand.IsYMM(my):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTI64X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, z, k, my},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{my},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VEXTRACTI64X4_Z: bad operands")
}

// VEXTRACTPS: Extract Packed Single Precision Floating-Point Value.
//
// Forms:
//
// 	VEXTRACTPS imm8 xmm m32
// 	VEXTRACTPS imm8 xmm r32
func VEXTRACTPS(i, x, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsM32(mr),
		operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "VEXTRACTPS",
			Operands: []operand.Op{i, x, mr},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{mr},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VEXTRACTPS: bad operands")
}

// VFIXUPIMMPD: Fix Up Special Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFIXUPIMMPD imm8 m512 zmm k zmm
// 	VFIXUPIMMPD imm8 m512 zmm zmm
// 	VFIXUPIMMPD imm8 zmm  zmm k zmm
// 	VFIXUPIMMPD imm8 zmm  zmm zmm
// 	VFIXUPIMMPD imm8 m128 xmm k xmm
// 	VFIXUPIMMPD imm8 m128 xmm xmm
// 	VFIXUPIMMPD imm8 m256 ymm k ymm
// 	VFIXUPIMMPD imm8 m256 ymm ymm
// 	VFIXUPIMMPD imm8 xmm  xmm k xmm
// 	VFIXUPIMMPD imm8 xmm  xmm xmm
// 	VFIXUPIMMPD imm8 ymm  ymm k ymm
// 	VFIXUPIMMPD imm8 ymm  ymm ymm
func VFIXUPIMMPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMPD: bad operands")
}

// VFIXUPIMMPD_BCST: Fix Up Special Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFIXUPIMMPD.BCST imm8 m64 zmm k zmm
// 	VFIXUPIMMPD.BCST imm8 m64 zmm zmm
// 	VFIXUPIMMPD.BCST imm8 m64 xmm k xmm
// 	VFIXUPIMMPD.BCST imm8 m64 xmm xmm
// 	VFIXUPIMMPD.BCST imm8 m64 ymm k ymm
// 	VFIXUPIMMPD.BCST imm8 m64 ymm ymm
func VFIXUPIMMPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMPD_BCST: bad operands")
}

// VFIXUPIMMPD_BCST_Z: Fix Up Special Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFIXUPIMMPD.BCST.Z imm8 m64 zmm k zmm
// 	VFIXUPIMMPD.BCST.Z imm8 m64 xmm k xmm
// 	VFIXUPIMMPD.BCST.Z imm8 m64 ymm k ymm
func VFIXUPIMMPD_BCST_Z(i, m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMPD_BCST_Z: bad operands")
}

// VFIXUPIMMPD_SAE: Fix Up Special Packed Double-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VFIXUPIMMPD.SAE imm8 zmm zmm k zmm
// 	VFIXUPIMMPD.SAE imm8 zmm zmm zmm
func VFIXUPIMMPD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMPD_SAE: bad operands")
}

// VFIXUPIMMPD_SAE_Z: Fix Up Special Packed Double-Precision Floating-Point Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VFIXUPIMMPD.SAE.Z imm8 zmm zmm k zmm
func VFIXUPIMMPD_SAE_Z(i, z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMPD_SAE_Z: bad operands")
}

// VFIXUPIMMPD_Z: Fix Up Special Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFIXUPIMMPD.Z imm8 m512 zmm k zmm
// 	VFIXUPIMMPD.Z imm8 zmm  zmm k zmm
// 	VFIXUPIMMPD.Z imm8 m128 xmm k xmm
// 	VFIXUPIMMPD.Z imm8 m256 ymm k ymm
// 	VFIXUPIMMPD.Z imm8 xmm  xmm k xmm
// 	VFIXUPIMMPD.Z imm8 ymm  ymm k ymm
func VFIXUPIMMPD_Z(i, mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMPD_Z: bad operands")
}

// VFIXUPIMMPS: Fix Up Special Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFIXUPIMMPS imm8 m512 zmm k zmm
// 	VFIXUPIMMPS imm8 m512 zmm zmm
// 	VFIXUPIMMPS imm8 zmm  zmm k zmm
// 	VFIXUPIMMPS imm8 zmm  zmm zmm
// 	VFIXUPIMMPS imm8 m256 ymm k ymm
// 	VFIXUPIMMPS imm8 m256 ymm ymm
// 	VFIXUPIMMPS imm8 ymm  ymm k ymm
// 	VFIXUPIMMPS imm8 ymm  ymm ymm
// 	VFIXUPIMMPS imm8 m128 xmm k xmm
// 	VFIXUPIMMPS imm8 m128 xmm xmm
// 	VFIXUPIMMPS imm8 xmm  xmm k xmm
// 	VFIXUPIMMPS imm8 xmm  xmm xmm
func VFIXUPIMMPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMPS: bad operands")
}

// VFIXUPIMMPS_BCST: Fix Up Special Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFIXUPIMMPS.BCST imm8 m32 zmm k zmm
// 	VFIXUPIMMPS.BCST imm8 m32 zmm zmm
// 	VFIXUPIMMPS.BCST imm8 m32 ymm k ymm
// 	VFIXUPIMMPS.BCST imm8 m32 ymm ymm
// 	VFIXUPIMMPS.BCST imm8 m32 xmm k xmm
// 	VFIXUPIMMPS.BCST imm8 m32 xmm xmm
func VFIXUPIMMPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMPS_BCST: bad operands")
}

// VFIXUPIMMPS_BCST_Z: Fix Up Special Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFIXUPIMMPS.BCST.Z imm8 m32 zmm k zmm
// 	VFIXUPIMMPS.BCST.Z imm8 m32 ymm k ymm
// 	VFIXUPIMMPS.BCST.Z imm8 m32 xmm k xmm
func VFIXUPIMMPS_BCST_Z(i, m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMPS_BCST_Z: bad operands")
}

// VFIXUPIMMPS_SAE: Fix Up Special Packed Single-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VFIXUPIMMPS.SAE imm8 zmm zmm k zmm
// 	VFIXUPIMMPS.SAE imm8 zmm zmm zmm
func VFIXUPIMMPS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMPS_SAE: bad operands")
}

// VFIXUPIMMPS_SAE_Z: Fix Up Special Packed Single-Precision Floating-Point Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VFIXUPIMMPS.SAE.Z imm8 zmm zmm k zmm
func VFIXUPIMMPS_SAE_Z(i, z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMPS_SAE_Z: bad operands")
}

// VFIXUPIMMPS_Z: Fix Up Special Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFIXUPIMMPS.Z imm8 m512 zmm k zmm
// 	VFIXUPIMMPS.Z imm8 zmm  zmm k zmm
// 	VFIXUPIMMPS.Z imm8 m256 ymm k ymm
// 	VFIXUPIMMPS.Z imm8 ymm  ymm k ymm
// 	VFIXUPIMMPS.Z imm8 m128 xmm k xmm
// 	VFIXUPIMMPS.Z imm8 xmm  xmm k xmm
func VFIXUPIMMPS_Z(i, mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMPS_Z: bad operands")
}

// VFIXUPIMMSD: Fix Up Special Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VFIXUPIMMSD imm8 m64 xmm k xmm
// 	VFIXUPIMMSD imm8 m64 xmm xmm
// 	VFIXUPIMMSD imm8 xmm xmm k xmm
// 	VFIXUPIMMSD imm8 xmm xmm xmm
func VFIXUPIMMSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMSD: bad operands")
}

// VFIXUPIMMSD_SAE: Fix Up Special Scalar Double-Precision Floating-Point Value (Suppress All Exceptions).
//
// Forms:
//
// 	VFIXUPIMMSD.SAE imm8 xmm xmm k xmm
// 	VFIXUPIMMSD.SAE imm8 xmm xmm xmm
func VFIXUPIMMSD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMSD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMSD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMSD_SAE: bad operands")
}

// VFIXUPIMMSD_SAE_Z: Fix Up Special Scalar Double-Precision Floating-Point Value (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VFIXUPIMMSD.SAE.Z imm8 xmm xmm k xmm
func VFIXUPIMMSD_SAE_Z(i, x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMSD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMSD_SAE_Z: bad operands")
}

// VFIXUPIMMSD_Z: Fix Up Special Scalar Double-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VFIXUPIMMSD.Z imm8 m64 xmm k xmm
// 	VFIXUPIMMSD.Z imm8 xmm xmm k xmm
func VFIXUPIMMSD_Z(i, mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMSD_Z: bad operands")
}

// VFIXUPIMMSS: Fix Up Special Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	VFIXUPIMMSS imm8 m32 xmm k xmm
// 	VFIXUPIMMSS imm8 m32 xmm xmm
// 	VFIXUPIMMSS imm8 xmm xmm k xmm
// 	VFIXUPIMMSS imm8 xmm xmm xmm
func VFIXUPIMMSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMSS: bad operands")
}

// VFIXUPIMMSS_SAE: Fix Up Special Scalar Single-Precision Floating-Point Value (Suppress All Exceptions).
//
// Forms:
//
// 	VFIXUPIMMSS.SAE imm8 xmm xmm k xmm
// 	VFIXUPIMMSS.SAE imm8 xmm xmm xmm
func VFIXUPIMMSS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMSS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMSS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMSS_SAE: bad operands")
}

// VFIXUPIMMSS_SAE_Z: Fix Up Special Scalar Single-Precision Floating-Point Value (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VFIXUPIMMSS.SAE.Z imm8 xmm xmm k xmm
func VFIXUPIMMSS_SAE_Z(i, x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMSS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMSS_SAE_Z: bad operands")
}

// VFIXUPIMMSS_Z: Fix Up Special Scalar Single-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VFIXUPIMMSS.Z imm8 m32 xmm k xmm
// 	VFIXUPIMMSS.Z imm8 xmm xmm k xmm
func VFIXUPIMMSS_Z(i, mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFIXUPIMMSS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFIXUPIMMSS_Z: bad operands")
}

// VFMADD132PD: Fused Multiply-Add of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADD132PD m128 xmm xmm
// 	VFMADD132PD m256 ymm ymm
// 	VFMADD132PD xmm  xmm xmm
// 	VFMADD132PD ymm  ymm ymm
// 	VFMADD132PD m512 zmm k zmm
// 	VFMADD132PD m512 zmm zmm
// 	VFMADD132PD zmm  zmm k zmm
// 	VFMADD132PD zmm  zmm zmm
// 	VFMADD132PD m128 xmm k xmm
// 	VFMADD132PD m256 ymm k ymm
// 	VFMADD132PD xmm  xmm k xmm
// 	VFMADD132PD ymm  ymm k ymm
func VFMADD132PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADD132PD: bad operands")
}

// VFMADD132PD_BCST: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMADD132PD.BCST m64 zmm k zmm
// 	VFMADD132PD.BCST m64 zmm zmm
// 	VFMADD132PD.BCST m64 xmm k xmm
// 	VFMADD132PD.BCST m64 xmm xmm
// 	VFMADD132PD.BCST m64 ymm k ymm
// 	VFMADD132PD.BCST m64 ymm ymm
func VFMADD132PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PD_BCST: bad operands")
}

// VFMADD132PD_BCST_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132PD.BCST.Z m64 zmm k zmm
// 	VFMADD132PD.BCST.Z m64 xmm k xmm
// 	VFMADD132PD.BCST.Z m64 ymm k ymm
func VFMADD132PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PD_BCST_Z: bad operands")
}

// VFMADD132PD_RD_SAE: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADD132PD.RD_SAE zmm zmm k zmm
// 	VFMADD132PD.RD_SAE zmm zmm zmm
func VFMADD132PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PD_RD_SAE: bad operands")
}

// VFMADD132PD_RD_SAE_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132PD.RD_SAE.Z zmm zmm k zmm
func VFMADD132PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PD_RD_SAE_Z: bad operands")
}

// VFMADD132PD_RN_SAE: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADD132PD.RN_SAE zmm zmm k zmm
// 	VFMADD132PD.RN_SAE zmm zmm zmm
func VFMADD132PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PD_RN_SAE: bad operands")
}

// VFMADD132PD_RN_SAE_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132PD.RN_SAE.Z zmm zmm k zmm
func VFMADD132PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PD_RN_SAE_Z: bad operands")
}

// VFMADD132PD_RU_SAE: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADD132PD.RU_SAE zmm zmm k zmm
// 	VFMADD132PD.RU_SAE zmm zmm zmm
func VFMADD132PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PD_RU_SAE: bad operands")
}

// VFMADD132PD_RU_SAE_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132PD.RU_SAE.Z zmm zmm k zmm
func VFMADD132PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PD_RU_SAE_Z: bad operands")
}

// VFMADD132PD_RZ_SAE: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADD132PD.RZ_SAE zmm zmm k zmm
// 	VFMADD132PD.RZ_SAE zmm zmm zmm
func VFMADD132PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PD_RZ_SAE: bad operands")
}

// VFMADD132PD_RZ_SAE_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132PD.RZ_SAE.Z zmm zmm k zmm
func VFMADD132PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PD_RZ_SAE_Z: bad operands")
}

// VFMADD132PD_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADD132PD.Z m512 zmm k zmm
// 	VFMADD132PD.Z zmm  zmm k zmm
// 	VFMADD132PD.Z m128 xmm k xmm
// 	VFMADD132PD.Z m256 ymm k ymm
// 	VFMADD132PD.Z xmm  xmm k xmm
// 	VFMADD132PD.Z ymm  ymm k ymm
func VFMADD132PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PD_Z: bad operands")
}

// VFMADD132PS: Fused Multiply-Add of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADD132PS m128 xmm xmm
// 	VFMADD132PS m256 ymm ymm
// 	VFMADD132PS xmm  xmm xmm
// 	VFMADD132PS ymm  ymm ymm
// 	VFMADD132PS m512 zmm k zmm
// 	VFMADD132PS m512 zmm zmm
// 	VFMADD132PS zmm  zmm k zmm
// 	VFMADD132PS zmm  zmm zmm
// 	VFMADD132PS m128 xmm k xmm
// 	VFMADD132PS m256 ymm k ymm
// 	VFMADD132PS xmm  xmm k xmm
// 	VFMADD132PS ymm  ymm k ymm
func VFMADD132PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADD132PS: bad operands")
}

// VFMADD132PS_BCST: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMADD132PS.BCST m32 zmm k zmm
// 	VFMADD132PS.BCST m32 zmm zmm
// 	VFMADD132PS.BCST m32 xmm k xmm
// 	VFMADD132PS.BCST m32 xmm xmm
// 	VFMADD132PS.BCST m32 ymm k ymm
// 	VFMADD132PS.BCST m32 ymm ymm
func VFMADD132PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PS_BCST: bad operands")
}

// VFMADD132PS_BCST_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132PS.BCST.Z m32 zmm k zmm
// 	VFMADD132PS.BCST.Z m32 xmm k xmm
// 	VFMADD132PS.BCST.Z m32 ymm k ymm
func VFMADD132PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PS_BCST_Z: bad operands")
}

// VFMADD132PS_RD_SAE: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADD132PS.RD_SAE zmm zmm k zmm
// 	VFMADD132PS.RD_SAE zmm zmm zmm
func VFMADD132PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PS_RD_SAE: bad operands")
}

// VFMADD132PS_RD_SAE_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132PS.RD_SAE.Z zmm zmm k zmm
func VFMADD132PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PS_RD_SAE_Z: bad operands")
}

// VFMADD132PS_RN_SAE: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADD132PS.RN_SAE zmm zmm k zmm
// 	VFMADD132PS.RN_SAE zmm zmm zmm
func VFMADD132PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PS_RN_SAE: bad operands")
}

// VFMADD132PS_RN_SAE_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132PS.RN_SAE.Z zmm zmm k zmm
func VFMADD132PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PS_RN_SAE_Z: bad operands")
}

// VFMADD132PS_RU_SAE: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADD132PS.RU_SAE zmm zmm k zmm
// 	VFMADD132PS.RU_SAE zmm zmm zmm
func VFMADD132PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PS_RU_SAE: bad operands")
}

// VFMADD132PS_RU_SAE_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132PS.RU_SAE.Z zmm zmm k zmm
func VFMADD132PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PS_RU_SAE_Z: bad operands")
}

// VFMADD132PS_RZ_SAE: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADD132PS.RZ_SAE zmm zmm k zmm
// 	VFMADD132PS.RZ_SAE zmm zmm zmm
func VFMADD132PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PS_RZ_SAE: bad operands")
}

// VFMADD132PS_RZ_SAE_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132PS.RZ_SAE.Z zmm zmm k zmm
func VFMADD132PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PS_RZ_SAE_Z: bad operands")
}

// VFMADD132PS_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADD132PS.Z m512 zmm k zmm
// 	VFMADD132PS.Z zmm  zmm k zmm
// 	VFMADD132PS.Z m128 xmm k xmm
// 	VFMADD132PS.Z m256 ymm k ymm
// 	VFMADD132PS.Z xmm  xmm k xmm
// 	VFMADD132PS.Z ymm  ymm k ymm
func VFMADD132PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD132PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132PS_Z: bad operands")
}

// VFMADD132SD: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADD132SD m64 xmm xmm
// 	VFMADD132SD xmm xmm xmm
// 	VFMADD132SD m64 xmm k xmm
// 	VFMADD132SD xmm xmm k xmm
func VFMADD132SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADD132SD: bad operands")
}

// VFMADD132SD_RD_SAE: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADD132SD.RD_SAE xmm xmm k xmm
// 	VFMADD132SD.RD_SAE xmm xmm xmm
func VFMADD132SD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SD_RD_SAE: bad operands")
}

// VFMADD132SD_RD_SAE_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132SD.RD_SAE.Z xmm xmm k xmm
func VFMADD132SD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SD_RD_SAE_Z: bad operands")
}

// VFMADD132SD_RN_SAE: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADD132SD.RN_SAE xmm xmm k xmm
// 	VFMADD132SD.RN_SAE xmm xmm xmm
func VFMADD132SD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SD_RN_SAE: bad operands")
}

// VFMADD132SD_RN_SAE_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132SD.RN_SAE.Z xmm xmm k xmm
func VFMADD132SD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SD_RN_SAE_Z: bad operands")
}

// VFMADD132SD_RU_SAE: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADD132SD.RU_SAE xmm xmm k xmm
// 	VFMADD132SD.RU_SAE xmm xmm xmm
func VFMADD132SD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SD_RU_SAE: bad operands")
}

// VFMADD132SD_RU_SAE_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132SD.RU_SAE.Z xmm xmm k xmm
func VFMADD132SD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SD_RU_SAE_Z: bad operands")
}

// VFMADD132SD_RZ_SAE: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADD132SD.RZ_SAE xmm xmm k xmm
// 	VFMADD132SD.RZ_SAE xmm xmm xmm
func VFMADD132SD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SD_RZ_SAE: bad operands")
}

// VFMADD132SD_RZ_SAE_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132SD.RZ_SAE.Z xmm xmm k xmm
func VFMADD132SD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SD_RZ_SAE_Z: bad operands")
}

// VFMADD132SD_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADD132SD.Z m64 xmm k xmm
// 	VFMADD132SD.Z xmm xmm k xmm
func VFMADD132SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SD_Z: bad operands")
}

// VFMADD132SS: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADD132SS m32 xmm xmm
// 	VFMADD132SS xmm xmm xmm
// 	VFMADD132SS m32 xmm k xmm
// 	VFMADD132SS xmm xmm k xmm
func VFMADD132SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADD132SS: bad operands")
}

// VFMADD132SS_RD_SAE: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADD132SS.RD_SAE xmm xmm k xmm
// 	VFMADD132SS.RD_SAE xmm xmm xmm
func VFMADD132SS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SS_RD_SAE: bad operands")
}

// VFMADD132SS_RD_SAE_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132SS.RD_SAE.Z xmm xmm k xmm
func VFMADD132SS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SS_RD_SAE_Z: bad operands")
}

// VFMADD132SS_RN_SAE: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADD132SS.RN_SAE xmm xmm k xmm
// 	VFMADD132SS.RN_SAE xmm xmm xmm
func VFMADD132SS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SS_RN_SAE: bad operands")
}

// VFMADD132SS_RN_SAE_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132SS.RN_SAE.Z xmm xmm k xmm
func VFMADD132SS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SS_RN_SAE_Z: bad operands")
}

// VFMADD132SS_RU_SAE: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADD132SS.RU_SAE xmm xmm k xmm
// 	VFMADD132SS.RU_SAE xmm xmm xmm
func VFMADD132SS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SS_RU_SAE: bad operands")
}

// VFMADD132SS_RU_SAE_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132SS.RU_SAE.Z xmm xmm k xmm
func VFMADD132SS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SS_RU_SAE_Z: bad operands")
}

// VFMADD132SS_RZ_SAE: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADD132SS.RZ_SAE xmm xmm k xmm
// 	VFMADD132SS.RZ_SAE xmm xmm xmm
func VFMADD132SS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SS_RZ_SAE: bad operands")
}

// VFMADD132SS_RZ_SAE_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADD132SS.RZ_SAE.Z xmm xmm k xmm
func VFMADD132SS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SS_RZ_SAE_Z: bad operands")
}

// VFMADD132SS_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADD132SS.Z m32 xmm k xmm
// 	VFMADD132SS.Z xmm xmm k xmm
func VFMADD132SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFMADD132SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD132SS_Z: bad operands")
}

// VFMADD213PD: Fused Multiply-Add of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADD213PD m128 xmm xmm
// 	VFMADD213PD m256 ymm ymm
// 	VFMADD213PD xmm  xmm xmm
// 	VFMADD213PD ymm  ymm ymm
// 	VFMADD213PD m512 zmm k zmm
// 	VFMADD213PD m512 zmm zmm
// 	VFMADD213PD zmm  zmm k zmm
// 	VFMADD213PD zmm  zmm zmm
// 	VFMADD213PD m128 xmm k xmm
// 	VFMADD213PD m256 ymm k ymm
// 	VFMADD213PD xmm  xmm k xmm
// 	VFMADD213PD ymm  ymm k ymm
func VFMADD213PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADD213PD: bad operands")
}

// VFMADD213PD_BCST: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMADD213PD.BCST m64 zmm k zmm
// 	VFMADD213PD.BCST m64 zmm zmm
// 	VFMADD213PD.BCST m64 xmm k xmm
// 	VFMADD213PD.BCST m64 xmm xmm
// 	VFMADD213PD.BCST m64 ymm k ymm
// 	VFMADD213PD.BCST m64 ymm ymm
func VFMADD213PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PD_BCST: bad operands")
}

// VFMADD213PD_BCST_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213PD.BCST.Z m64 zmm k zmm
// 	VFMADD213PD.BCST.Z m64 xmm k xmm
// 	VFMADD213PD.BCST.Z m64 ymm k ymm
func VFMADD213PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PD_BCST_Z: bad operands")
}

// VFMADD213PD_RD_SAE: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADD213PD.RD_SAE zmm zmm k zmm
// 	VFMADD213PD.RD_SAE zmm zmm zmm
func VFMADD213PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PD_RD_SAE: bad operands")
}

// VFMADD213PD_RD_SAE_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213PD.RD_SAE.Z zmm zmm k zmm
func VFMADD213PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PD_RD_SAE_Z: bad operands")
}

// VFMADD213PD_RN_SAE: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADD213PD.RN_SAE zmm zmm k zmm
// 	VFMADD213PD.RN_SAE zmm zmm zmm
func VFMADD213PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PD_RN_SAE: bad operands")
}

// VFMADD213PD_RN_SAE_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213PD.RN_SAE.Z zmm zmm k zmm
func VFMADD213PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PD_RN_SAE_Z: bad operands")
}

// VFMADD213PD_RU_SAE: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADD213PD.RU_SAE zmm zmm k zmm
// 	VFMADD213PD.RU_SAE zmm zmm zmm
func VFMADD213PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PD_RU_SAE: bad operands")
}

// VFMADD213PD_RU_SAE_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213PD.RU_SAE.Z zmm zmm k zmm
func VFMADD213PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PD_RU_SAE_Z: bad operands")
}

// VFMADD213PD_RZ_SAE: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADD213PD.RZ_SAE zmm zmm k zmm
// 	VFMADD213PD.RZ_SAE zmm zmm zmm
func VFMADD213PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PD_RZ_SAE: bad operands")
}

// VFMADD213PD_RZ_SAE_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213PD.RZ_SAE.Z zmm zmm k zmm
func VFMADD213PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PD_RZ_SAE_Z: bad operands")
}

// VFMADD213PD_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADD213PD.Z m512 zmm k zmm
// 	VFMADD213PD.Z zmm  zmm k zmm
// 	VFMADD213PD.Z m128 xmm k xmm
// 	VFMADD213PD.Z m256 ymm k ymm
// 	VFMADD213PD.Z xmm  xmm k xmm
// 	VFMADD213PD.Z ymm  ymm k ymm
func VFMADD213PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PD_Z: bad operands")
}

// VFMADD213PS: Fused Multiply-Add of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADD213PS m128 xmm xmm
// 	VFMADD213PS m256 ymm ymm
// 	VFMADD213PS xmm  xmm xmm
// 	VFMADD213PS ymm  ymm ymm
// 	VFMADD213PS m512 zmm k zmm
// 	VFMADD213PS m512 zmm zmm
// 	VFMADD213PS zmm  zmm k zmm
// 	VFMADD213PS zmm  zmm zmm
// 	VFMADD213PS m128 xmm k xmm
// 	VFMADD213PS m256 ymm k ymm
// 	VFMADD213PS xmm  xmm k xmm
// 	VFMADD213PS ymm  ymm k ymm
func VFMADD213PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADD213PS: bad operands")
}

// VFMADD213PS_BCST: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMADD213PS.BCST m32 zmm k zmm
// 	VFMADD213PS.BCST m32 zmm zmm
// 	VFMADD213PS.BCST m32 xmm k xmm
// 	VFMADD213PS.BCST m32 xmm xmm
// 	VFMADD213PS.BCST m32 ymm k ymm
// 	VFMADD213PS.BCST m32 ymm ymm
func VFMADD213PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PS_BCST: bad operands")
}

// VFMADD213PS_BCST_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213PS.BCST.Z m32 zmm k zmm
// 	VFMADD213PS.BCST.Z m32 xmm k xmm
// 	VFMADD213PS.BCST.Z m32 ymm k ymm
func VFMADD213PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PS_BCST_Z: bad operands")
}

// VFMADD213PS_RD_SAE: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADD213PS.RD_SAE zmm zmm k zmm
// 	VFMADD213PS.RD_SAE zmm zmm zmm
func VFMADD213PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PS_RD_SAE: bad operands")
}

// VFMADD213PS_RD_SAE_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213PS.RD_SAE.Z zmm zmm k zmm
func VFMADD213PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PS_RD_SAE_Z: bad operands")
}

// VFMADD213PS_RN_SAE: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADD213PS.RN_SAE zmm zmm k zmm
// 	VFMADD213PS.RN_SAE zmm zmm zmm
func VFMADD213PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PS_RN_SAE: bad operands")
}

// VFMADD213PS_RN_SAE_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213PS.RN_SAE.Z zmm zmm k zmm
func VFMADD213PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PS_RN_SAE_Z: bad operands")
}

// VFMADD213PS_RU_SAE: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADD213PS.RU_SAE zmm zmm k zmm
// 	VFMADD213PS.RU_SAE zmm zmm zmm
func VFMADD213PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PS_RU_SAE: bad operands")
}

// VFMADD213PS_RU_SAE_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213PS.RU_SAE.Z zmm zmm k zmm
func VFMADD213PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PS_RU_SAE_Z: bad operands")
}

// VFMADD213PS_RZ_SAE: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADD213PS.RZ_SAE zmm zmm k zmm
// 	VFMADD213PS.RZ_SAE zmm zmm zmm
func VFMADD213PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PS_RZ_SAE: bad operands")
}

// VFMADD213PS_RZ_SAE_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213PS.RZ_SAE.Z zmm zmm k zmm
func VFMADD213PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PS_RZ_SAE_Z: bad operands")
}

// VFMADD213PS_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADD213PS.Z m512 zmm k zmm
// 	VFMADD213PS.Z zmm  zmm k zmm
// 	VFMADD213PS.Z m128 xmm k xmm
// 	VFMADD213PS.Z m256 ymm k ymm
// 	VFMADD213PS.Z xmm  xmm k xmm
// 	VFMADD213PS.Z ymm  ymm k ymm
func VFMADD213PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD213PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213PS_Z: bad operands")
}

// VFMADD213SD: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADD213SD m64 xmm xmm
// 	VFMADD213SD xmm xmm xmm
// 	VFMADD213SD m64 xmm k xmm
// 	VFMADD213SD xmm xmm k xmm
func VFMADD213SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADD213SD: bad operands")
}

// VFMADD213SD_RD_SAE: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADD213SD.RD_SAE xmm xmm k xmm
// 	VFMADD213SD.RD_SAE xmm xmm xmm
func VFMADD213SD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SD_RD_SAE: bad operands")
}

// VFMADD213SD_RD_SAE_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213SD.RD_SAE.Z xmm xmm k xmm
func VFMADD213SD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SD_RD_SAE_Z: bad operands")
}

// VFMADD213SD_RN_SAE: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADD213SD.RN_SAE xmm xmm k xmm
// 	VFMADD213SD.RN_SAE xmm xmm xmm
func VFMADD213SD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SD_RN_SAE: bad operands")
}

// VFMADD213SD_RN_SAE_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213SD.RN_SAE.Z xmm xmm k xmm
func VFMADD213SD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SD_RN_SAE_Z: bad operands")
}

// VFMADD213SD_RU_SAE: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADD213SD.RU_SAE xmm xmm k xmm
// 	VFMADD213SD.RU_SAE xmm xmm xmm
func VFMADD213SD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SD_RU_SAE: bad operands")
}

// VFMADD213SD_RU_SAE_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213SD.RU_SAE.Z xmm xmm k xmm
func VFMADD213SD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SD_RU_SAE_Z: bad operands")
}

// VFMADD213SD_RZ_SAE: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADD213SD.RZ_SAE xmm xmm k xmm
// 	VFMADD213SD.RZ_SAE xmm xmm xmm
func VFMADD213SD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SD_RZ_SAE: bad operands")
}

// VFMADD213SD_RZ_SAE_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213SD.RZ_SAE.Z xmm xmm k xmm
func VFMADD213SD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SD_RZ_SAE_Z: bad operands")
}

// VFMADD213SD_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADD213SD.Z m64 xmm k xmm
// 	VFMADD213SD.Z xmm xmm k xmm
func VFMADD213SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SD_Z: bad operands")
}

// VFMADD213SS: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADD213SS m32 xmm xmm
// 	VFMADD213SS xmm xmm xmm
// 	VFMADD213SS m32 xmm k xmm
// 	VFMADD213SS xmm xmm k xmm
func VFMADD213SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADD213SS: bad operands")
}

// VFMADD213SS_RD_SAE: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADD213SS.RD_SAE xmm xmm k xmm
// 	VFMADD213SS.RD_SAE xmm xmm xmm
func VFMADD213SS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SS_RD_SAE: bad operands")
}

// VFMADD213SS_RD_SAE_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213SS.RD_SAE.Z xmm xmm k xmm
func VFMADD213SS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SS_RD_SAE_Z: bad operands")
}

// VFMADD213SS_RN_SAE: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADD213SS.RN_SAE xmm xmm k xmm
// 	VFMADD213SS.RN_SAE xmm xmm xmm
func VFMADD213SS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SS_RN_SAE: bad operands")
}

// VFMADD213SS_RN_SAE_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213SS.RN_SAE.Z xmm xmm k xmm
func VFMADD213SS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SS_RN_SAE_Z: bad operands")
}

// VFMADD213SS_RU_SAE: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADD213SS.RU_SAE xmm xmm k xmm
// 	VFMADD213SS.RU_SAE xmm xmm xmm
func VFMADD213SS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SS_RU_SAE: bad operands")
}

// VFMADD213SS_RU_SAE_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213SS.RU_SAE.Z xmm xmm k xmm
func VFMADD213SS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SS_RU_SAE_Z: bad operands")
}

// VFMADD213SS_RZ_SAE: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADD213SS.RZ_SAE xmm xmm k xmm
// 	VFMADD213SS.RZ_SAE xmm xmm xmm
func VFMADD213SS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SS_RZ_SAE: bad operands")
}

// VFMADD213SS_RZ_SAE_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADD213SS.RZ_SAE.Z xmm xmm k xmm
func VFMADD213SS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SS_RZ_SAE_Z: bad operands")
}

// VFMADD213SS_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADD213SS.Z m32 xmm k xmm
// 	VFMADD213SS.Z xmm xmm k xmm
func VFMADD213SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFMADD213SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD213SS_Z: bad operands")
}

// VFMADD231PD: Fused Multiply-Add of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADD231PD m128 xmm xmm
// 	VFMADD231PD m256 ymm ymm
// 	VFMADD231PD xmm  xmm xmm
// 	VFMADD231PD ymm  ymm ymm
// 	VFMADD231PD m512 zmm k zmm
// 	VFMADD231PD m512 zmm zmm
// 	VFMADD231PD zmm  zmm k zmm
// 	VFMADD231PD zmm  zmm zmm
// 	VFMADD231PD m128 xmm k xmm
// 	VFMADD231PD m256 ymm k ymm
// 	VFMADD231PD xmm  xmm k xmm
// 	VFMADD231PD ymm  ymm k ymm
func VFMADD231PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADD231PD: bad operands")
}

// VFMADD231PD_BCST: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMADD231PD.BCST m64 zmm k zmm
// 	VFMADD231PD.BCST m64 zmm zmm
// 	VFMADD231PD.BCST m64 xmm k xmm
// 	VFMADD231PD.BCST m64 xmm xmm
// 	VFMADD231PD.BCST m64 ymm k ymm
// 	VFMADD231PD.BCST m64 ymm ymm
func VFMADD231PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PD_BCST: bad operands")
}

// VFMADD231PD_BCST_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231PD.BCST.Z m64 zmm k zmm
// 	VFMADD231PD.BCST.Z m64 xmm k xmm
// 	VFMADD231PD.BCST.Z m64 ymm k ymm
func VFMADD231PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PD_BCST_Z: bad operands")
}

// VFMADD231PD_RD_SAE: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADD231PD.RD_SAE zmm zmm k zmm
// 	VFMADD231PD.RD_SAE zmm zmm zmm
func VFMADD231PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PD_RD_SAE: bad operands")
}

// VFMADD231PD_RD_SAE_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231PD.RD_SAE.Z zmm zmm k zmm
func VFMADD231PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PD_RD_SAE_Z: bad operands")
}

// VFMADD231PD_RN_SAE: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADD231PD.RN_SAE zmm zmm k zmm
// 	VFMADD231PD.RN_SAE zmm zmm zmm
func VFMADD231PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PD_RN_SAE: bad operands")
}

// VFMADD231PD_RN_SAE_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231PD.RN_SAE.Z zmm zmm k zmm
func VFMADD231PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PD_RN_SAE_Z: bad operands")
}

// VFMADD231PD_RU_SAE: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADD231PD.RU_SAE zmm zmm k zmm
// 	VFMADD231PD.RU_SAE zmm zmm zmm
func VFMADD231PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PD_RU_SAE: bad operands")
}

// VFMADD231PD_RU_SAE_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231PD.RU_SAE.Z zmm zmm k zmm
func VFMADD231PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PD_RU_SAE_Z: bad operands")
}

// VFMADD231PD_RZ_SAE: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADD231PD.RZ_SAE zmm zmm k zmm
// 	VFMADD231PD.RZ_SAE zmm zmm zmm
func VFMADD231PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PD_RZ_SAE: bad operands")
}

// VFMADD231PD_RZ_SAE_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231PD.RZ_SAE.Z zmm zmm k zmm
func VFMADD231PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PD_RZ_SAE_Z: bad operands")
}

// VFMADD231PD_Z: Fused Multiply-Add of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADD231PD.Z m512 zmm k zmm
// 	VFMADD231PD.Z zmm  zmm k zmm
// 	VFMADD231PD.Z m128 xmm k xmm
// 	VFMADD231PD.Z m256 ymm k ymm
// 	VFMADD231PD.Z xmm  xmm k xmm
// 	VFMADD231PD.Z ymm  ymm k ymm
func VFMADD231PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PD_Z: bad operands")
}

// VFMADD231PS: Fused Multiply-Add of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADD231PS m128 xmm xmm
// 	VFMADD231PS m256 ymm ymm
// 	VFMADD231PS xmm  xmm xmm
// 	VFMADD231PS ymm  ymm ymm
// 	VFMADD231PS m512 zmm k zmm
// 	VFMADD231PS m512 zmm zmm
// 	VFMADD231PS zmm  zmm k zmm
// 	VFMADD231PS zmm  zmm zmm
// 	VFMADD231PS m128 xmm k xmm
// 	VFMADD231PS m256 ymm k ymm
// 	VFMADD231PS xmm  xmm k xmm
// 	VFMADD231PS ymm  ymm k ymm
func VFMADD231PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADD231PS: bad operands")
}

// VFMADD231PS_BCST: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMADD231PS.BCST m32 zmm k zmm
// 	VFMADD231PS.BCST m32 zmm zmm
// 	VFMADD231PS.BCST m32 xmm k xmm
// 	VFMADD231PS.BCST m32 xmm xmm
// 	VFMADD231PS.BCST m32 ymm k ymm
// 	VFMADD231PS.BCST m32 ymm ymm
func VFMADD231PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PS_BCST: bad operands")
}

// VFMADD231PS_BCST_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231PS.BCST.Z m32 zmm k zmm
// 	VFMADD231PS.BCST.Z m32 xmm k xmm
// 	VFMADD231PS.BCST.Z m32 ymm k ymm
func VFMADD231PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PS_BCST_Z: bad operands")
}

// VFMADD231PS_RD_SAE: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADD231PS.RD_SAE zmm zmm k zmm
// 	VFMADD231PS.RD_SAE zmm zmm zmm
func VFMADD231PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PS_RD_SAE: bad operands")
}

// VFMADD231PS_RD_SAE_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231PS.RD_SAE.Z zmm zmm k zmm
func VFMADD231PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PS_RD_SAE_Z: bad operands")
}

// VFMADD231PS_RN_SAE: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADD231PS.RN_SAE zmm zmm k zmm
// 	VFMADD231PS.RN_SAE zmm zmm zmm
func VFMADD231PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PS_RN_SAE: bad operands")
}

// VFMADD231PS_RN_SAE_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231PS.RN_SAE.Z zmm zmm k zmm
func VFMADD231PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PS_RN_SAE_Z: bad operands")
}

// VFMADD231PS_RU_SAE: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADD231PS.RU_SAE zmm zmm k zmm
// 	VFMADD231PS.RU_SAE zmm zmm zmm
func VFMADD231PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PS_RU_SAE: bad operands")
}

// VFMADD231PS_RU_SAE_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231PS.RU_SAE.Z zmm zmm k zmm
func VFMADD231PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PS_RU_SAE_Z: bad operands")
}

// VFMADD231PS_RZ_SAE: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADD231PS.RZ_SAE zmm zmm k zmm
// 	VFMADD231PS.RZ_SAE zmm zmm zmm
func VFMADD231PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PS_RZ_SAE: bad operands")
}

// VFMADD231PS_RZ_SAE_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231PS.RZ_SAE.Z zmm zmm k zmm
func VFMADD231PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PS_RZ_SAE_Z: bad operands")
}

// VFMADD231PS_Z: Fused Multiply-Add of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADD231PS.Z m512 zmm k zmm
// 	VFMADD231PS.Z zmm  zmm k zmm
// 	VFMADD231PS.Z m128 xmm k xmm
// 	VFMADD231PS.Z m256 ymm k ymm
// 	VFMADD231PS.Z xmm  xmm k xmm
// 	VFMADD231PS.Z ymm  ymm k ymm
func VFMADD231PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADD231PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231PS_Z: bad operands")
}

// VFMADD231SD: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADD231SD m64 xmm xmm
// 	VFMADD231SD xmm xmm xmm
// 	VFMADD231SD m64 xmm k xmm
// 	VFMADD231SD xmm xmm k xmm
func VFMADD231SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADD231SD: bad operands")
}

// VFMADD231SD_RD_SAE: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADD231SD.RD_SAE xmm xmm k xmm
// 	VFMADD231SD.RD_SAE xmm xmm xmm
func VFMADD231SD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SD_RD_SAE: bad operands")
}

// VFMADD231SD_RD_SAE_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231SD.RD_SAE.Z xmm xmm k xmm
func VFMADD231SD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SD_RD_SAE_Z: bad operands")
}

// VFMADD231SD_RN_SAE: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADD231SD.RN_SAE xmm xmm k xmm
// 	VFMADD231SD.RN_SAE xmm xmm xmm
func VFMADD231SD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SD_RN_SAE: bad operands")
}

// VFMADD231SD_RN_SAE_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231SD.RN_SAE.Z xmm xmm k xmm
func VFMADD231SD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SD_RN_SAE_Z: bad operands")
}

// VFMADD231SD_RU_SAE: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADD231SD.RU_SAE xmm xmm k xmm
// 	VFMADD231SD.RU_SAE xmm xmm xmm
func VFMADD231SD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SD_RU_SAE: bad operands")
}

// VFMADD231SD_RU_SAE_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231SD.RU_SAE.Z xmm xmm k xmm
func VFMADD231SD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SD_RU_SAE_Z: bad operands")
}

// VFMADD231SD_RZ_SAE: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADD231SD.RZ_SAE xmm xmm k xmm
// 	VFMADD231SD.RZ_SAE xmm xmm xmm
func VFMADD231SD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SD_RZ_SAE: bad operands")
}

// VFMADD231SD_RZ_SAE_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231SD.RZ_SAE.Z xmm xmm k xmm
func VFMADD231SD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SD_RZ_SAE_Z: bad operands")
}

// VFMADD231SD_Z: Fused Multiply-Add of Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADD231SD.Z m64 xmm k xmm
// 	VFMADD231SD.Z xmm xmm k xmm
func VFMADD231SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SD_Z: bad operands")
}

// VFMADD231SS: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADD231SS m32 xmm xmm
// 	VFMADD231SS xmm xmm xmm
// 	VFMADD231SS m32 xmm k xmm
// 	VFMADD231SS xmm xmm k xmm
func VFMADD231SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADD231SS: bad operands")
}

// VFMADD231SS_RD_SAE: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADD231SS.RD_SAE xmm xmm k xmm
// 	VFMADD231SS.RD_SAE xmm xmm xmm
func VFMADD231SS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SS_RD_SAE: bad operands")
}

// VFMADD231SS_RD_SAE_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231SS.RD_SAE.Z xmm xmm k xmm
func VFMADD231SS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SS_RD_SAE_Z: bad operands")
}

// VFMADD231SS_RN_SAE: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADD231SS.RN_SAE xmm xmm k xmm
// 	VFMADD231SS.RN_SAE xmm xmm xmm
func VFMADD231SS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SS_RN_SAE: bad operands")
}

// VFMADD231SS_RN_SAE_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231SS.RN_SAE.Z xmm xmm k xmm
func VFMADD231SS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SS_RN_SAE_Z: bad operands")
}

// VFMADD231SS_RU_SAE: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADD231SS.RU_SAE xmm xmm k xmm
// 	VFMADD231SS.RU_SAE xmm xmm xmm
func VFMADD231SS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SS_RU_SAE: bad operands")
}

// VFMADD231SS_RU_SAE_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231SS.RU_SAE.Z xmm xmm k xmm
func VFMADD231SS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SS_RU_SAE_Z: bad operands")
}

// VFMADD231SS_RZ_SAE: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADD231SS.RZ_SAE xmm xmm k xmm
// 	VFMADD231SS.RZ_SAE xmm xmm xmm
func VFMADD231SS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SS_RZ_SAE: bad operands")
}

// VFMADD231SS_RZ_SAE_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADD231SS.RZ_SAE.Z xmm xmm k xmm
func VFMADD231SS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SS_RZ_SAE_Z: bad operands")
}

// VFMADD231SS_Z: Fused Multiply-Add of Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADD231SS.Z m32 xmm k xmm
// 	VFMADD231SS.Z xmm xmm k xmm
func VFMADD231SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFMADD231SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADD231SS_Z: bad operands")
}

// VFMADDSUB132PD: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADDSUB132PD m128 xmm xmm
// 	VFMADDSUB132PD m256 ymm ymm
// 	VFMADDSUB132PD xmm  xmm xmm
// 	VFMADDSUB132PD ymm  ymm ymm
// 	VFMADDSUB132PD m512 zmm k zmm
// 	VFMADDSUB132PD m512 zmm zmm
// 	VFMADDSUB132PD zmm  zmm k zmm
// 	VFMADDSUB132PD zmm  zmm zmm
// 	VFMADDSUB132PD m128 xmm k xmm
// 	VFMADDSUB132PD m256 ymm k ymm
// 	VFMADDSUB132PD xmm  xmm k xmm
// 	VFMADDSUB132PD ymm  ymm k ymm
func VFMADDSUB132PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PD: bad operands")
}

// VFMADDSUB132PD_BCST: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMADDSUB132PD.BCST m64 zmm k zmm
// 	VFMADDSUB132PD.BCST m64 zmm zmm
// 	VFMADDSUB132PD.BCST m64 xmm k xmm
// 	VFMADDSUB132PD.BCST m64 xmm xmm
// 	VFMADDSUB132PD.BCST m64 ymm k ymm
// 	VFMADDSUB132PD.BCST m64 ymm ymm
func VFMADDSUB132PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PD_BCST: bad operands")
}

// VFMADDSUB132PD_BCST_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB132PD.BCST.Z m64 zmm k zmm
// 	VFMADDSUB132PD.BCST.Z m64 xmm k xmm
// 	VFMADDSUB132PD.BCST.Z m64 ymm k ymm
func VFMADDSUB132PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PD_BCST_Z: bad operands")
}

// VFMADDSUB132PD_RD_SAE: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADDSUB132PD.RD_SAE zmm zmm k zmm
// 	VFMADDSUB132PD.RD_SAE zmm zmm zmm
func VFMADDSUB132PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PD_RD_SAE: bad operands")
}

// VFMADDSUB132PD_RD_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB132PD.RD_SAE.Z zmm zmm k zmm
func VFMADDSUB132PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PD_RD_SAE_Z: bad operands")
}

// VFMADDSUB132PD_RN_SAE: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADDSUB132PD.RN_SAE zmm zmm k zmm
// 	VFMADDSUB132PD.RN_SAE zmm zmm zmm
func VFMADDSUB132PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PD_RN_SAE: bad operands")
}

// VFMADDSUB132PD_RN_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB132PD.RN_SAE.Z zmm zmm k zmm
func VFMADDSUB132PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PD_RN_SAE_Z: bad operands")
}

// VFMADDSUB132PD_RU_SAE: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADDSUB132PD.RU_SAE zmm zmm k zmm
// 	VFMADDSUB132PD.RU_SAE zmm zmm zmm
func VFMADDSUB132PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PD_RU_SAE: bad operands")
}

// VFMADDSUB132PD_RU_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB132PD.RU_SAE.Z zmm zmm k zmm
func VFMADDSUB132PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PD_RU_SAE_Z: bad operands")
}

// VFMADDSUB132PD_RZ_SAE: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADDSUB132PD.RZ_SAE zmm zmm k zmm
// 	VFMADDSUB132PD.RZ_SAE zmm zmm zmm
func VFMADDSUB132PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PD_RZ_SAE: bad operands")
}

// VFMADDSUB132PD_RZ_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB132PD.RZ_SAE.Z zmm zmm k zmm
func VFMADDSUB132PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PD_RZ_SAE_Z: bad operands")
}

// VFMADDSUB132PD_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB132PD.Z m512 zmm k zmm
// 	VFMADDSUB132PD.Z zmm  zmm k zmm
// 	VFMADDSUB132PD.Z m128 xmm k xmm
// 	VFMADDSUB132PD.Z m256 ymm k ymm
// 	VFMADDSUB132PD.Z xmm  xmm k xmm
// 	VFMADDSUB132PD.Z ymm  ymm k ymm
func VFMADDSUB132PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PD_Z: bad operands")
}

// VFMADDSUB132PS: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADDSUB132PS m128 xmm xmm
// 	VFMADDSUB132PS m256 ymm ymm
// 	VFMADDSUB132PS xmm  xmm xmm
// 	VFMADDSUB132PS ymm  ymm ymm
// 	VFMADDSUB132PS m512 zmm k zmm
// 	VFMADDSUB132PS m512 zmm zmm
// 	VFMADDSUB132PS zmm  zmm k zmm
// 	VFMADDSUB132PS zmm  zmm zmm
// 	VFMADDSUB132PS m128 xmm k xmm
// 	VFMADDSUB132PS m256 ymm k ymm
// 	VFMADDSUB132PS xmm  xmm k xmm
// 	VFMADDSUB132PS ymm  ymm k ymm
func VFMADDSUB132PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PS: bad operands")
}

// VFMADDSUB132PS_BCST: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMADDSUB132PS.BCST m32 zmm k zmm
// 	VFMADDSUB132PS.BCST m32 zmm zmm
// 	VFMADDSUB132PS.BCST m32 xmm k xmm
// 	VFMADDSUB132PS.BCST m32 xmm xmm
// 	VFMADDSUB132PS.BCST m32 ymm k ymm
// 	VFMADDSUB132PS.BCST m32 ymm ymm
func VFMADDSUB132PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PS_BCST: bad operands")
}

// VFMADDSUB132PS_BCST_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB132PS.BCST.Z m32 zmm k zmm
// 	VFMADDSUB132PS.BCST.Z m32 xmm k xmm
// 	VFMADDSUB132PS.BCST.Z m32 ymm k ymm
func VFMADDSUB132PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PS_BCST_Z: bad operands")
}

// VFMADDSUB132PS_RD_SAE: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADDSUB132PS.RD_SAE zmm zmm k zmm
// 	VFMADDSUB132PS.RD_SAE zmm zmm zmm
func VFMADDSUB132PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PS_RD_SAE: bad operands")
}

// VFMADDSUB132PS_RD_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB132PS.RD_SAE.Z zmm zmm k zmm
func VFMADDSUB132PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PS_RD_SAE_Z: bad operands")
}

// VFMADDSUB132PS_RN_SAE: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADDSUB132PS.RN_SAE zmm zmm k zmm
// 	VFMADDSUB132PS.RN_SAE zmm zmm zmm
func VFMADDSUB132PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PS_RN_SAE: bad operands")
}

// VFMADDSUB132PS_RN_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB132PS.RN_SAE.Z zmm zmm k zmm
func VFMADDSUB132PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PS_RN_SAE_Z: bad operands")
}

// VFMADDSUB132PS_RU_SAE: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADDSUB132PS.RU_SAE zmm zmm k zmm
// 	VFMADDSUB132PS.RU_SAE zmm zmm zmm
func VFMADDSUB132PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PS_RU_SAE: bad operands")
}

// VFMADDSUB132PS_RU_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB132PS.RU_SAE.Z zmm zmm k zmm
func VFMADDSUB132PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PS_RU_SAE_Z: bad operands")
}

// VFMADDSUB132PS_RZ_SAE: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADDSUB132PS.RZ_SAE zmm zmm k zmm
// 	VFMADDSUB132PS.RZ_SAE zmm zmm zmm
func VFMADDSUB132PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PS_RZ_SAE: bad operands")
}

// VFMADDSUB132PS_RZ_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB132PS.RZ_SAE.Z zmm zmm k zmm
func VFMADDSUB132PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PS_RZ_SAE_Z: bad operands")
}

// VFMADDSUB132PS_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB132PS.Z m512 zmm k zmm
// 	VFMADDSUB132PS.Z zmm  zmm k zmm
// 	VFMADDSUB132PS.Z m128 xmm k xmm
// 	VFMADDSUB132PS.Z m256 ymm k ymm
// 	VFMADDSUB132PS.Z xmm  xmm k xmm
// 	VFMADDSUB132PS.Z ymm  ymm k ymm
func VFMADDSUB132PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB132PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB132PS_Z: bad operands")
}

// VFMADDSUB213PD: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADDSUB213PD m128 xmm xmm
// 	VFMADDSUB213PD m256 ymm ymm
// 	VFMADDSUB213PD xmm  xmm xmm
// 	VFMADDSUB213PD ymm  ymm ymm
// 	VFMADDSUB213PD m512 zmm k zmm
// 	VFMADDSUB213PD m512 zmm zmm
// 	VFMADDSUB213PD zmm  zmm k zmm
// 	VFMADDSUB213PD zmm  zmm zmm
// 	VFMADDSUB213PD m128 xmm k xmm
// 	VFMADDSUB213PD m256 ymm k ymm
// 	VFMADDSUB213PD xmm  xmm k xmm
// 	VFMADDSUB213PD ymm  ymm k ymm
func VFMADDSUB213PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PD: bad operands")
}

// VFMADDSUB213PD_BCST: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMADDSUB213PD.BCST m64 zmm k zmm
// 	VFMADDSUB213PD.BCST m64 zmm zmm
// 	VFMADDSUB213PD.BCST m64 xmm k xmm
// 	VFMADDSUB213PD.BCST m64 xmm xmm
// 	VFMADDSUB213PD.BCST m64 ymm k ymm
// 	VFMADDSUB213PD.BCST m64 ymm ymm
func VFMADDSUB213PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PD_BCST: bad operands")
}

// VFMADDSUB213PD_BCST_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB213PD.BCST.Z m64 zmm k zmm
// 	VFMADDSUB213PD.BCST.Z m64 xmm k xmm
// 	VFMADDSUB213PD.BCST.Z m64 ymm k ymm
func VFMADDSUB213PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PD_BCST_Z: bad operands")
}

// VFMADDSUB213PD_RD_SAE: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADDSUB213PD.RD_SAE zmm zmm k zmm
// 	VFMADDSUB213PD.RD_SAE zmm zmm zmm
func VFMADDSUB213PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PD_RD_SAE: bad operands")
}

// VFMADDSUB213PD_RD_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB213PD.RD_SAE.Z zmm zmm k zmm
func VFMADDSUB213PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PD_RD_SAE_Z: bad operands")
}

// VFMADDSUB213PD_RN_SAE: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADDSUB213PD.RN_SAE zmm zmm k zmm
// 	VFMADDSUB213PD.RN_SAE zmm zmm zmm
func VFMADDSUB213PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PD_RN_SAE: bad operands")
}

// VFMADDSUB213PD_RN_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB213PD.RN_SAE.Z zmm zmm k zmm
func VFMADDSUB213PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PD_RN_SAE_Z: bad operands")
}

// VFMADDSUB213PD_RU_SAE: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADDSUB213PD.RU_SAE zmm zmm k zmm
// 	VFMADDSUB213PD.RU_SAE zmm zmm zmm
func VFMADDSUB213PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PD_RU_SAE: bad operands")
}

// VFMADDSUB213PD_RU_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB213PD.RU_SAE.Z zmm zmm k zmm
func VFMADDSUB213PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PD_RU_SAE_Z: bad operands")
}

// VFMADDSUB213PD_RZ_SAE: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADDSUB213PD.RZ_SAE zmm zmm k zmm
// 	VFMADDSUB213PD.RZ_SAE zmm zmm zmm
func VFMADDSUB213PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PD_RZ_SAE: bad operands")
}

// VFMADDSUB213PD_RZ_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB213PD.RZ_SAE.Z zmm zmm k zmm
func VFMADDSUB213PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PD_RZ_SAE_Z: bad operands")
}

// VFMADDSUB213PD_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB213PD.Z m512 zmm k zmm
// 	VFMADDSUB213PD.Z zmm  zmm k zmm
// 	VFMADDSUB213PD.Z m128 xmm k xmm
// 	VFMADDSUB213PD.Z m256 ymm k ymm
// 	VFMADDSUB213PD.Z xmm  xmm k xmm
// 	VFMADDSUB213PD.Z ymm  ymm k ymm
func VFMADDSUB213PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PD_Z: bad operands")
}

// VFMADDSUB213PS: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADDSUB213PS m128 xmm xmm
// 	VFMADDSUB213PS m256 ymm ymm
// 	VFMADDSUB213PS xmm  xmm xmm
// 	VFMADDSUB213PS ymm  ymm ymm
// 	VFMADDSUB213PS m512 zmm k zmm
// 	VFMADDSUB213PS m512 zmm zmm
// 	VFMADDSUB213PS zmm  zmm k zmm
// 	VFMADDSUB213PS zmm  zmm zmm
// 	VFMADDSUB213PS m128 xmm k xmm
// 	VFMADDSUB213PS m256 ymm k ymm
// 	VFMADDSUB213PS xmm  xmm k xmm
// 	VFMADDSUB213PS ymm  ymm k ymm
func VFMADDSUB213PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PS: bad operands")
}

// VFMADDSUB213PS_BCST: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMADDSUB213PS.BCST m32 zmm k zmm
// 	VFMADDSUB213PS.BCST m32 zmm zmm
// 	VFMADDSUB213PS.BCST m32 xmm k xmm
// 	VFMADDSUB213PS.BCST m32 xmm xmm
// 	VFMADDSUB213PS.BCST m32 ymm k ymm
// 	VFMADDSUB213PS.BCST m32 ymm ymm
func VFMADDSUB213PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PS_BCST: bad operands")
}

// VFMADDSUB213PS_BCST_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB213PS.BCST.Z m32 zmm k zmm
// 	VFMADDSUB213PS.BCST.Z m32 xmm k xmm
// 	VFMADDSUB213PS.BCST.Z m32 ymm k ymm
func VFMADDSUB213PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PS_BCST_Z: bad operands")
}

// VFMADDSUB213PS_RD_SAE: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADDSUB213PS.RD_SAE zmm zmm k zmm
// 	VFMADDSUB213PS.RD_SAE zmm zmm zmm
func VFMADDSUB213PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PS_RD_SAE: bad operands")
}

// VFMADDSUB213PS_RD_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB213PS.RD_SAE.Z zmm zmm k zmm
func VFMADDSUB213PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PS_RD_SAE_Z: bad operands")
}

// VFMADDSUB213PS_RN_SAE: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADDSUB213PS.RN_SAE zmm zmm k zmm
// 	VFMADDSUB213PS.RN_SAE zmm zmm zmm
func VFMADDSUB213PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PS_RN_SAE: bad operands")
}

// VFMADDSUB213PS_RN_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB213PS.RN_SAE.Z zmm zmm k zmm
func VFMADDSUB213PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PS_RN_SAE_Z: bad operands")
}

// VFMADDSUB213PS_RU_SAE: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADDSUB213PS.RU_SAE zmm zmm k zmm
// 	VFMADDSUB213PS.RU_SAE zmm zmm zmm
func VFMADDSUB213PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PS_RU_SAE: bad operands")
}

// VFMADDSUB213PS_RU_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB213PS.RU_SAE.Z zmm zmm k zmm
func VFMADDSUB213PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PS_RU_SAE_Z: bad operands")
}

// VFMADDSUB213PS_RZ_SAE: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADDSUB213PS.RZ_SAE zmm zmm k zmm
// 	VFMADDSUB213PS.RZ_SAE zmm zmm zmm
func VFMADDSUB213PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PS_RZ_SAE: bad operands")
}

// VFMADDSUB213PS_RZ_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB213PS.RZ_SAE.Z zmm zmm k zmm
func VFMADDSUB213PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PS_RZ_SAE_Z: bad operands")
}

// VFMADDSUB213PS_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB213PS.Z m512 zmm k zmm
// 	VFMADDSUB213PS.Z zmm  zmm k zmm
// 	VFMADDSUB213PS.Z m128 xmm k xmm
// 	VFMADDSUB213PS.Z m256 ymm k ymm
// 	VFMADDSUB213PS.Z xmm  xmm k xmm
// 	VFMADDSUB213PS.Z ymm  ymm k ymm
func VFMADDSUB213PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB213PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB213PS_Z: bad operands")
}

// VFMADDSUB231PD: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADDSUB231PD m128 xmm xmm
// 	VFMADDSUB231PD m256 ymm ymm
// 	VFMADDSUB231PD xmm  xmm xmm
// 	VFMADDSUB231PD ymm  ymm ymm
// 	VFMADDSUB231PD m512 zmm k zmm
// 	VFMADDSUB231PD m512 zmm zmm
// 	VFMADDSUB231PD zmm  zmm k zmm
// 	VFMADDSUB231PD zmm  zmm zmm
// 	VFMADDSUB231PD m128 xmm k xmm
// 	VFMADDSUB231PD m256 ymm k ymm
// 	VFMADDSUB231PD xmm  xmm k xmm
// 	VFMADDSUB231PD ymm  ymm k ymm
func VFMADDSUB231PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PD: bad operands")
}

// VFMADDSUB231PD_BCST: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMADDSUB231PD.BCST m64 zmm k zmm
// 	VFMADDSUB231PD.BCST m64 zmm zmm
// 	VFMADDSUB231PD.BCST m64 xmm k xmm
// 	VFMADDSUB231PD.BCST m64 xmm xmm
// 	VFMADDSUB231PD.BCST m64 ymm k ymm
// 	VFMADDSUB231PD.BCST m64 ymm ymm
func VFMADDSUB231PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PD_BCST: bad operands")
}

// VFMADDSUB231PD_BCST_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB231PD.BCST.Z m64 zmm k zmm
// 	VFMADDSUB231PD.BCST.Z m64 xmm k xmm
// 	VFMADDSUB231PD.BCST.Z m64 ymm k ymm
func VFMADDSUB231PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PD_BCST_Z: bad operands")
}

// VFMADDSUB231PD_RD_SAE: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADDSUB231PD.RD_SAE zmm zmm k zmm
// 	VFMADDSUB231PD.RD_SAE zmm zmm zmm
func VFMADDSUB231PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PD_RD_SAE: bad operands")
}

// VFMADDSUB231PD_RD_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB231PD.RD_SAE.Z zmm zmm k zmm
func VFMADDSUB231PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PD_RD_SAE_Z: bad operands")
}

// VFMADDSUB231PD_RN_SAE: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADDSUB231PD.RN_SAE zmm zmm k zmm
// 	VFMADDSUB231PD.RN_SAE zmm zmm zmm
func VFMADDSUB231PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PD_RN_SAE: bad operands")
}

// VFMADDSUB231PD_RN_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB231PD.RN_SAE.Z zmm zmm k zmm
func VFMADDSUB231PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PD_RN_SAE_Z: bad operands")
}

// VFMADDSUB231PD_RU_SAE: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADDSUB231PD.RU_SAE zmm zmm k zmm
// 	VFMADDSUB231PD.RU_SAE zmm zmm zmm
func VFMADDSUB231PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PD_RU_SAE: bad operands")
}

// VFMADDSUB231PD_RU_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB231PD.RU_SAE.Z zmm zmm k zmm
func VFMADDSUB231PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PD_RU_SAE_Z: bad operands")
}

// VFMADDSUB231PD_RZ_SAE: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADDSUB231PD.RZ_SAE zmm zmm k zmm
// 	VFMADDSUB231PD.RZ_SAE zmm zmm zmm
func VFMADDSUB231PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PD_RZ_SAE: bad operands")
}

// VFMADDSUB231PD_RZ_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB231PD.RZ_SAE.Z zmm zmm k zmm
func VFMADDSUB231PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PD_RZ_SAE_Z: bad operands")
}

// VFMADDSUB231PD_Z: Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB231PD.Z m512 zmm k zmm
// 	VFMADDSUB231PD.Z zmm  zmm k zmm
// 	VFMADDSUB231PD.Z m128 xmm k xmm
// 	VFMADDSUB231PD.Z m256 ymm k ymm
// 	VFMADDSUB231PD.Z xmm  xmm k xmm
// 	VFMADDSUB231PD.Z ymm  ymm k ymm
func VFMADDSUB231PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PD_Z: bad operands")
}

// VFMADDSUB231PS: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMADDSUB231PS m128 xmm xmm
// 	VFMADDSUB231PS m256 ymm ymm
// 	VFMADDSUB231PS xmm  xmm xmm
// 	VFMADDSUB231PS ymm  ymm ymm
// 	VFMADDSUB231PS m512 zmm k zmm
// 	VFMADDSUB231PS m512 zmm zmm
// 	VFMADDSUB231PS zmm  zmm k zmm
// 	VFMADDSUB231PS zmm  zmm zmm
// 	VFMADDSUB231PS m128 xmm k xmm
// 	VFMADDSUB231PS m256 ymm k ymm
// 	VFMADDSUB231PS xmm  xmm k xmm
// 	VFMADDSUB231PS ymm  ymm k ymm
func VFMADDSUB231PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PS: bad operands")
}

// VFMADDSUB231PS_BCST: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMADDSUB231PS.BCST m32 zmm k zmm
// 	VFMADDSUB231PS.BCST m32 zmm zmm
// 	VFMADDSUB231PS.BCST m32 xmm k xmm
// 	VFMADDSUB231PS.BCST m32 xmm xmm
// 	VFMADDSUB231PS.BCST m32 ymm k ymm
// 	VFMADDSUB231PS.BCST m32 ymm ymm
func VFMADDSUB231PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PS_BCST: bad operands")
}

// VFMADDSUB231PS_BCST_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB231PS.BCST.Z m32 zmm k zmm
// 	VFMADDSUB231PS.BCST.Z m32 xmm k xmm
// 	VFMADDSUB231PS.BCST.Z m32 ymm k ymm
func VFMADDSUB231PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PS_BCST_Z: bad operands")
}

// VFMADDSUB231PS_RD_SAE: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMADDSUB231PS.RD_SAE zmm zmm k zmm
// 	VFMADDSUB231PS.RD_SAE zmm zmm zmm
func VFMADDSUB231PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PS_RD_SAE: bad operands")
}

// VFMADDSUB231PS_RD_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB231PS.RD_SAE.Z zmm zmm k zmm
func VFMADDSUB231PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PS_RD_SAE_Z: bad operands")
}

// VFMADDSUB231PS_RN_SAE: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMADDSUB231PS.RN_SAE zmm zmm k zmm
// 	VFMADDSUB231PS.RN_SAE zmm zmm zmm
func VFMADDSUB231PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PS_RN_SAE: bad operands")
}

// VFMADDSUB231PS_RN_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB231PS.RN_SAE.Z zmm zmm k zmm
func VFMADDSUB231PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PS_RN_SAE_Z: bad operands")
}

// VFMADDSUB231PS_RU_SAE: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMADDSUB231PS.RU_SAE zmm zmm k zmm
// 	VFMADDSUB231PS.RU_SAE zmm zmm zmm
func VFMADDSUB231PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PS_RU_SAE: bad operands")
}

// VFMADDSUB231PS_RU_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB231PS.RU_SAE.Z zmm zmm k zmm
func VFMADDSUB231PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PS_RU_SAE_Z: bad operands")
}

// VFMADDSUB231PS_RZ_SAE: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMADDSUB231PS.RZ_SAE zmm zmm k zmm
// 	VFMADDSUB231PS.RZ_SAE zmm zmm zmm
func VFMADDSUB231PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PS_RZ_SAE: bad operands")
}

// VFMADDSUB231PS_RZ_SAE_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB231PS.RZ_SAE.Z zmm zmm k zmm
func VFMADDSUB231PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PS_RZ_SAE_Z: bad operands")
}

// VFMADDSUB231PS_Z: Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMADDSUB231PS.Z m512 zmm k zmm
// 	VFMADDSUB231PS.Z zmm  zmm k zmm
// 	VFMADDSUB231PS.Z m128 xmm k xmm
// 	VFMADDSUB231PS.Z m256 ymm k ymm
// 	VFMADDSUB231PS.Z xmm  xmm k xmm
// 	VFMADDSUB231PS.Z ymm  ymm k ymm
func VFMADDSUB231PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMADDSUB231PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMADDSUB231PS_Z: bad operands")
}

// VFMSUB132PD: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUB132PD m128 xmm xmm
// 	VFMSUB132PD m256 ymm ymm
// 	VFMSUB132PD xmm  xmm xmm
// 	VFMSUB132PD ymm  ymm ymm
// 	VFMSUB132PD m512 zmm k zmm
// 	VFMSUB132PD m512 zmm zmm
// 	VFMSUB132PD zmm  zmm k zmm
// 	VFMSUB132PD zmm  zmm zmm
// 	VFMSUB132PD m128 xmm k xmm
// 	VFMSUB132PD m256 ymm k ymm
// 	VFMSUB132PD xmm  xmm k xmm
// 	VFMSUB132PD ymm  ymm k ymm
func VFMSUB132PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PD: bad operands")
}

// VFMSUB132PD_BCST: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMSUB132PD.BCST m64 zmm k zmm
// 	VFMSUB132PD.BCST m64 zmm zmm
// 	VFMSUB132PD.BCST m64 xmm k xmm
// 	VFMSUB132PD.BCST m64 xmm xmm
// 	VFMSUB132PD.BCST m64 ymm k ymm
// 	VFMSUB132PD.BCST m64 ymm ymm
func VFMSUB132PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PD_BCST: bad operands")
}

// VFMSUB132PD_BCST_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132PD.BCST.Z m64 zmm k zmm
// 	VFMSUB132PD.BCST.Z m64 xmm k xmm
// 	VFMSUB132PD.BCST.Z m64 ymm k ymm
func VFMSUB132PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PD_BCST_Z: bad operands")
}

// VFMSUB132PD_RD_SAE: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUB132PD.RD_SAE zmm zmm k zmm
// 	VFMSUB132PD.RD_SAE zmm zmm zmm
func VFMSUB132PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PD_RD_SAE: bad operands")
}

// VFMSUB132PD_RD_SAE_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132PD.RD_SAE.Z zmm zmm k zmm
func VFMSUB132PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PD_RD_SAE_Z: bad operands")
}

// VFMSUB132PD_RN_SAE: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUB132PD.RN_SAE zmm zmm k zmm
// 	VFMSUB132PD.RN_SAE zmm zmm zmm
func VFMSUB132PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PD_RN_SAE: bad operands")
}

// VFMSUB132PD_RN_SAE_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132PD.RN_SAE.Z zmm zmm k zmm
func VFMSUB132PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PD_RN_SAE_Z: bad operands")
}

// VFMSUB132PD_RU_SAE: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUB132PD.RU_SAE zmm zmm k zmm
// 	VFMSUB132PD.RU_SAE zmm zmm zmm
func VFMSUB132PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PD_RU_SAE: bad operands")
}

// VFMSUB132PD_RU_SAE_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132PD.RU_SAE.Z zmm zmm k zmm
func VFMSUB132PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PD_RU_SAE_Z: bad operands")
}

// VFMSUB132PD_RZ_SAE: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUB132PD.RZ_SAE zmm zmm k zmm
// 	VFMSUB132PD.RZ_SAE zmm zmm zmm
func VFMSUB132PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PD_RZ_SAE: bad operands")
}

// VFMSUB132PD_RZ_SAE_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132PD.RZ_SAE.Z zmm zmm k zmm
func VFMSUB132PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PD_RZ_SAE_Z: bad operands")
}

// VFMSUB132PD_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132PD.Z m512 zmm k zmm
// 	VFMSUB132PD.Z zmm  zmm k zmm
// 	VFMSUB132PD.Z m128 xmm k xmm
// 	VFMSUB132PD.Z m256 ymm k ymm
// 	VFMSUB132PD.Z xmm  xmm k xmm
// 	VFMSUB132PD.Z ymm  ymm k ymm
func VFMSUB132PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PD_Z: bad operands")
}

// VFMSUB132PS: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUB132PS m128 xmm xmm
// 	VFMSUB132PS m256 ymm ymm
// 	VFMSUB132PS xmm  xmm xmm
// 	VFMSUB132PS ymm  ymm ymm
// 	VFMSUB132PS m512 zmm k zmm
// 	VFMSUB132PS m512 zmm zmm
// 	VFMSUB132PS zmm  zmm k zmm
// 	VFMSUB132PS zmm  zmm zmm
// 	VFMSUB132PS m128 xmm k xmm
// 	VFMSUB132PS m256 ymm k ymm
// 	VFMSUB132PS xmm  xmm k xmm
// 	VFMSUB132PS ymm  ymm k ymm
func VFMSUB132PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PS: bad operands")
}

// VFMSUB132PS_BCST: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMSUB132PS.BCST m32 zmm k zmm
// 	VFMSUB132PS.BCST m32 zmm zmm
// 	VFMSUB132PS.BCST m32 xmm k xmm
// 	VFMSUB132PS.BCST m32 xmm xmm
// 	VFMSUB132PS.BCST m32 ymm k ymm
// 	VFMSUB132PS.BCST m32 ymm ymm
func VFMSUB132PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PS_BCST: bad operands")
}

// VFMSUB132PS_BCST_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132PS.BCST.Z m32 zmm k zmm
// 	VFMSUB132PS.BCST.Z m32 xmm k xmm
// 	VFMSUB132PS.BCST.Z m32 ymm k ymm
func VFMSUB132PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PS_BCST_Z: bad operands")
}

// VFMSUB132PS_RD_SAE: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUB132PS.RD_SAE zmm zmm k zmm
// 	VFMSUB132PS.RD_SAE zmm zmm zmm
func VFMSUB132PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PS_RD_SAE: bad operands")
}

// VFMSUB132PS_RD_SAE_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132PS.RD_SAE.Z zmm zmm k zmm
func VFMSUB132PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PS_RD_SAE_Z: bad operands")
}

// VFMSUB132PS_RN_SAE: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUB132PS.RN_SAE zmm zmm k zmm
// 	VFMSUB132PS.RN_SAE zmm zmm zmm
func VFMSUB132PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PS_RN_SAE: bad operands")
}

// VFMSUB132PS_RN_SAE_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132PS.RN_SAE.Z zmm zmm k zmm
func VFMSUB132PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PS_RN_SAE_Z: bad operands")
}

// VFMSUB132PS_RU_SAE: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUB132PS.RU_SAE zmm zmm k zmm
// 	VFMSUB132PS.RU_SAE zmm zmm zmm
func VFMSUB132PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PS_RU_SAE: bad operands")
}

// VFMSUB132PS_RU_SAE_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132PS.RU_SAE.Z zmm zmm k zmm
func VFMSUB132PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PS_RU_SAE_Z: bad operands")
}

// VFMSUB132PS_RZ_SAE: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUB132PS.RZ_SAE zmm zmm k zmm
// 	VFMSUB132PS.RZ_SAE zmm zmm zmm
func VFMSUB132PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PS_RZ_SAE: bad operands")
}

// VFMSUB132PS_RZ_SAE_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132PS.RZ_SAE.Z zmm zmm k zmm
func VFMSUB132PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PS_RZ_SAE_Z: bad operands")
}

// VFMSUB132PS_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132PS.Z m512 zmm k zmm
// 	VFMSUB132PS.Z zmm  zmm k zmm
// 	VFMSUB132PS.Z m128 xmm k xmm
// 	VFMSUB132PS.Z m256 ymm k ymm
// 	VFMSUB132PS.Z xmm  xmm k xmm
// 	VFMSUB132PS.Z ymm  ymm k ymm
func VFMSUB132PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132PS_Z: bad operands")
}

// VFMSUB132SD: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUB132SD m64 xmm xmm
// 	VFMSUB132SD xmm xmm xmm
// 	VFMSUB132SD m64 xmm k xmm
// 	VFMSUB132SD xmm xmm k xmm
func VFMSUB132SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SD: bad operands")
}

// VFMSUB132SD_RD_SAE: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUB132SD.RD_SAE xmm xmm k xmm
// 	VFMSUB132SD.RD_SAE xmm xmm xmm
func VFMSUB132SD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SD_RD_SAE: bad operands")
}

// VFMSUB132SD_RD_SAE_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132SD.RD_SAE.Z xmm xmm k xmm
func VFMSUB132SD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SD_RD_SAE_Z: bad operands")
}

// VFMSUB132SD_RN_SAE: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUB132SD.RN_SAE xmm xmm k xmm
// 	VFMSUB132SD.RN_SAE xmm xmm xmm
func VFMSUB132SD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SD_RN_SAE: bad operands")
}

// VFMSUB132SD_RN_SAE_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132SD.RN_SAE.Z xmm xmm k xmm
func VFMSUB132SD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SD_RN_SAE_Z: bad operands")
}

// VFMSUB132SD_RU_SAE: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUB132SD.RU_SAE xmm xmm k xmm
// 	VFMSUB132SD.RU_SAE xmm xmm xmm
func VFMSUB132SD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SD_RU_SAE: bad operands")
}

// VFMSUB132SD_RU_SAE_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132SD.RU_SAE.Z xmm xmm k xmm
func VFMSUB132SD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SD_RU_SAE_Z: bad operands")
}

// VFMSUB132SD_RZ_SAE: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUB132SD.RZ_SAE xmm xmm k xmm
// 	VFMSUB132SD.RZ_SAE xmm xmm xmm
func VFMSUB132SD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SD_RZ_SAE: bad operands")
}

// VFMSUB132SD_RZ_SAE_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132SD.RZ_SAE.Z xmm xmm k xmm
func VFMSUB132SD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SD_RZ_SAE_Z: bad operands")
}

// VFMSUB132SD_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132SD.Z m64 xmm k xmm
// 	VFMSUB132SD.Z xmm xmm k xmm
func VFMSUB132SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SD_Z: bad operands")
}

// VFMSUB132SS: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUB132SS m32 xmm xmm
// 	VFMSUB132SS xmm xmm xmm
// 	VFMSUB132SS m32 xmm k xmm
// 	VFMSUB132SS xmm xmm k xmm
func VFMSUB132SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SS: bad operands")
}

// VFMSUB132SS_RD_SAE: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUB132SS.RD_SAE xmm xmm k xmm
// 	VFMSUB132SS.RD_SAE xmm xmm xmm
func VFMSUB132SS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SS_RD_SAE: bad operands")
}

// VFMSUB132SS_RD_SAE_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132SS.RD_SAE.Z xmm xmm k xmm
func VFMSUB132SS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SS_RD_SAE_Z: bad operands")
}

// VFMSUB132SS_RN_SAE: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUB132SS.RN_SAE xmm xmm k xmm
// 	VFMSUB132SS.RN_SAE xmm xmm xmm
func VFMSUB132SS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SS_RN_SAE: bad operands")
}

// VFMSUB132SS_RN_SAE_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132SS.RN_SAE.Z xmm xmm k xmm
func VFMSUB132SS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SS_RN_SAE_Z: bad operands")
}

// VFMSUB132SS_RU_SAE: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUB132SS.RU_SAE xmm xmm k xmm
// 	VFMSUB132SS.RU_SAE xmm xmm xmm
func VFMSUB132SS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SS_RU_SAE: bad operands")
}

// VFMSUB132SS_RU_SAE_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132SS.RU_SAE.Z xmm xmm k xmm
func VFMSUB132SS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SS_RU_SAE_Z: bad operands")
}

// VFMSUB132SS_RZ_SAE: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUB132SS.RZ_SAE xmm xmm k xmm
// 	VFMSUB132SS.RZ_SAE xmm xmm xmm
func VFMSUB132SS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SS_RZ_SAE: bad operands")
}

// VFMSUB132SS_RZ_SAE_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132SS.RZ_SAE.Z xmm xmm k xmm
func VFMSUB132SS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SS_RZ_SAE_Z: bad operands")
}

// VFMSUB132SS_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUB132SS.Z m32 xmm k xmm
// 	VFMSUB132SS.Z xmm xmm k xmm
func VFMSUB132SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB132SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB132SS_Z: bad operands")
}

// VFMSUB213PD: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUB213PD m128 xmm xmm
// 	VFMSUB213PD m256 ymm ymm
// 	VFMSUB213PD xmm  xmm xmm
// 	VFMSUB213PD ymm  ymm ymm
// 	VFMSUB213PD m512 zmm k zmm
// 	VFMSUB213PD m512 zmm zmm
// 	VFMSUB213PD zmm  zmm k zmm
// 	VFMSUB213PD zmm  zmm zmm
// 	VFMSUB213PD m128 xmm k xmm
// 	VFMSUB213PD m256 ymm k ymm
// 	VFMSUB213PD xmm  xmm k xmm
// 	VFMSUB213PD ymm  ymm k ymm
func VFMSUB213PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PD: bad operands")
}

// VFMSUB213PD_BCST: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMSUB213PD.BCST m64 zmm k zmm
// 	VFMSUB213PD.BCST m64 zmm zmm
// 	VFMSUB213PD.BCST m64 xmm k xmm
// 	VFMSUB213PD.BCST m64 xmm xmm
// 	VFMSUB213PD.BCST m64 ymm k ymm
// 	VFMSUB213PD.BCST m64 ymm ymm
func VFMSUB213PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PD_BCST: bad operands")
}

// VFMSUB213PD_BCST_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213PD.BCST.Z m64 zmm k zmm
// 	VFMSUB213PD.BCST.Z m64 xmm k xmm
// 	VFMSUB213PD.BCST.Z m64 ymm k ymm
func VFMSUB213PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PD_BCST_Z: bad operands")
}

// VFMSUB213PD_RD_SAE: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUB213PD.RD_SAE zmm zmm k zmm
// 	VFMSUB213PD.RD_SAE zmm zmm zmm
func VFMSUB213PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PD_RD_SAE: bad operands")
}

// VFMSUB213PD_RD_SAE_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213PD.RD_SAE.Z zmm zmm k zmm
func VFMSUB213PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PD_RD_SAE_Z: bad operands")
}

// VFMSUB213PD_RN_SAE: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUB213PD.RN_SAE zmm zmm k zmm
// 	VFMSUB213PD.RN_SAE zmm zmm zmm
func VFMSUB213PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PD_RN_SAE: bad operands")
}

// VFMSUB213PD_RN_SAE_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213PD.RN_SAE.Z zmm zmm k zmm
func VFMSUB213PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PD_RN_SAE_Z: bad operands")
}

// VFMSUB213PD_RU_SAE: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUB213PD.RU_SAE zmm zmm k zmm
// 	VFMSUB213PD.RU_SAE zmm zmm zmm
func VFMSUB213PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PD_RU_SAE: bad operands")
}

// VFMSUB213PD_RU_SAE_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213PD.RU_SAE.Z zmm zmm k zmm
func VFMSUB213PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PD_RU_SAE_Z: bad operands")
}

// VFMSUB213PD_RZ_SAE: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUB213PD.RZ_SAE zmm zmm k zmm
// 	VFMSUB213PD.RZ_SAE zmm zmm zmm
func VFMSUB213PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PD_RZ_SAE: bad operands")
}

// VFMSUB213PD_RZ_SAE_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213PD.RZ_SAE.Z zmm zmm k zmm
func VFMSUB213PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PD_RZ_SAE_Z: bad operands")
}

// VFMSUB213PD_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213PD.Z m512 zmm k zmm
// 	VFMSUB213PD.Z zmm  zmm k zmm
// 	VFMSUB213PD.Z m128 xmm k xmm
// 	VFMSUB213PD.Z m256 ymm k ymm
// 	VFMSUB213PD.Z xmm  xmm k xmm
// 	VFMSUB213PD.Z ymm  ymm k ymm
func VFMSUB213PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PD_Z: bad operands")
}

// VFMSUB213PS: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUB213PS m128 xmm xmm
// 	VFMSUB213PS m256 ymm ymm
// 	VFMSUB213PS xmm  xmm xmm
// 	VFMSUB213PS ymm  ymm ymm
// 	VFMSUB213PS m512 zmm k zmm
// 	VFMSUB213PS m512 zmm zmm
// 	VFMSUB213PS zmm  zmm k zmm
// 	VFMSUB213PS zmm  zmm zmm
// 	VFMSUB213PS m128 xmm k xmm
// 	VFMSUB213PS m256 ymm k ymm
// 	VFMSUB213PS xmm  xmm k xmm
// 	VFMSUB213PS ymm  ymm k ymm
func VFMSUB213PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PS: bad operands")
}

// VFMSUB213PS_BCST: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMSUB213PS.BCST m32 zmm k zmm
// 	VFMSUB213PS.BCST m32 zmm zmm
// 	VFMSUB213PS.BCST m32 xmm k xmm
// 	VFMSUB213PS.BCST m32 xmm xmm
// 	VFMSUB213PS.BCST m32 ymm k ymm
// 	VFMSUB213PS.BCST m32 ymm ymm
func VFMSUB213PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PS_BCST: bad operands")
}

// VFMSUB213PS_BCST_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213PS.BCST.Z m32 zmm k zmm
// 	VFMSUB213PS.BCST.Z m32 xmm k xmm
// 	VFMSUB213PS.BCST.Z m32 ymm k ymm
func VFMSUB213PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PS_BCST_Z: bad operands")
}

// VFMSUB213PS_RD_SAE: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUB213PS.RD_SAE zmm zmm k zmm
// 	VFMSUB213PS.RD_SAE zmm zmm zmm
func VFMSUB213PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PS_RD_SAE: bad operands")
}

// VFMSUB213PS_RD_SAE_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213PS.RD_SAE.Z zmm zmm k zmm
func VFMSUB213PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PS_RD_SAE_Z: bad operands")
}

// VFMSUB213PS_RN_SAE: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUB213PS.RN_SAE zmm zmm k zmm
// 	VFMSUB213PS.RN_SAE zmm zmm zmm
func VFMSUB213PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PS_RN_SAE: bad operands")
}

// VFMSUB213PS_RN_SAE_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213PS.RN_SAE.Z zmm zmm k zmm
func VFMSUB213PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PS_RN_SAE_Z: bad operands")
}

// VFMSUB213PS_RU_SAE: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUB213PS.RU_SAE zmm zmm k zmm
// 	VFMSUB213PS.RU_SAE zmm zmm zmm
func VFMSUB213PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PS_RU_SAE: bad operands")
}

// VFMSUB213PS_RU_SAE_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213PS.RU_SAE.Z zmm zmm k zmm
func VFMSUB213PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PS_RU_SAE_Z: bad operands")
}

// VFMSUB213PS_RZ_SAE: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUB213PS.RZ_SAE zmm zmm k zmm
// 	VFMSUB213PS.RZ_SAE zmm zmm zmm
func VFMSUB213PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PS_RZ_SAE: bad operands")
}

// VFMSUB213PS_RZ_SAE_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213PS.RZ_SAE.Z zmm zmm k zmm
func VFMSUB213PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PS_RZ_SAE_Z: bad operands")
}

// VFMSUB213PS_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213PS.Z m512 zmm k zmm
// 	VFMSUB213PS.Z zmm  zmm k zmm
// 	VFMSUB213PS.Z m128 xmm k xmm
// 	VFMSUB213PS.Z m256 ymm k ymm
// 	VFMSUB213PS.Z xmm  xmm k xmm
// 	VFMSUB213PS.Z ymm  ymm k ymm
func VFMSUB213PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213PS_Z: bad operands")
}

// VFMSUB213SD: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUB213SD m64 xmm xmm
// 	VFMSUB213SD xmm xmm xmm
// 	VFMSUB213SD m64 xmm k xmm
// 	VFMSUB213SD xmm xmm k xmm
func VFMSUB213SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SD: bad operands")
}

// VFMSUB213SD_RD_SAE: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUB213SD.RD_SAE xmm xmm k xmm
// 	VFMSUB213SD.RD_SAE xmm xmm xmm
func VFMSUB213SD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SD_RD_SAE: bad operands")
}

// VFMSUB213SD_RD_SAE_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213SD.RD_SAE.Z xmm xmm k xmm
func VFMSUB213SD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SD_RD_SAE_Z: bad operands")
}

// VFMSUB213SD_RN_SAE: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUB213SD.RN_SAE xmm xmm k xmm
// 	VFMSUB213SD.RN_SAE xmm xmm xmm
func VFMSUB213SD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SD_RN_SAE: bad operands")
}

// VFMSUB213SD_RN_SAE_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213SD.RN_SAE.Z xmm xmm k xmm
func VFMSUB213SD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SD_RN_SAE_Z: bad operands")
}

// VFMSUB213SD_RU_SAE: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUB213SD.RU_SAE xmm xmm k xmm
// 	VFMSUB213SD.RU_SAE xmm xmm xmm
func VFMSUB213SD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SD_RU_SAE: bad operands")
}

// VFMSUB213SD_RU_SAE_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213SD.RU_SAE.Z xmm xmm k xmm
func VFMSUB213SD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SD_RU_SAE_Z: bad operands")
}

// VFMSUB213SD_RZ_SAE: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUB213SD.RZ_SAE xmm xmm k xmm
// 	VFMSUB213SD.RZ_SAE xmm xmm xmm
func VFMSUB213SD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SD_RZ_SAE: bad operands")
}

// VFMSUB213SD_RZ_SAE_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213SD.RZ_SAE.Z xmm xmm k xmm
func VFMSUB213SD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SD_RZ_SAE_Z: bad operands")
}

// VFMSUB213SD_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213SD.Z m64 xmm k xmm
// 	VFMSUB213SD.Z xmm xmm k xmm
func VFMSUB213SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SD_Z: bad operands")
}

// VFMSUB213SS: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUB213SS m32 xmm xmm
// 	VFMSUB213SS xmm xmm xmm
// 	VFMSUB213SS m32 xmm k xmm
// 	VFMSUB213SS xmm xmm k xmm
func VFMSUB213SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SS: bad operands")
}

// VFMSUB213SS_RD_SAE: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUB213SS.RD_SAE xmm xmm k xmm
// 	VFMSUB213SS.RD_SAE xmm xmm xmm
func VFMSUB213SS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SS_RD_SAE: bad operands")
}

// VFMSUB213SS_RD_SAE_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213SS.RD_SAE.Z xmm xmm k xmm
func VFMSUB213SS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SS_RD_SAE_Z: bad operands")
}

// VFMSUB213SS_RN_SAE: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUB213SS.RN_SAE xmm xmm k xmm
// 	VFMSUB213SS.RN_SAE xmm xmm xmm
func VFMSUB213SS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SS_RN_SAE: bad operands")
}

// VFMSUB213SS_RN_SAE_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213SS.RN_SAE.Z xmm xmm k xmm
func VFMSUB213SS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SS_RN_SAE_Z: bad operands")
}

// VFMSUB213SS_RU_SAE: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUB213SS.RU_SAE xmm xmm k xmm
// 	VFMSUB213SS.RU_SAE xmm xmm xmm
func VFMSUB213SS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SS_RU_SAE: bad operands")
}

// VFMSUB213SS_RU_SAE_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213SS.RU_SAE.Z xmm xmm k xmm
func VFMSUB213SS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SS_RU_SAE_Z: bad operands")
}

// VFMSUB213SS_RZ_SAE: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUB213SS.RZ_SAE xmm xmm k xmm
// 	VFMSUB213SS.RZ_SAE xmm xmm xmm
func VFMSUB213SS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SS_RZ_SAE: bad operands")
}

// VFMSUB213SS_RZ_SAE_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213SS.RZ_SAE.Z xmm xmm k xmm
func VFMSUB213SS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SS_RZ_SAE_Z: bad operands")
}

// VFMSUB213SS_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUB213SS.Z m32 xmm k xmm
// 	VFMSUB213SS.Z xmm xmm k xmm
func VFMSUB213SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB213SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB213SS_Z: bad operands")
}

// VFMSUB231PD: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUB231PD m128 xmm xmm
// 	VFMSUB231PD m256 ymm ymm
// 	VFMSUB231PD xmm  xmm xmm
// 	VFMSUB231PD ymm  ymm ymm
// 	VFMSUB231PD m512 zmm k zmm
// 	VFMSUB231PD m512 zmm zmm
// 	VFMSUB231PD zmm  zmm k zmm
// 	VFMSUB231PD zmm  zmm zmm
// 	VFMSUB231PD m128 xmm k xmm
// 	VFMSUB231PD m256 ymm k ymm
// 	VFMSUB231PD xmm  xmm k xmm
// 	VFMSUB231PD ymm  ymm k ymm
func VFMSUB231PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PD: bad operands")
}

// VFMSUB231PD_BCST: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMSUB231PD.BCST m64 zmm k zmm
// 	VFMSUB231PD.BCST m64 zmm zmm
// 	VFMSUB231PD.BCST m64 xmm k xmm
// 	VFMSUB231PD.BCST m64 xmm xmm
// 	VFMSUB231PD.BCST m64 ymm k ymm
// 	VFMSUB231PD.BCST m64 ymm ymm
func VFMSUB231PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PD_BCST: bad operands")
}

// VFMSUB231PD_BCST_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231PD.BCST.Z m64 zmm k zmm
// 	VFMSUB231PD.BCST.Z m64 xmm k xmm
// 	VFMSUB231PD.BCST.Z m64 ymm k ymm
func VFMSUB231PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PD_BCST_Z: bad operands")
}

// VFMSUB231PD_RD_SAE: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUB231PD.RD_SAE zmm zmm k zmm
// 	VFMSUB231PD.RD_SAE zmm zmm zmm
func VFMSUB231PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PD_RD_SAE: bad operands")
}

// VFMSUB231PD_RD_SAE_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231PD.RD_SAE.Z zmm zmm k zmm
func VFMSUB231PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PD_RD_SAE_Z: bad operands")
}

// VFMSUB231PD_RN_SAE: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUB231PD.RN_SAE zmm zmm k zmm
// 	VFMSUB231PD.RN_SAE zmm zmm zmm
func VFMSUB231PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PD_RN_SAE: bad operands")
}

// VFMSUB231PD_RN_SAE_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231PD.RN_SAE.Z zmm zmm k zmm
func VFMSUB231PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PD_RN_SAE_Z: bad operands")
}

// VFMSUB231PD_RU_SAE: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUB231PD.RU_SAE zmm zmm k zmm
// 	VFMSUB231PD.RU_SAE zmm zmm zmm
func VFMSUB231PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PD_RU_SAE: bad operands")
}

// VFMSUB231PD_RU_SAE_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231PD.RU_SAE.Z zmm zmm k zmm
func VFMSUB231PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PD_RU_SAE_Z: bad operands")
}

// VFMSUB231PD_RZ_SAE: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUB231PD.RZ_SAE zmm zmm k zmm
// 	VFMSUB231PD.RZ_SAE zmm zmm zmm
func VFMSUB231PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PD_RZ_SAE: bad operands")
}

// VFMSUB231PD_RZ_SAE_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231PD.RZ_SAE.Z zmm zmm k zmm
func VFMSUB231PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PD_RZ_SAE_Z: bad operands")
}

// VFMSUB231PD_Z: Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231PD.Z m512 zmm k zmm
// 	VFMSUB231PD.Z zmm  zmm k zmm
// 	VFMSUB231PD.Z m128 xmm k xmm
// 	VFMSUB231PD.Z m256 ymm k ymm
// 	VFMSUB231PD.Z xmm  xmm k xmm
// 	VFMSUB231PD.Z ymm  ymm k ymm
func VFMSUB231PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PD_Z: bad operands")
}

// VFMSUB231PS: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUB231PS m128 xmm xmm
// 	VFMSUB231PS m256 ymm ymm
// 	VFMSUB231PS xmm  xmm xmm
// 	VFMSUB231PS ymm  ymm ymm
// 	VFMSUB231PS m512 zmm k zmm
// 	VFMSUB231PS m512 zmm zmm
// 	VFMSUB231PS zmm  zmm k zmm
// 	VFMSUB231PS zmm  zmm zmm
// 	VFMSUB231PS m128 xmm k xmm
// 	VFMSUB231PS m256 ymm k ymm
// 	VFMSUB231PS xmm  xmm k xmm
// 	VFMSUB231PS ymm  ymm k ymm
func VFMSUB231PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PS: bad operands")
}

// VFMSUB231PS_BCST: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMSUB231PS.BCST m32 zmm k zmm
// 	VFMSUB231PS.BCST m32 zmm zmm
// 	VFMSUB231PS.BCST m32 xmm k xmm
// 	VFMSUB231PS.BCST m32 xmm xmm
// 	VFMSUB231PS.BCST m32 ymm k ymm
// 	VFMSUB231PS.BCST m32 ymm ymm
func VFMSUB231PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PS_BCST: bad operands")
}

// VFMSUB231PS_BCST_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231PS.BCST.Z m32 zmm k zmm
// 	VFMSUB231PS.BCST.Z m32 xmm k xmm
// 	VFMSUB231PS.BCST.Z m32 ymm k ymm
func VFMSUB231PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PS_BCST_Z: bad operands")
}

// VFMSUB231PS_RD_SAE: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUB231PS.RD_SAE zmm zmm k zmm
// 	VFMSUB231PS.RD_SAE zmm zmm zmm
func VFMSUB231PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PS_RD_SAE: bad operands")
}

// VFMSUB231PS_RD_SAE_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231PS.RD_SAE.Z zmm zmm k zmm
func VFMSUB231PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PS_RD_SAE_Z: bad operands")
}

// VFMSUB231PS_RN_SAE: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUB231PS.RN_SAE zmm zmm k zmm
// 	VFMSUB231PS.RN_SAE zmm zmm zmm
func VFMSUB231PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PS_RN_SAE: bad operands")
}

// VFMSUB231PS_RN_SAE_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231PS.RN_SAE.Z zmm zmm k zmm
func VFMSUB231PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PS_RN_SAE_Z: bad operands")
}

// VFMSUB231PS_RU_SAE: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUB231PS.RU_SAE zmm zmm k zmm
// 	VFMSUB231PS.RU_SAE zmm zmm zmm
func VFMSUB231PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PS_RU_SAE: bad operands")
}

// VFMSUB231PS_RU_SAE_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231PS.RU_SAE.Z zmm zmm k zmm
func VFMSUB231PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PS_RU_SAE_Z: bad operands")
}

// VFMSUB231PS_RZ_SAE: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUB231PS.RZ_SAE zmm zmm k zmm
// 	VFMSUB231PS.RZ_SAE zmm zmm zmm
func VFMSUB231PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PS_RZ_SAE: bad operands")
}

// VFMSUB231PS_RZ_SAE_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231PS.RZ_SAE.Z zmm zmm k zmm
func VFMSUB231PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PS_RZ_SAE_Z: bad operands")
}

// VFMSUB231PS_Z: Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231PS.Z m512 zmm k zmm
// 	VFMSUB231PS.Z zmm  zmm k zmm
// 	VFMSUB231PS.Z m128 xmm k xmm
// 	VFMSUB231PS.Z m256 ymm k ymm
// 	VFMSUB231PS.Z xmm  xmm k xmm
// 	VFMSUB231PS.Z ymm  ymm k ymm
func VFMSUB231PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231PS_Z: bad operands")
}

// VFMSUB231SD: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUB231SD m64 xmm xmm
// 	VFMSUB231SD xmm xmm xmm
// 	VFMSUB231SD m64 xmm k xmm
// 	VFMSUB231SD xmm xmm k xmm
func VFMSUB231SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SD: bad operands")
}

// VFMSUB231SD_RD_SAE: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUB231SD.RD_SAE xmm xmm k xmm
// 	VFMSUB231SD.RD_SAE xmm xmm xmm
func VFMSUB231SD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SD_RD_SAE: bad operands")
}

// VFMSUB231SD_RD_SAE_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231SD.RD_SAE.Z xmm xmm k xmm
func VFMSUB231SD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SD_RD_SAE_Z: bad operands")
}

// VFMSUB231SD_RN_SAE: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUB231SD.RN_SAE xmm xmm k xmm
// 	VFMSUB231SD.RN_SAE xmm xmm xmm
func VFMSUB231SD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SD_RN_SAE: bad operands")
}

// VFMSUB231SD_RN_SAE_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231SD.RN_SAE.Z xmm xmm k xmm
func VFMSUB231SD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SD_RN_SAE_Z: bad operands")
}

// VFMSUB231SD_RU_SAE: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUB231SD.RU_SAE xmm xmm k xmm
// 	VFMSUB231SD.RU_SAE xmm xmm xmm
func VFMSUB231SD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SD_RU_SAE: bad operands")
}

// VFMSUB231SD_RU_SAE_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231SD.RU_SAE.Z xmm xmm k xmm
func VFMSUB231SD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SD_RU_SAE_Z: bad operands")
}

// VFMSUB231SD_RZ_SAE: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUB231SD.RZ_SAE xmm xmm k xmm
// 	VFMSUB231SD.RZ_SAE xmm xmm xmm
func VFMSUB231SD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SD_RZ_SAE: bad operands")
}

// VFMSUB231SD_RZ_SAE_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231SD.RZ_SAE.Z xmm xmm k xmm
func VFMSUB231SD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SD_RZ_SAE_Z: bad operands")
}

// VFMSUB231SD_Z: Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231SD.Z m64 xmm k xmm
// 	VFMSUB231SD.Z xmm xmm k xmm
func VFMSUB231SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SD_Z: bad operands")
}

// VFMSUB231SS: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUB231SS m32 xmm xmm
// 	VFMSUB231SS xmm xmm xmm
// 	VFMSUB231SS m32 xmm k xmm
// 	VFMSUB231SS xmm xmm k xmm
func VFMSUB231SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SS: bad operands")
}

// VFMSUB231SS_RD_SAE: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUB231SS.RD_SAE xmm xmm k xmm
// 	VFMSUB231SS.RD_SAE xmm xmm xmm
func VFMSUB231SS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SS_RD_SAE: bad operands")
}

// VFMSUB231SS_RD_SAE_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231SS.RD_SAE.Z xmm xmm k xmm
func VFMSUB231SS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SS_RD_SAE_Z: bad operands")
}

// VFMSUB231SS_RN_SAE: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUB231SS.RN_SAE xmm xmm k xmm
// 	VFMSUB231SS.RN_SAE xmm xmm xmm
func VFMSUB231SS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SS_RN_SAE: bad operands")
}

// VFMSUB231SS_RN_SAE_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231SS.RN_SAE.Z xmm xmm k xmm
func VFMSUB231SS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SS_RN_SAE_Z: bad operands")
}

// VFMSUB231SS_RU_SAE: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUB231SS.RU_SAE xmm xmm k xmm
// 	VFMSUB231SS.RU_SAE xmm xmm xmm
func VFMSUB231SS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SS_RU_SAE: bad operands")
}

// VFMSUB231SS_RU_SAE_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231SS.RU_SAE.Z xmm xmm k xmm
func VFMSUB231SS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SS_RU_SAE_Z: bad operands")
}

// VFMSUB231SS_RZ_SAE: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUB231SS.RZ_SAE xmm xmm k xmm
// 	VFMSUB231SS.RZ_SAE xmm xmm xmm
func VFMSUB231SS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SS_RZ_SAE: bad operands")
}

// VFMSUB231SS_RZ_SAE_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231SS.RZ_SAE.Z xmm xmm k xmm
func VFMSUB231SS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SS_RZ_SAE_Z: bad operands")
}

// VFMSUB231SS_Z: Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUB231SS.Z m32 xmm k xmm
// 	VFMSUB231SS.Z xmm xmm k xmm
func VFMSUB231SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFMSUB231SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUB231SS_Z: bad operands")
}

// VFMSUBADD132PD: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUBADD132PD m128 xmm xmm
// 	VFMSUBADD132PD m256 ymm ymm
// 	VFMSUBADD132PD xmm  xmm xmm
// 	VFMSUBADD132PD ymm  ymm ymm
// 	VFMSUBADD132PD m512 zmm k zmm
// 	VFMSUBADD132PD m512 zmm zmm
// 	VFMSUBADD132PD zmm  zmm k zmm
// 	VFMSUBADD132PD zmm  zmm zmm
// 	VFMSUBADD132PD m128 xmm k xmm
// 	VFMSUBADD132PD m256 ymm k ymm
// 	VFMSUBADD132PD xmm  xmm k xmm
// 	VFMSUBADD132PD ymm  ymm k ymm
func VFMSUBADD132PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PD: bad operands")
}

// VFMSUBADD132PD_BCST: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMSUBADD132PD.BCST m64 zmm k zmm
// 	VFMSUBADD132PD.BCST m64 zmm zmm
// 	VFMSUBADD132PD.BCST m64 xmm k xmm
// 	VFMSUBADD132PD.BCST m64 xmm xmm
// 	VFMSUBADD132PD.BCST m64 ymm k ymm
// 	VFMSUBADD132PD.BCST m64 ymm ymm
func VFMSUBADD132PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PD_BCST: bad operands")
}

// VFMSUBADD132PD_BCST_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD132PD.BCST.Z m64 zmm k zmm
// 	VFMSUBADD132PD.BCST.Z m64 xmm k xmm
// 	VFMSUBADD132PD.BCST.Z m64 ymm k ymm
func VFMSUBADD132PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PD_BCST_Z: bad operands")
}

// VFMSUBADD132PD_RD_SAE: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUBADD132PD.RD_SAE zmm zmm k zmm
// 	VFMSUBADD132PD.RD_SAE zmm zmm zmm
func VFMSUBADD132PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PD_RD_SAE: bad operands")
}

// VFMSUBADD132PD_RD_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD132PD.RD_SAE.Z zmm zmm k zmm
func VFMSUBADD132PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PD_RD_SAE_Z: bad operands")
}

// VFMSUBADD132PD_RN_SAE: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUBADD132PD.RN_SAE zmm zmm k zmm
// 	VFMSUBADD132PD.RN_SAE zmm zmm zmm
func VFMSUBADD132PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PD_RN_SAE: bad operands")
}

// VFMSUBADD132PD_RN_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD132PD.RN_SAE.Z zmm zmm k zmm
func VFMSUBADD132PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PD_RN_SAE_Z: bad operands")
}

// VFMSUBADD132PD_RU_SAE: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUBADD132PD.RU_SAE zmm zmm k zmm
// 	VFMSUBADD132PD.RU_SAE zmm zmm zmm
func VFMSUBADD132PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PD_RU_SAE: bad operands")
}

// VFMSUBADD132PD_RU_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD132PD.RU_SAE.Z zmm zmm k zmm
func VFMSUBADD132PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PD_RU_SAE_Z: bad operands")
}

// VFMSUBADD132PD_RZ_SAE: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUBADD132PD.RZ_SAE zmm zmm k zmm
// 	VFMSUBADD132PD.RZ_SAE zmm zmm zmm
func VFMSUBADD132PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PD_RZ_SAE: bad operands")
}

// VFMSUBADD132PD_RZ_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD132PD.RZ_SAE.Z zmm zmm k zmm
func VFMSUBADD132PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PD_RZ_SAE_Z: bad operands")
}

// VFMSUBADD132PD_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD132PD.Z m512 zmm k zmm
// 	VFMSUBADD132PD.Z zmm  zmm k zmm
// 	VFMSUBADD132PD.Z m128 xmm k xmm
// 	VFMSUBADD132PD.Z m256 ymm k ymm
// 	VFMSUBADD132PD.Z xmm  xmm k xmm
// 	VFMSUBADD132PD.Z ymm  ymm k ymm
func VFMSUBADD132PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PD_Z: bad operands")
}

// VFMSUBADD132PS: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUBADD132PS m128 xmm xmm
// 	VFMSUBADD132PS m256 ymm ymm
// 	VFMSUBADD132PS xmm  xmm xmm
// 	VFMSUBADD132PS ymm  ymm ymm
// 	VFMSUBADD132PS m512 zmm k zmm
// 	VFMSUBADD132PS m512 zmm zmm
// 	VFMSUBADD132PS zmm  zmm k zmm
// 	VFMSUBADD132PS zmm  zmm zmm
// 	VFMSUBADD132PS m128 xmm k xmm
// 	VFMSUBADD132PS m256 ymm k ymm
// 	VFMSUBADD132PS xmm  xmm k xmm
// 	VFMSUBADD132PS ymm  ymm k ymm
func VFMSUBADD132PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PS: bad operands")
}

// VFMSUBADD132PS_BCST: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMSUBADD132PS.BCST m32 zmm k zmm
// 	VFMSUBADD132PS.BCST m32 zmm zmm
// 	VFMSUBADD132PS.BCST m32 xmm k xmm
// 	VFMSUBADD132PS.BCST m32 xmm xmm
// 	VFMSUBADD132PS.BCST m32 ymm k ymm
// 	VFMSUBADD132PS.BCST m32 ymm ymm
func VFMSUBADD132PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PS_BCST: bad operands")
}

// VFMSUBADD132PS_BCST_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD132PS.BCST.Z m32 zmm k zmm
// 	VFMSUBADD132PS.BCST.Z m32 xmm k xmm
// 	VFMSUBADD132PS.BCST.Z m32 ymm k ymm
func VFMSUBADD132PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PS_BCST_Z: bad operands")
}

// VFMSUBADD132PS_RD_SAE: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUBADD132PS.RD_SAE zmm zmm k zmm
// 	VFMSUBADD132PS.RD_SAE zmm zmm zmm
func VFMSUBADD132PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PS_RD_SAE: bad operands")
}

// VFMSUBADD132PS_RD_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD132PS.RD_SAE.Z zmm zmm k zmm
func VFMSUBADD132PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PS_RD_SAE_Z: bad operands")
}

// VFMSUBADD132PS_RN_SAE: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUBADD132PS.RN_SAE zmm zmm k zmm
// 	VFMSUBADD132PS.RN_SAE zmm zmm zmm
func VFMSUBADD132PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PS_RN_SAE: bad operands")
}

// VFMSUBADD132PS_RN_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD132PS.RN_SAE.Z zmm zmm k zmm
func VFMSUBADD132PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PS_RN_SAE_Z: bad operands")
}

// VFMSUBADD132PS_RU_SAE: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUBADD132PS.RU_SAE zmm zmm k zmm
// 	VFMSUBADD132PS.RU_SAE zmm zmm zmm
func VFMSUBADD132PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PS_RU_SAE: bad operands")
}

// VFMSUBADD132PS_RU_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD132PS.RU_SAE.Z zmm zmm k zmm
func VFMSUBADD132PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PS_RU_SAE_Z: bad operands")
}

// VFMSUBADD132PS_RZ_SAE: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUBADD132PS.RZ_SAE zmm zmm k zmm
// 	VFMSUBADD132PS.RZ_SAE zmm zmm zmm
func VFMSUBADD132PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PS_RZ_SAE: bad operands")
}

// VFMSUBADD132PS_RZ_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD132PS.RZ_SAE.Z zmm zmm k zmm
func VFMSUBADD132PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PS_RZ_SAE_Z: bad operands")
}

// VFMSUBADD132PS_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD132PS.Z m512 zmm k zmm
// 	VFMSUBADD132PS.Z zmm  zmm k zmm
// 	VFMSUBADD132PS.Z m128 xmm k xmm
// 	VFMSUBADD132PS.Z m256 ymm k ymm
// 	VFMSUBADD132PS.Z xmm  xmm k xmm
// 	VFMSUBADD132PS.Z ymm  ymm k ymm
func VFMSUBADD132PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD132PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD132PS_Z: bad operands")
}

// VFMSUBADD213PD: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUBADD213PD m128 xmm xmm
// 	VFMSUBADD213PD m256 ymm ymm
// 	VFMSUBADD213PD xmm  xmm xmm
// 	VFMSUBADD213PD ymm  ymm ymm
// 	VFMSUBADD213PD m512 zmm k zmm
// 	VFMSUBADD213PD m512 zmm zmm
// 	VFMSUBADD213PD zmm  zmm k zmm
// 	VFMSUBADD213PD zmm  zmm zmm
// 	VFMSUBADD213PD m128 xmm k xmm
// 	VFMSUBADD213PD m256 ymm k ymm
// 	VFMSUBADD213PD xmm  xmm k xmm
// 	VFMSUBADD213PD ymm  ymm k ymm
func VFMSUBADD213PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PD: bad operands")
}

// VFMSUBADD213PD_BCST: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMSUBADD213PD.BCST m64 zmm k zmm
// 	VFMSUBADD213PD.BCST m64 zmm zmm
// 	VFMSUBADD213PD.BCST m64 xmm k xmm
// 	VFMSUBADD213PD.BCST m64 xmm xmm
// 	VFMSUBADD213PD.BCST m64 ymm k ymm
// 	VFMSUBADD213PD.BCST m64 ymm ymm
func VFMSUBADD213PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PD_BCST: bad operands")
}

// VFMSUBADD213PD_BCST_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD213PD.BCST.Z m64 zmm k zmm
// 	VFMSUBADD213PD.BCST.Z m64 xmm k xmm
// 	VFMSUBADD213PD.BCST.Z m64 ymm k ymm
func VFMSUBADD213PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PD_BCST_Z: bad operands")
}

// VFMSUBADD213PD_RD_SAE: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUBADD213PD.RD_SAE zmm zmm k zmm
// 	VFMSUBADD213PD.RD_SAE zmm zmm zmm
func VFMSUBADD213PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PD_RD_SAE: bad operands")
}

// VFMSUBADD213PD_RD_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD213PD.RD_SAE.Z zmm zmm k zmm
func VFMSUBADD213PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PD_RD_SAE_Z: bad operands")
}

// VFMSUBADD213PD_RN_SAE: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUBADD213PD.RN_SAE zmm zmm k zmm
// 	VFMSUBADD213PD.RN_SAE zmm zmm zmm
func VFMSUBADD213PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PD_RN_SAE: bad operands")
}

// VFMSUBADD213PD_RN_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD213PD.RN_SAE.Z zmm zmm k zmm
func VFMSUBADD213PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PD_RN_SAE_Z: bad operands")
}

// VFMSUBADD213PD_RU_SAE: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUBADD213PD.RU_SAE zmm zmm k zmm
// 	VFMSUBADD213PD.RU_SAE zmm zmm zmm
func VFMSUBADD213PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PD_RU_SAE: bad operands")
}

// VFMSUBADD213PD_RU_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD213PD.RU_SAE.Z zmm zmm k zmm
func VFMSUBADD213PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PD_RU_SAE_Z: bad operands")
}

// VFMSUBADD213PD_RZ_SAE: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUBADD213PD.RZ_SAE zmm zmm k zmm
// 	VFMSUBADD213PD.RZ_SAE zmm zmm zmm
func VFMSUBADD213PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PD_RZ_SAE: bad operands")
}

// VFMSUBADD213PD_RZ_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD213PD.RZ_SAE.Z zmm zmm k zmm
func VFMSUBADD213PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PD_RZ_SAE_Z: bad operands")
}

// VFMSUBADD213PD_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD213PD.Z m512 zmm k zmm
// 	VFMSUBADD213PD.Z zmm  zmm k zmm
// 	VFMSUBADD213PD.Z m128 xmm k xmm
// 	VFMSUBADD213PD.Z m256 ymm k ymm
// 	VFMSUBADD213PD.Z xmm  xmm k xmm
// 	VFMSUBADD213PD.Z ymm  ymm k ymm
func VFMSUBADD213PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PD_Z: bad operands")
}

// VFMSUBADD213PS: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUBADD213PS m128 xmm xmm
// 	VFMSUBADD213PS m256 ymm ymm
// 	VFMSUBADD213PS xmm  xmm xmm
// 	VFMSUBADD213PS ymm  ymm ymm
// 	VFMSUBADD213PS m512 zmm k zmm
// 	VFMSUBADD213PS m512 zmm zmm
// 	VFMSUBADD213PS zmm  zmm k zmm
// 	VFMSUBADD213PS zmm  zmm zmm
// 	VFMSUBADD213PS m128 xmm k xmm
// 	VFMSUBADD213PS m256 ymm k ymm
// 	VFMSUBADD213PS xmm  xmm k xmm
// 	VFMSUBADD213PS ymm  ymm k ymm
func VFMSUBADD213PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PS: bad operands")
}

// VFMSUBADD213PS_BCST: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMSUBADD213PS.BCST m32 zmm k zmm
// 	VFMSUBADD213PS.BCST m32 zmm zmm
// 	VFMSUBADD213PS.BCST m32 xmm k xmm
// 	VFMSUBADD213PS.BCST m32 xmm xmm
// 	VFMSUBADD213PS.BCST m32 ymm k ymm
// 	VFMSUBADD213PS.BCST m32 ymm ymm
func VFMSUBADD213PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PS_BCST: bad operands")
}

// VFMSUBADD213PS_BCST_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD213PS.BCST.Z m32 zmm k zmm
// 	VFMSUBADD213PS.BCST.Z m32 xmm k xmm
// 	VFMSUBADD213PS.BCST.Z m32 ymm k ymm
func VFMSUBADD213PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PS_BCST_Z: bad operands")
}

// VFMSUBADD213PS_RD_SAE: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUBADD213PS.RD_SAE zmm zmm k zmm
// 	VFMSUBADD213PS.RD_SAE zmm zmm zmm
func VFMSUBADD213PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PS_RD_SAE: bad operands")
}

// VFMSUBADD213PS_RD_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD213PS.RD_SAE.Z zmm zmm k zmm
func VFMSUBADD213PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PS_RD_SAE_Z: bad operands")
}

// VFMSUBADD213PS_RN_SAE: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUBADD213PS.RN_SAE zmm zmm k zmm
// 	VFMSUBADD213PS.RN_SAE zmm zmm zmm
func VFMSUBADD213PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PS_RN_SAE: bad operands")
}

// VFMSUBADD213PS_RN_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD213PS.RN_SAE.Z zmm zmm k zmm
func VFMSUBADD213PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PS_RN_SAE_Z: bad operands")
}

// VFMSUBADD213PS_RU_SAE: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUBADD213PS.RU_SAE zmm zmm k zmm
// 	VFMSUBADD213PS.RU_SAE zmm zmm zmm
func VFMSUBADD213PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PS_RU_SAE: bad operands")
}

// VFMSUBADD213PS_RU_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD213PS.RU_SAE.Z zmm zmm k zmm
func VFMSUBADD213PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PS_RU_SAE_Z: bad operands")
}

// VFMSUBADD213PS_RZ_SAE: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUBADD213PS.RZ_SAE zmm zmm k zmm
// 	VFMSUBADD213PS.RZ_SAE zmm zmm zmm
func VFMSUBADD213PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PS_RZ_SAE: bad operands")
}

// VFMSUBADD213PS_RZ_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD213PS.RZ_SAE.Z zmm zmm k zmm
func VFMSUBADD213PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PS_RZ_SAE_Z: bad operands")
}

// VFMSUBADD213PS_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD213PS.Z m512 zmm k zmm
// 	VFMSUBADD213PS.Z zmm  zmm k zmm
// 	VFMSUBADD213PS.Z m128 xmm k xmm
// 	VFMSUBADD213PS.Z m256 ymm k ymm
// 	VFMSUBADD213PS.Z xmm  xmm k xmm
// 	VFMSUBADD213PS.Z ymm  ymm k ymm
func VFMSUBADD213PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD213PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD213PS_Z: bad operands")
}

// VFMSUBADD231PD: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUBADD231PD m128 xmm xmm
// 	VFMSUBADD231PD m256 ymm ymm
// 	VFMSUBADD231PD xmm  xmm xmm
// 	VFMSUBADD231PD ymm  ymm ymm
// 	VFMSUBADD231PD m512 zmm k zmm
// 	VFMSUBADD231PD m512 zmm zmm
// 	VFMSUBADD231PD zmm  zmm k zmm
// 	VFMSUBADD231PD zmm  zmm zmm
// 	VFMSUBADD231PD m128 xmm k xmm
// 	VFMSUBADD231PD m256 ymm k ymm
// 	VFMSUBADD231PD xmm  xmm k xmm
// 	VFMSUBADD231PD ymm  ymm k ymm
func VFMSUBADD231PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PD: bad operands")
}

// VFMSUBADD231PD_BCST: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMSUBADD231PD.BCST m64 zmm k zmm
// 	VFMSUBADD231PD.BCST m64 zmm zmm
// 	VFMSUBADD231PD.BCST m64 xmm k xmm
// 	VFMSUBADD231PD.BCST m64 xmm xmm
// 	VFMSUBADD231PD.BCST m64 ymm k ymm
// 	VFMSUBADD231PD.BCST m64 ymm ymm
func VFMSUBADD231PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PD_BCST: bad operands")
}

// VFMSUBADD231PD_BCST_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD231PD.BCST.Z m64 zmm k zmm
// 	VFMSUBADD231PD.BCST.Z m64 xmm k xmm
// 	VFMSUBADD231PD.BCST.Z m64 ymm k ymm
func VFMSUBADD231PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PD_BCST_Z: bad operands")
}

// VFMSUBADD231PD_RD_SAE: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUBADD231PD.RD_SAE zmm zmm k zmm
// 	VFMSUBADD231PD.RD_SAE zmm zmm zmm
func VFMSUBADD231PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PD_RD_SAE: bad operands")
}

// VFMSUBADD231PD_RD_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD231PD.RD_SAE.Z zmm zmm k zmm
func VFMSUBADD231PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PD_RD_SAE_Z: bad operands")
}

// VFMSUBADD231PD_RN_SAE: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUBADD231PD.RN_SAE zmm zmm k zmm
// 	VFMSUBADD231PD.RN_SAE zmm zmm zmm
func VFMSUBADD231PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PD_RN_SAE: bad operands")
}

// VFMSUBADD231PD_RN_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD231PD.RN_SAE.Z zmm zmm k zmm
func VFMSUBADD231PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PD_RN_SAE_Z: bad operands")
}

// VFMSUBADD231PD_RU_SAE: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUBADD231PD.RU_SAE zmm zmm k zmm
// 	VFMSUBADD231PD.RU_SAE zmm zmm zmm
func VFMSUBADD231PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PD_RU_SAE: bad operands")
}

// VFMSUBADD231PD_RU_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD231PD.RU_SAE.Z zmm zmm k zmm
func VFMSUBADD231PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PD_RU_SAE_Z: bad operands")
}

// VFMSUBADD231PD_RZ_SAE: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUBADD231PD.RZ_SAE zmm zmm k zmm
// 	VFMSUBADD231PD.RZ_SAE zmm zmm zmm
func VFMSUBADD231PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PD_RZ_SAE: bad operands")
}

// VFMSUBADD231PD_RZ_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD231PD.RZ_SAE.Z zmm zmm k zmm
func VFMSUBADD231PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PD_RZ_SAE_Z: bad operands")
}

// VFMSUBADD231PD_Z: Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD231PD.Z m512 zmm k zmm
// 	VFMSUBADD231PD.Z zmm  zmm k zmm
// 	VFMSUBADD231PD.Z m128 xmm k xmm
// 	VFMSUBADD231PD.Z m256 ymm k ymm
// 	VFMSUBADD231PD.Z xmm  xmm k xmm
// 	VFMSUBADD231PD.Z ymm  ymm k ymm
func VFMSUBADD231PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PD_Z: bad operands")
}

// VFMSUBADD231PS: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFMSUBADD231PS m128 xmm xmm
// 	VFMSUBADD231PS m256 ymm ymm
// 	VFMSUBADD231PS xmm  xmm xmm
// 	VFMSUBADD231PS ymm  ymm ymm
// 	VFMSUBADD231PS m512 zmm k zmm
// 	VFMSUBADD231PS m512 zmm zmm
// 	VFMSUBADD231PS zmm  zmm k zmm
// 	VFMSUBADD231PS zmm  zmm zmm
// 	VFMSUBADD231PS m128 xmm k xmm
// 	VFMSUBADD231PS m256 ymm k ymm
// 	VFMSUBADD231PS xmm  xmm k xmm
// 	VFMSUBADD231PS ymm  ymm k ymm
func VFMSUBADD231PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PS: bad operands")
}

// VFMSUBADD231PS_BCST: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFMSUBADD231PS.BCST m32 zmm k zmm
// 	VFMSUBADD231PS.BCST m32 zmm zmm
// 	VFMSUBADD231PS.BCST m32 xmm k xmm
// 	VFMSUBADD231PS.BCST m32 xmm xmm
// 	VFMSUBADD231PS.BCST m32 ymm k ymm
// 	VFMSUBADD231PS.BCST m32 ymm ymm
func VFMSUBADD231PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PS_BCST: bad operands")
}

// VFMSUBADD231PS_BCST_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD231PS.BCST.Z m32 zmm k zmm
// 	VFMSUBADD231PS.BCST.Z m32 xmm k xmm
// 	VFMSUBADD231PS.BCST.Z m32 ymm k ymm
func VFMSUBADD231PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PS_BCST_Z: bad operands")
}

// VFMSUBADD231PS_RD_SAE: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFMSUBADD231PS.RD_SAE zmm zmm k zmm
// 	VFMSUBADD231PS.RD_SAE zmm zmm zmm
func VFMSUBADD231PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PS_RD_SAE: bad operands")
}

// VFMSUBADD231PS_RD_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD231PS.RD_SAE.Z zmm zmm k zmm
func VFMSUBADD231PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PS_RD_SAE_Z: bad operands")
}

// VFMSUBADD231PS_RN_SAE: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFMSUBADD231PS.RN_SAE zmm zmm k zmm
// 	VFMSUBADD231PS.RN_SAE zmm zmm zmm
func VFMSUBADD231PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PS_RN_SAE: bad operands")
}

// VFMSUBADD231PS_RN_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD231PS.RN_SAE.Z zmm zmm k zmm
func VFMSUBADD231PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PS_RN_SAE_Z: bad operands")
}

// VFMSUBADD231PS_RU_SAE: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFMSUBADD231PS.RU_SAE zmm zmm k zmm
// 	VFMSUBADD231PS.RU_SAE zmm zmm zmm
func VFMSUBADD231PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PS_RU_SAE: bad operands")
}

// VFMSUBADD231PS_RU_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD231PS.RU_SAE.Z zmm zmm k zmm
func VFMSUBADD231PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PS_RU_SAE_Z: bad operands")
}

// VFMSUBADD231PS_RZ_SAE: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFMSUBADD231PS.RZ_SAE zmm zmm k zmm
// 	VFMSUBADD231PS.RZ_SAE zmm zmm zmm
func VFMSUBADD231PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PS_RZ_SAE: bad operands")
}

// VFMSUBADD231PS_RZ_SAE_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD231PS.RZ_SAE.Z zmm zmm k zmm
func VFMSUBADD231PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PS_RZ_SAE_Z: bad operands")
}

// VFMSUBADD231PS_Z: Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFMSUBADD231PS.Z m512 zmm k zmm
// 	VFMSUBADD231PS.Z zmm  zmm k zmm
// 	VFMSUBADD231PS.Z m128 xmm k xmm
// 	VFMSUBADD231PS.Z m256 ymm k ymm
// 	VFMSUBADD231PS.Z xmm  xmm k xmm
// 	VFMSUBADD231PS.Z ymm  ymm k ymm
func VFMSUBADD231PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFMSUBADD231PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFMSUBADD231PS_Z: bad operands")
}

// VFNMADD132PD: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMADD132PD m128 xmm xmm
// 	VFNMADD132PD m256 ymm ymm
// 	VFNMADD132PD xmm  xmm xmm
// 	VFNMADD132PD ymm  ymm ymm
// 	VFNMADD132PD m512 zmm k zmm
// 	VFNMADD132PD m512 zmm zmm
// 	VFNMADD132PD zmm  zmm k zmm
// 	VFNMADD132PD zmm  zmm zmm
// 	VFNMADD132PD m128 xmm k xmm
// 	VFNMADD132PD m256 ymm k ymm
// 	VFNMADD132PD xmm  xmm k xmm
// 	VFNMADD132PD ymm  ymm k ymm
func VFNMADD132PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PD: bad operands")
}

// VFNMADD132PD_BCST: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFNMADD132PD.BCST m64 zmm k zmm
// 	VFNMADD132PD.BCST m64 zmm zmm
// 	VFNMADD132PD.BCST m64 xmm k xmm
// 	VFNMADD132PD.BCST m64 xmm xmm
// 	VFNMADD132PD.BCST m64 ymm k ymm
// 	VFNMADD132PD.BCST m64 ymm ymm
func VFNMADD132PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PD_BCST: bad operands")
}

// VFNMADD132PD_BCST_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132PD.BCST.Z m64 zmm k zmm
// 	VFNMADD132PD.BCST.Z m64 xmm k xmm
// 	VFNMADD132PD.BCST.Z m64 ymm k ymm
func VFNMADD132PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PD_BCST_Z: bad operands")
}

// VFNMADD132PD_RD_SAE: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMADD132PD.RD_SAE zmm zmm k zmm
// 	VFNMADD132PD.RD_SAE zmm zmm zmm
func VFNMADD132PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PD_RD_SAE: bad operands")
}

// VFNMADD132PD_RD_SAE_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132PD.RD_SAE.Z zmm zmm k zmm
func VFNMADD132PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PD_RD_SAE_Z: bad operands")
}

// VFNMADD132PD_RN_SAE: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMADD132PD.RN_SAE zmm zmm k zmm
// 	VFNMADD132PD.RN_SAE zmm zmm zmm
func VFNMADD132PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PD_RN_SAE: bad operands")
}

// VFNMADD132PD_RN_SAE_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132PD.RN_SAE.Z zmm zmm k zmm
func VFNMADD132PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PD_RN_SAE_Z: bad operands")
}

// VFNMADD132PD_RU_SAE: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMADD132PD.RU_SAE zmm zmm k zmm
// 	VFNMADD132PD.RU_SAE zmm zmm zmm
func VFNMADD132PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PD_RU_SAE: bad operands")
}

// VFNMADD132PD_RU_SAE_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132PD.RU_SAE.Z zmm zmm k zmm
func VFNMADD132PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PD_RU_SAE_Z: bad operands")
}

// VFNMADD132PD_RZ_SAE: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMADD132PD.RZ_SAE zmm zmm k zmm
// 	VFNMADD132PD.RZ_SAE zmm zmm zmm
func VFNMADD132PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PD_RZ_SAE: bad operands")
}

// VFNMADD132PD_RZ_SAE_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132PD.RZ_SAE.Z zmm zmm k zmm
func VFNMADD132PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PD_RZ_SAE_Z: bad operands")
}

// VFNMADD132PD_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132PD.Z m512 zmm k zmm
// 	VFNMADD132PD.Z zmm  zmm k zmm
// 	VFNMADD132PD.Z m128 xmm k xmm
// 	VFNMADD132PD.Z m256 ymm k ymm
// 	VFNMADD132PD.Z xmm  xmm k xmm
// 	VFNMADD132PD.Z ymm  ymm k ymm
func VFNMADD132PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PD_Z: bad operands")
}

// VFNMADD132PS: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMADD132PS m128 xmm xmm
// 	VFNMADD132PS m256 ymm ymm
// 	VFNMADD132PS xmm  xmm xmm
// 	VFNMADD132PS ymm  ymm ymm
// 	VFNMADD132PS m512 zmm k zmm
// 	VFNMADD132PS m512 zmm zmm
// 	VFNMADD132PS zmm  zmm k zmm
// 	VFNMADD132PS zmm  zmm zmm
// 	VFNMADD132PS m128 xmm k xmm
// 	VFNMADD132PS m256 ymm k ymm
// 	VFNMADD132PS xmm  xmm k xmm
// 	VFNMADD132PS ymm  ymm k ymm
func VFNMADD132PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PS: bad operands")
}

// VFNMADD132PS_BCST: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFNMADD132PS.BCST m32 zmm k zmm
// 	VFNMADD132PS.BCST m32 zmm zmm
// 	VFNMADD132PS.BCST m32 xmm k xmm
// 	VFNMADD132PS.BCST m32 xmm xmm
// 	VFNMADD132PS.BCST m32 ymm k ymm
// 	VFNMADD132PS.BCST m32 ymm ymm
func VFNMADD132PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PS_BCST: bad operands")
}

// VFNMADD132PS_BCST_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132PS.BCST.Z m32 zmm k zmm
// 	VFNMADD132PS.BCST.Z m32 xmm k xmm
// 	VFNMADD132PS.BCST.Z m32 ymm k ymm
func VFNMADD132PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PS_BCST_Z: bad operands")
}

// VFNMADD132PS_RD_SAE: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMADD132PS.RD_SAE zmm zmm k zmm
// 	VFNMADD132PS.RD_SAE zmm zmm zmm
func VFNMADD132PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PS_RD_SAE: bad operands")
}

// VFNMADD132PS_RD_SAE_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132PS.RD_SAE.Z zmm zmm k zmm
func VFNMADD132PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PS_RD_SAE_Z: bad operands")
}

// VFNMADD132PS_RN_SAE: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMADD132PS.RN_SAE zmm zmm k zmm
// 	VFNMADD132PS.RN_SAE zmm zmm zmm
func VFNMADD132PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PS_RN_SAE: bad operands")
}

// VFNMADD132PS_RN_SAE_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132PS.RN_SAE.Z zmm zmm k zmm
func VFNMADD132PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PS_RN_SAE_Z: bad operands")
}

// VFNMADD132PS_RU_SAE: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMADD132PS.RU_SAE zmm zmm k zmm
// 	VFNMADD132PS.RU_SAE zmm zmm zmm
func VFNMADD132PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PS_RU_SAE: bad operands")
}

// VFNMADD132PS_RU_SAE_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132PS.RU_SAE.Z zmm zmm k zmm
func VFNMADD132PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PS_RU_SAE_Z: bad operands")
}

// VFNMADD132PS_RZ_SAE: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMADD132PS.RZ_SAE zmm zmm k zmm
// 	VFNMADD132PS.RZ_SAE zmm zmm zmm
func VFNMADD132PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PS_RZ_SAE: bad operands")
}

// VFNMADD132PS_RZ_SAE_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132PS.RZ_SAE.Z zmm zmm k zmm
func VFNMADD132PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PS_RZ_SAE_Z: bad operands")
}

// VFNMADD132PS_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132PS.Z m512 zmm k zmm
// 	VFNMADD132PS.Z zmm  zmm k zmm
// 	VFNMADD132PS.Z m128 xmm k xmm
// 	VFNMADD132PS.Z m256 ymm k ymm
// 	VFNMADD132PS.Z xmm  xmm k xmm
// 	VFNMADD132PS.Z ymm  ymm k ymm
func VFNMADD132PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132PS_Z: bad operands")
}

// VFNMADD132SD: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMADD132SD m64 xmm xmm
// 	VFNMADD132SD xmm xmm xmm
// 	VFNMADD132SD m64 xmm k xmm
// 	VFNMADD132SD xmm xmm k xmm
func VFNMADD132SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SD: bad operands")
}

// VFNMADD132SD_RD_SAE: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMADD132SD.RD_SAE xmm xmm k xmm
// 	VFNMADD132SD.RD_SAE xmm xmm xmm
func VFNMADD132SD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SD_RD_SAE: bad operands")
}

// VFNMADD132SD_RD_SAE_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132SD.RD_SAE.Z xmm xmm k xmm
func VFNMADD132SD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SD_RD_SAE_Z: bad operands")
}

// VFNMADD132SD_RN_SAE: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMADD132SD.RN_SAE xmm xmm k xmm
// 	VFNMADD132SD.RN_SAE xmm xmm xmm
func VFNMADD132SD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SD_RN_SAE: bad operands")
}

// VFNMADD132SD_RN_SAE_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132SD.RN_SAE.Z xmm xmm k xmm
func VFNMADD132SD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SD_RN_SAE_Z: bad operands")
}

// VFNMADD132SD_RU_SAE: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMADD132SD.RU_SAE xmm xmm k xmm
// 	VFNMADD132SD.RU_SAE xmm xmm xmm
func VFNMADD132SD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SD_RU_SAE: bad operands")
}

// VFNMADD132SD_RU_SAE_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132SD.RU_SAE.Z xmm xmm k xmm
func VFNMADD132SD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SD_RU_SAE_Z: bad operands")
}

// VFNMADD132SD_RZ_SAE: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMADD132SD.RZ_SAE xmm xmm k xmm
// 	VFNMADD132SD.RZ_SAE xmm xmm xmm
func VFNMADD132SD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SD_RZ_SAE: bad operands")
}

// VFNMADD132SD_RZ_SAE_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132SD.RZ_SAE.Z xmm xmm k xmm
func VFNMADD132SD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SD_RZ_SAE_Z: bad operands")
}

// VFNMADD132SD_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132SD.Z m64 xmm k xmm
// 	VFNMADD132SD.Z xmm xmm k xmm
func VFNMADD132SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SD_Z: bad operands")
}

// VFNMADD132SS: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMADD132SS m32 xmm xmm
// 	VFNMADD132SS xmm xmm xmm
// 	VFNMADD132SS m32 xmm k xmm
// 	VFNMADD132SS xmm xmm k xmm
func VFNMADD132SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SS: bad operands")
}

// VFNMADD132SS_RD_SAE: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMADD132SS.RD_SAE xmm xmm k xmm
// 	VFNMADD132SS.RD_SAE xmm xmm xmm
func VFNMADD132SS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SS_RD_SAE: bad operands")
}

// VFNMADD132SS_RD_SAE_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132SS.RD_SAE.Z xmm xmm k xmm
func VFNMADD132SS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SS_RD_SAE_Z: bad operands")
}

// VFNMADD132SS_RN_SAE: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMADD132SS.RN_SAE xmm xmm k xmm
// 	VFNMADD132SS.RN_SAE xmm xmm xmm
func VFNMADD132SS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SS_RN_SAE: bad operands")
}

// VFNMADD132SS_RN_SAE_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132SS.RN_SAE.Z xmm xmm k xmm
func VFNMADD132SS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SS_RN_SAE_Z: bad operands")
}

// VFNMADD132SS_RU_SAE: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMADD132SS.RU_SAE xmm xmm k xmm
// 	VFNMADD132SS.RU_SAE xmm xmm xmm
func VFNMADD132SS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SS_RU_SAE: bad operands")
}

// VFNMADD132SS_RU_SAE_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132SS.RU_SAE.Z xmm xmm k xmm
func VFNMADD132SS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SS_RU_SAE_Z: bad operands")
}

// VFNMADD132SS_RZ_SAE: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMADD132SS.RZ_SAE xmm xmm k xmm
// 	VFNMADD132SS.RZ_SAE xmm xmm xmm
func VFNMADD132SS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SS_RZ_SAE: bad operands")
}

// VFNMADD132SS_RZ_SAE_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132SS.RZ_SAE.Z xmm xmm k xmm
func VFNMADD132SS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SS_RZ_SAE_Z: bad operands")
}

// VFNMADD132SS_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMADD132SS.Z m32 xmm k xmm
// 	VFNMADD132SS.Z xmm xmm k xmm
func VFNMADD132SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD132SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD132SS_Z: bad operands")
}

// VFNMADD213PD: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMADD213PD m128 xmm xmm
// 	VFNMADD213PD m256 ymm ymm
// 	VFNMADD213PD xmm  xmm xmm
// 	VFNMADD213PD ymm  ymm ymm
// 	VFNMADD213PD m512 zmm k zmm
// 	VFNMADD213PD m512 zmm zmm
// 	VFNMADD213PD zmm  zmm k zmm
// 	VFNMADD213PD zmm  zmm zmm
// 	VFNMADD213PD m128 xmm k xmm
// 	VFNMADD213PD m256 ymm k ymm
// 	VFNMADD213PD xmm  xmm k xmm
// 	VFNMADD213PD ymm  ymm k ymm
func VFNMADD213PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PD: bad operands")
}

// VFNMADD213PD_BCST: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFNMADD213PD.BCST m64 zmm k zmm
// 	VFNMADD213PD.BCST m64 zmm zmm
// 	VFNMADD213PD.BCST m64 xmm k xmm
// 	VFNMADD213PD.BCST m64 xmm xmm
// 	VFNMADD213PD.BCST m64 ymm k ymm
// 	VFNMADD213PD.BCST m64 ymm ymm
func VFNMADD213PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PD_BCST: bad operands")
}

// VFNMADD213PD_BCST_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213PD.BCST.Z m64 zmm k zmm
// 	VFNMADD213PD.BCST.Z m64 xmm k xmm
// 	VFNMADD213PD.BCST.Z m64 ymm k ymm
func VFNMADD213PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PD_BCST_Z: bad operands")
}

// VFNMADD213PD_RD_SAE: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMADD213PD.RD_SAE zmm zmm k zmm
// 	VFNMADD213PD.RD_SAE zmm zmm zmm
func VFNMADD213PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PD_RD_SAE: bad operands")
}

// VFNMADD213PD_RD_SAE_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213PD.RD_SAE.Z zmm zmm k zmm
func VFNMADD213PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PD_RD_SAE_Z: bad operands")
}

// VFNMADD213PD_RN_SAE: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMADD213PD.RN_SAE zmm zmm k zmm
// 	VFNMADD213PD.RN_SAE zmm zmm zmm
func VFNMADD213PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PD_RN_SAE: bad operands")
}

// VFNMADD213PD_RN_SAE_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213PD.RN_SAE.Z zmm zmm k zmm
func VFNMADD213PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PD_RN_SAE_Z: bad operands")
}

// VFNMADD213PD_RU_SAE: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMADD213PD.RU_SAE zmm zmm k zmm
// 	VFNMADD213PD.RU_SAE zmm zmm zmm
func VFNMADD213PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PD_RU_SAE: bad operands")
}

// VFNMADD213PD_RU_SAE_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213PD.RU_SAE.Z zmm zmm k zmm
func VFNMADD213PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PD_RU_SAE_Z: bad operands")
}

// VFNMADD213PD_RZ_SAE: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMADD213PD.RZ_SAE zmm zmm k zmm
// 	VFNMADD213PD.RZ_SAE zmm zmm zmm
func VFNMADD213PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PD_RZ_SAE: bad operands")
}

// VFNMADD213PD_RZ_SAE_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213PD.RZ_SAE.Z zmm zmm k zmm
func VFNMADD213PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PD_RZ_SAE_Z: bad operands")
}

// VFNMADD213PD_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213PD.Z m512 zmm k zmm
// 	VFNMADD213PD.Z zmm  zmm k zmm
// 	VFNMADD213PD.Z m128 xmm k xmm
// 	VFNMADD213PD.Z m256 ymm k ymm
// 	VFNMADD213PD.Z xmm  xmm k xmm
// 	VFNMADD213PD.Z ymm  ymm k ymm
func VFNMADD213PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PD_Z: bad operands")
}

// VFNMADD213PS: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMADD213PS m128 xmm xmm
// 	VFNMADD213PS m256 ymm ymm
// 	VFNMADD213PS xmm  xmm xmm
// 	VFNMADD213PS ymm  ymm ymm
// 	VFNMADD213PS m512 zmm k zmm
// 	VFNMADD213PS m512 zmm zmm
// 	VFNMADD213PS zmm  zmm k zmm
// 	VFNMADD213PS zmm  zmm zmm
// 	VFNMADD213PS m128 xmm k xmm
// 	VFNMADD213PS m256 ymm k ymm
// 	VFNMADD213PS xmm  xmm k xmm
// 	VFNMADD213PS ymm  ymm k ymm
func VFNMADD213PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PS: bad operands")
}

// VFNMADD213PS_BCST: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFNMADD213PS.BCST m32 zmm k zmm
// 	VFNMADD213PS.BCST m32 zmm zmm
// 	VFNMADD213PS.BCST m32 xmm k xmm
// 	VFNMADD213PS.BCST m32 xmm xmm
// 	VFNMADD213PS.BCST m32 ymm k ymm
// 	VFNMADD213PS.BCST m32 ymm ymm
func VFNMADD213PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PS_BCST: bad operands")
}

// VFNMADD213PS_BCST_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213PS.BCST.Z m32 zmm k zmm
// 	VFNMADD213PS.BCST.Z m32 xmm k xmm
// 	VFNMADD213PS.BCST.Z m32 ymm k ymm
func VFNMADD213PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PS_BCST_Z: bad operands")
}

// VFNMADD213PS_RD_SAE: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMADD213PS.RD_SAE zmm zmm k zmm
// 	VFNMADD213PS.RD_SAE zmm zmm zmm
func VFNMADD213PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PS_RD_SAE: bad operands")
}

// VFNMADD213PS_RD_SAE_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213PS.RD_SAE.Z zmm zmm k zmm
func VFNMADD213PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PS_RD_SAE_Z: bad operands")
}

// VFNMADD213PS_RN_SAE: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMADD213PS.RN_SAE zmm zmm k zmm
// 	VFNMADD213PS.RN_SAE zmm zmm zmm
func VFNMADD213PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PS_RN_SAE: bad operands")
}

// VFNMADD213PS_RN_SAE_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213PS.RN_SAE.Z zmm zmm k zmm
func VFNMADD213PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PS_RN_SAE_Z: bad operands")
}

// VFNMADD213PS_RU_SAE: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMADD213PS.RU_SAE zmm zmm k zmm
// 	VFNMADD213PS.RU_SAE zmm zmm zmm
func VFNMADD213PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PS_RU_SAE: bad operands")
}

// VFNMADD213PS_RU_SAE_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213PS.RU_SAE.Z zmm zmm k zmm
func VFNMADD213PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PS_RU_SAE_Z: bad operands")
}

// VFNMADD213PS_RZ_SAE: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMADD213PS.RZ_SAE zmm zmm k zmm
// 	VFNMADD213PS.RZ_SAE zmm zmm zmm
func VFNMADD213PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PS_RZ_SAE: bad operands")
}

// VFNMADD213PS_RZ_SAE_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213PS.RZ_SAE.Z zmm zmm k zmm
func VFNMADD213PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PS_RZ_SAE_Z: bad operands")
}

// VFNMADD213PS_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213PS.Z m512 zmm k zmm
// 	VFNMADD213PS.Z zmm  zmm k zmm
// 	VFNMADD213PS.Z m128 xmm k xmm
// 	VFNMADD213PS.Z m256 ymm k ymm
// 	VFNMADD213PS.Z xmm  xmm k xmm
// 	VFNMADD213PS.Z ymm  ymm k ymm
func VFNMADD213PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213PS_Z: bad operands")
}

// VFNMADD213SD: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMADD213SD m64 xmm xmm
// 	VFNMADD213SD xmm xmm xmm
// 	VFNMADD213SD m64 xmm k xmm
// 	VFNMADD213SD xmm xmm k xmm
func VFNMADD213SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SD: bad operands")
}

// VFNMADD213SD_RD_SAE: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMADD213SD.RD_SAE xmm xmm k xmm
// 	VFNMADD213SD.RD_SAE xmm xmm xmm
func VFNMADD213SD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SD_RD_SAE: bad operands")
}

// VFNMADD213SD_RD_SAE_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213SD.RD_SAE.Z xmm xmm k xmm
func VFNMADD213SD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SD_RD_SAE_Z: bad operands")
}

// VFNMADD213SD_RN_SAE: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMADD213SD.RN_SAE xmm xmm k xmm
// 	VFNMADD213SD.RN_SAE xmm xmm xmm
func VFNMADD213SD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SD_RN_SAE: bad operands")
}

// VFNMADD213SD_RN_SAE_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213SD.RN_SAE.Z xmm xmm k xmm
func VFNMADD213SD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SD_RN_SAE_Z: bad operands")
}

// VFNMADD213SD_RU_SAE: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMADD213SD.RU_SAE xmm xmm k xmm
// 	VFNMADD213SD.RU_SAE xmm xmm xmm
func VFNMADD213SD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SD_RU_SAE: bad operands")
}

// VFNMADD213SD_RU_SAE_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213SD.RU_SAE.Z xmm xmm k xmm
func VFNMADD213SD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SD_RU_SAE_Z: bad operands")
}

// VFNMADD213SD_RZ_SAE: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMADD213SD.RZ_SAE xmm xmm k xmm
// 	VFNMADD213SD.RZ_SAE xmm xmm xmm
func VFNMADD213SD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SD_RZ_SAE: bad operands")
}

// VFNMADD213SD_RZ_SAE_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213SD.RZ_SAE.Z xmm xmm k xmm
func VFNMADD213SD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SD_RZ_SAE_Z: bad operands")
}

// VFNMADD213SD_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213SD.Z m64 xmm k xmm
// 	VFNMADD213SD.Z xmm xmm k xmm
func VFNMADD213SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SD_Z: bad operands")
}

// VFNMADD213SS: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMADD213SS m32 xmm xmm
// 	VFNMADD213SS xmm xmm xmm
// 	VFNMADD213SS m32 xmm k xmm
// 	VFNMADD213SS xmm xmm k xmm
func VFNMADD213SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SS: bad operands")
}

// VFNMADD213SS_RD_SAE: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMADD213SS.RD_SAE xmm xmm k xmm
// 	VFNMADD213SS.RD_SAE xmm xmm xmm
func VFNMADD213SS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SS_RD_SAE: bad operands")
}

// VFNMADD213SS_RD_SAE_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213SS.RD_SAE.Z xmm xmm k xmm
func VFNMADD213SS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SS_RD_SAE_Z: bad operands")
}

// VFNMADD213SS_RN_SAE: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMADD213SS.RN_SAE xmm xmm k xmm
// 	VFNMADD213SS.RN_SAE xmm xmm xmm
func VFNMADD213SS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SS_RN_SAE: bad operands")
}

// VFNMADD213SS_RN_SAE_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213SS.RN_SAE.Z xmm xmm k xmm
func VFNMADD213SS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SS_RN_SAE_Z: bad operands")
}

// VFNMADD213SS_RU_SAE: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMADD213SS.RU_SAE xmm xmm k xmm
// 	VFNMADD213SS.RU_SAE xmm xmm xmm
func VFNMADD213SS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SS_RU_SAE: bad operands")
}

// VFNMADD213SS_RU_SAE_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213SS.RU_SAE.Z xmm xmm k xmm
func VFNMADD213SS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SS_RU_SAE_Z: bad operands")
}

// VFNMADD213SS_RZ_SAE: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMADD213SS.RZ_SAE xmm xmm k xmm
// 	VFNMADD213SS.RZ_SAE xmm xmm xmm
func VFNMADD213SS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SS_RZ_SAE: bad operands")
}

// VFNMADD213SS_RZ_SAE_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213SS.RZ_SAE.Z xmm xmm k xmm
func VFNMADD213SS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SS_RZ_SAE_Z: bad operands")
}

// VFNMADD213SS_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMADD213SS.Z m32 xmm k xmm
// 	VFNMADD213SS.Z xmm xmm k xmm
func VFNMADD213SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD213SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD213SS_Z: bad operands")
}

// VFNMADD231PD: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMADD231PD m128 xmm xmm
// 	VFNMADD231PD m256 ymm ymm
// 	VFNMADD231PD xmm  xmm xmm
// 	VFNMADD231PD ymm  ymm ymm
// 	VFNMADD231PD m512 zmm k zmm
// 	VFNMADD231PD m512 zmm zmm
// 	VFNMADD231PD zmm  zmm k zmm
// 	VFNMADD231PD zmm  zmm zmm
// 	VFNMADD231PD m128 xmm k xmm
// 	VFNMADD231PD m256 ymm k ymm
// 	VFNMADD231PD xmm  xmm k xmm
// 	VFNMADD231PD ymm  ymm k ymm
func VFNMADD231PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PD: bad operands")
}

// VFNMADD231PD_BCST: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFNMADD231PD.BCST m64 zmm k zmm
// 	VFNMADD231PD.BCST m64 zmm zmm
// 	VFNMADD231PD.BCST m64 xmm k xmm
// 	VFNMADD231PD.BCST m64 xmm xmm
// 	VFNMADD231PD.BCST m64 ymm k ymm
// 	VFNMADD231PD.BCST m64 ymm ymm
func VFNMADD231PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PD_BCST: bad operands")
}

// VFNMADD231PD_BCST_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231PD.BCST.Z m64 zmm k zmm
// 	VFNMADD231PD.BCST.Z m64 xmm k xmm
// 	VFNMADD231PD.BCST.Z m64 ymm k ymm
func VFNMADD231PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PD_BCST_Z: bad operands")
}

// VFNMADD231PD_RD_SAE: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMADD231PD.RD_SAE zmm zmm k zmm
// 	VFNMADD231PD.RD_SAE zmm zmm zmm
func VFNMADD231PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PD_RD_SAE: bad operands")
}

// VFNMADD231PD_RD_SAE_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231PD.RD_SAE.Z zmm zmm k zmm
func VFNMADD231PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PD_RD_SAE_Z: bad operands")
}

// VFNMADD231PD_RN_SAE: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMADD231PD.RN_SAE zmm zmm k zmm
// 	VFNMADD231PD.RN_SAE zmm zmm zmm
func VFNMADD231PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PD_RN_SAE: bad operands")
}

// VFNMADD231PD_RN_SAE_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231PD.RN_SAE.Z zmm zmm k zmm
func VFNMADD231PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PD_RN_SAE_Z: bad operands")
}

// VFNMADD231PD_RU_SAE: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMADD231PD.RU_SAE zmm zmm k zmm
// 	VFNMADD231PD.RU_SAE zmm zmm zmm
func VFNMADD231PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PD_RU_SAE: bad operands")
}

// VFNMADD231PD_RU_SAE_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231PD.RU_SAE.Z zmm zmm k zmm
func VFNMADD231PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PD_RU_SAE_Z: bad operands")
}

// VFNMADD231PD_RZ_SAE: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMADD231PD.RZ_SAE zmm zmm k zmm
// 	VFNMADD231PD.RZ_SAE zmm zmm zmm
func VFNMADD231PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PD_RZ_SAE: bad operands")
}

// VFNMADD231PD_RZ_SAE_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231PD.RZ_SAE.Z zmm zmm k zmm
func VFNMADD231PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PD_RZ_SAE_Z: bad operands")
}

// VFNMADD231PD_Z: Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231PD.Z m512 zmm k zmm
// 	VFNMADD231PD.Z zmm  zmm k zmm
// 	VFNMADD231PD.Z m128 xmm k xmm
// 	VFNMADD231PD.Z m256 ymm k ymm
// 	VFNMADD231PD.Z xmm  xmm k xmm
// 	VFNMADD231PD.Z ymm  ymm k ymm
func VFNMADD231PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PD_Z: bad operands")
}

// VFNMADD231PS: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMADD231PS m128 xmm xmm
// 	VFNMADD231PS m256 ymm ymm
// 	VFNMADD231PS xmm  xmm xmm
// 	VFNMADD231PS ymm  ymm ymm
// 	VFNMADD231PS m512 zmm k zmm
// 	VFNMADD231PS m512 zmm zmm
// 	VFNMADD231PS zmm  zmm k zmm
// 	VFNMADD231PS zmm  zmm zmm
// 	VFNMADD231PS m128 xmm k xmm
// 	VFNMADD231PS m256 ymm k ymm
// 	VFNMADD231PS xmm  xmm k xmm
// 	VFNMADD231PS ymm  ymm k ymm
func VFNMADD231PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PS: bad operands")
}

// VFNMADD231PS_BCST: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFNMADD231PS.BCST m32 zmm k zmm
// 	VFNMADD231PS.BCST m32 zmm zmm
// 	VFNMADD231PS.BCST m32 xmm k xmm
// 	VFNMADD231PS.BCST m32 xmm xmm
// 	VFNMADD231PS.BCST m32 ymm k ymm
// 	VFNMADD231PS.BCST m32 ymm ymm
func VFNMADD231PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PS_BCST: bad operands")
}

// VFNMADD231PS_BCST_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231PS.BCST.Z m32 zmm k zmm
// 	VFNMADD231PS.BCST.Z m32 xmm k xmm
// 	VFNMADD231PS.BCST.Z m32 ymm k ymm
func VFNMADD231PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PS_BCST_Z: bad operands")
}

// VFNMADD231PS_RD_SAE: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMADD231PS.RD_SAE zmm zmm k zmm
// 	VFNMADD231PS.RD_SAE zmm zmm zmm
func VFNMADD231PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PS_RD_SAE: bad operands")
}

// VFNMADD231PS_RD_SAE_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231PS.RD_SAE.Z zmm zmm k zmm
func VFNMADD231PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PS_RD_SAE_Z: bad operands")
}

// VFNMADD231PS_RN_SAE: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMADD231PS.RN_SAE zmm zmm k zmm
// 	VFNMADD231PS.RN_SAE zmm zmm zmm
func VFNMADD231PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PS_RN_SAE: bad operands")
}

// VFNMADD231PS_RN_SAE_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231PS.RN_SAE.Z zmm zmm k zmm
func VFNMADD231PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PS_RN_SAE_Z: bad operands")
}

// VFNMADD231PS_RU_SAE: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMADD231PS.RU_SAE zmm zmm k zmm
// 	VFNMADD231PS.RU_SAE zmm zmm zmm
func VFNMADD231PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PS_RU_SAE: bad operands")
}

// VFNMADD231PS_RU_SAE_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231PS.RU_SAE.Z zmm zmm k zmm
func VFNMADD231PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PS_RU_SAE_Z: bad operands")
}

// VFNMADD231PS_RZ_SAE: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMADD231PS.RZ_SAE zmm zmm k zmm
// 	VFNMADD231PS.RZ_SAE zmm zmm zmm
func VFNMADD231PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PS_RZ_SAE: bad operands")
}

// VFNMADD231PS_RZ_SAE_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231PS.RZ_SAE.Z zmm zmm k zmm
func VFNMADD231PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PS_RZ_SAE_Z: bad operands")
}

// VFNMADD231PS_Z: Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231PS.Z m512 zmm k zmm
// 	VFNMADD231PS.Z zmm  zmm k zmm
// 	VFNMADD231PS.Z m128 xmm k xmm
// 	VFNMADD231PS.Z m256 ymm k ymm
// 	VFNMADD231PS.Z xmm  xmm k xmm
// 	VFNMADD231PS.Z ymm  ymm k ymm
func VFNMADD231PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231PS_Z: bad operands")
}

// VFNMADD231SD: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMADD231SD m64 xmm xmm
// 	VFNMADD231SD xmm xmm xmm
// 	VFNMADD231SD m64 xmm k xmm
// 	VFNMADD231SD xmm xmm k xmm
func VFNMADD231SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SD: bad operands")
}

// VFNMADD231SD_RD_SAE: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMADD231SD.RD_SAE xmm xmm k xmm
// 	VFNMADD231SD.RD_SAE xmm xmm xmm
func VFNMADD231SD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SD_RD_SAE: bad operands")
}

// VFNMADD231SD_RD_SAE_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231SD.RD_SAE.Z xmm xmm k xmm
func VFNMADD231SD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SD_RD_SAE_Z: bad operands")
}

// VFNMADD231SD_RN_SAE: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMADD231SD.RN_SAE xmm xmm k xmm
// 	VFNMADD231SD.RN_SAE xmm xmm xmm
func VFNMADD231SD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SD_RN_SAE: bad operands")
}

// VFNMADD231SD_RN_SAE_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231SD.RN_SAE.Z xmm xmm k xmm
func VFNMADD231SD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SD_RN_SAE_Z: bad operands")
}

// VFNMADD231SD_RU_SAE: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMADD231SD.RU_SAE xmm xmm k xmm
// 	VFNMADD231SD.RU_SAE xmm xmm xmm
func VFNMADD231SD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SD_RU_SAE: bad operands")
}

// VFNMADD231SD_RU_SAE_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231SD.RU_SAE.Z xmm xmm k xmm
func VFNMADD231SD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SD_RU_SAE_Z: bad operands")
}

// VFNMADD231SD_RZ_SAE: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMADD231SD.RZ_SAE xmm xmm k xmm
// 	VFNMADD231SD.RZ_SAE xmm xmm xmm
func VFNMADD231SD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SD_RZ_SAE: bad operands")
}

// VFNMADD231SD_RZ_SAE_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231SD.RZ_SAE.Z xmm xmm k xmm
func VFNMADD231SD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SD_RZ_SAE_Z: bad operands")
}

// VFNMADD231SD_Z: Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231SD.Z m64 xmm k xmm
// 	VFNMADD231SD.Z xmm xmm k xmm
func VFNMADD231SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SD_Z: bad operands")
}

// VFNMADD231SS: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMADD231SS m32 xmm xmm
// 	VFNMADD231SS xmm xmm xmm
// 	VFNMADD231SS m32 xmm k xmm
// 	VFNMADD231SS xmm xmm k xmm
func VFNMADD231SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SS: bad operands")
}

// VFNMADD231SS_RD_SAE: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMADD231SS.RD_SAE xmm xmm k xmm
// 	VFNMADD231SS.RD_SAE xmm xmm xmm
func VFNMADD231SS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SS_RD_SAE: bad operands")
}

// VFNMADD231SS_RD_SAE_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231SS.RD_SAE.Z xmm xmm k xmm
func VFNMADD231SS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SS_RD_SAE_Z: bad operands")
}

// VFNMADD231SS_RN_SAE: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMADD231SS.RN_SAE xmm xmm k xmm
// 	VFNMADD231SS.RN_SAE xmm xmm xmm
func VFNMADD231SS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SS_RN_SAE: bad operands")
}

// VFNMADD231SS_RN_SAE_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231SS.RN_SAE.Z xmm xmm k xmm
func VFNMADD231SS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SS_RN_SAE_Z: bad operands")
}

// VFNMADD231SS_RU_SAE: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMADD231SS.RU_SAE xmm xmm k xmm
// 	VFNMADD231SS.RU_SAE xmm xmm xmm
func VFNMADD231SS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SS_RU_SAE: bad operands")
}

// VFNMADD231SS_RU_SAE_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231SS.RU_SAE.Z xmm xmm k xmm
func VFNMADD231SS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SS_RU_SAE_Z: bad operands")
}

// VFNMADD231SS_RZ_SAE: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMADD231SS.RZ_SAE xmm xmm k xmm
// 	VFNMADD231SS.RZ_SAE xmm xmm xmm
func VFNMADD231SS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SS_RZ_SAE: bad operands")
}

// VFNMADD231SS_RZ_SAE_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231SS.RZ_SAE.Z xmm xmm k xmm
func VFNMADD231SS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SS_RZ_SAE_Z: bad operands")
}

// VFNMADD231SS_Z: Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMADD231SS.Z m32 xmm k xmm
// 	VFNMADD231SS.Z xmm xmm k xmm
func VFNMADD231SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFNMADD231SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMADD231SS_Z: bad operands")
}

// VFNMSUB132PD: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMSUB132PD m128 xmm xmm
// 	VFNMSUB132PD m256 ymm ymm
// 	VFNMSUB132PD xmm  xmm xmm
// 	VFNMSUB132PD ymm  ymm ymm
// 	VFNMSUB132PD m512 zmm k zmm
// 	VFNMSUB132PD m512 zmm zmm
// 	VFNMSUB132PD zmm  zmm k zmm
// 	VFNMSUB132PD zmm  zmm zmm
// 	VFNMSUB132PD m128 xmm k xmm
// 	VFNMSUB132PD m256 ymm k ymm
// 	VFNMSUB132PD xmm  xmm k xmm
// 	VFNMSUB132PD ymm  ymm k ymm
func VFNMSUB132PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PD: bad operands")
}

// VFNMSUB132PD_BCST: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFNMSUB132PD.BCST m64 zmm k zmm
// 	VFNMSUB132PD.BCST m64 zmm zmm
// 	VFNMSUB132PD.BCST m64 xmm k xmm
// 	VFNMSUB132PD.BCST m64 xmm xmm
// 	VFNMSUB132PD.BCST m64 ymm k ymm
// 	VFNMSUB132PD.BCST m64 ymm ymm
func VFNMSUB132PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PD_BCST: bad operands")
}

// VFNMSUB132PD_BCST_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132PD.BCST.Z m64 zmm k zmm
// 	VFNMSUB132PD.BCST.Z m64 xmm k xmm
// 	VFNMSUB132PD.BCST.Z m64 ymm k ymm
func VFNMSUB132PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PD_BCST_Z: bad operands")
}

// VFNMSUB132PD_RD_SAE: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMSUB132PD.RD_SAE zmm zmm k zmm
// 	VFNMSUB132PD.RD_SAE zmm zmm zmm
func VFNMSUB132PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PD_RD_SAE: bad operands")
}

// VFNMSUB132PD_RD_SAE_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132PD.RD_SAE.Z zmm zmm k zmm
func VFNMSUB132PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PD_RD_SAE_Z: bad operands")
}

// VFNMSUB132PD_RN_SAE: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMSUB132PD.RN_SAE zmm zmm k zmm
// 	VFNMSUB132PD.RN_SAE zmm zmm zmm
func VFNMSUB132PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PD_RN_SAE: bad operands")
}

// VFNMSUB132PD_RN_SAE_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132PD.RN_SAE.Z zmm zmm k zmm
func VFNMSUB132PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PD_RN_SAE_Z: bad operands")
}

// VFNMSUB132PD_RU_SAE: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMSUB132PD.RU_SAE zmm zmm k zmm
// 	VFNMSUB132PD.RU_SAE zmm zmm zmm
func VFNMSUB132PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PD_RU_SAE: bad operands")
}

// VFNMSUB132PD_RU_SAE_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132PD.RU_SAE.Z zmm zmm k zmm
func VFNMSUB132PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PD_RU_SAE_Z: bad operands")
}

// VFNMSUB132PD_RZ_SAE: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMSUB132PD.RZ_SAE zmm zmm k zmm
// 	VFNMSUB132PD.RZ_SAE zmm zmm zmm
func VFNMSUB132PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PD_RZ_SAE: bad operands")
}

// VFNMSUB132PD_RZ_SAE_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132PD.RZ_SAE.Z zmm zmm k zmm
func VFNMSUB132PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PD_RZ_SAE_Z: bad operands")
}

// VFNMSUB132PD_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132PD.Z m512 zmm k zmm
// 	VFNMSUB132PD.Z zmm  zmm k zmm
// 	VFNMSUB132PD.Z m128 xmm k xmm
// 	VFNMSUB132PD.Z m256 ymm k ymm
// 	VFNMSUB132PD.Z xmm  xmm k xmm
// 	VFNMSUB132PD.Z ymm  ymm k ymm
func VFNMSUB132PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PD_Z: bad operands")
}

// VFNMSUB132PS: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMSUB132PS m128 xmm xmm
// 	VFNMSUB132PS m256 ymm ymm
// 	VFNMSUB132PS xmm  xmm xmm
// 	VFNMSUB132PS ymm  ymm ymm
// 	VFNMSUB132PS m512 zmm k zmm
// 	VFNMSUB132PS m512 zmm zmm
// 	VFNMSUB132PS zmm  zmm k zmm
// 	VFNMSUB132PS zmm  zmm zmm
// 	VFNMSUB132PS m128 xmm k xmm
// 	VFNMSUB132PS m256 ymm k ymm
// 	VFNMSUB132PS xmm  xmm k xmm
// 	VFNMSUB132PS ymm  ymm k ymm
func VFNMSUB132PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PS: bad operands")
}

// VFNMSUB132PS_BCST: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFNMSUB132PS.BCST m32 zmm k zmm
// 	VFNMSUB132PS.BCST m32 zmm zmm
// 	VFNMSUB132PS.BCST m32 xmm k xmm
// 	VFNMSUB132PS.BCST m32 xmm xmm
// 	VFNMSUB132PS.BCST m32 ymm k ymm
// 	VFNMSUB132PS.BCST m32 ymm ymm
func VFNMSUB132PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PS_BCST: bad operands")
}

// VFNMSUB132PS_BCST_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132PS.BCST.Z m32 zmm k zmm
// 	VFNMSUB132PS.BCST.Z m32 xmm k xmm
// 	VFNMSUB132PS.BCST.Z m32 ymm k ymm
func VFNMSUB132PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PS_BCST_Z: bad operands")
}

// VFNMSUB132PS_RD_SAE: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMSUB132PS.RD_SAE zmm zmm k zmm
// 	VFNMSUB132PS.RD_SAE zmm zmm zmm
func VFNMSUB132PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PS_RD_SAE: bad operands")
}

// VFNMSUB132PS_RD_SAE_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132PS.RD_SAE.Z zmm zmm k zmm
func VFNMSUB132PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PS_RD_SAE_Z: bad operands")
}

// VFNMSUB132PS_RN_SAE: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMSUB132PS.RN_SAE zmm zmm k zmm
// 	VFNMSUB132PS.RN_SAE zmm zmm zmm
func VFNMSUB132PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PS_RN_SAE: bad operands")
}

// VFNMSUB132PS_RN_SAE_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132PS.RN_SAE.Z zmm zmm k zmm
func VFNMSUB132PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PS_RN_SAE_Z: bad operands")
}

// VFNMSUB132PS_RU_SAE: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMSUB132PS.RU_SAE zmm zmm k zmm
// 	VFNMSUB132PS.RU_SAE zmm zmm zmm
func VFNMSUB132PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PS_RU_SAE: bad operands")
}

// VFNMSUB132PS_RU_SAE_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132PS.RU_SAE.Z zmm zmm k zmm
func VFNMSUB132PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PS_RU_SAE_Z: bad operands")
}

// VFNMSUB132PS_RZ_SAE: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMSUB132PS.RZ_SAE zmm zmm k zmm
// 	VFNMSUB132PS.RZ_SAE zmm zmm zmm
func VFNMSUB132PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PS_RZ_SAE: bad operands")
}

// VFNMSUB132PS_RZ_SAE_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132PS.RZ_SAE.Z zmm zmm k zmm
func VFNMSUB132PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PS_RZ_SAE_Z: bad operands")
}

// VFNMSUB132PS_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132PS.Z m512 zmm k zmm
// 	VFNMSUB132PS.Z zmm  zmm k zmm
// 	VFNMSUB132PS.Z m128 xmm k xmm
// 	VFNMSUB132PS.Z m256 ymm k ymm
// 	VFNMSUB132PS.Z xmm  xmm k xmm
// 	VFNMSUB132PS.Z ymm  ymm k ymm
func VFNMSUB132PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132PS_Z: bad operands")
}

// VFNMSUB132SD: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMSUB132SD m64 xmm xmm
// 	VFNMSUB132SD xmm xmm xmm
// 	VFNMSUB132SD m64 xmm k xmm
// 	VFNMSUB132SD xmm xmm k xmm
func VFNMSUB132SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SD: bad operands")
}

// VFNMSUB132SD_RD_SAE: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMSUB132SD.RD_SAE xmm xmm k xmm
// 	VFNMSUB132SD.RD_SAE xmm xmm xmm
func VFNMSUB132SD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SD_RD_SAE: bad operands")
}

// VFNMSUB132SD_RD_SAE_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132SD.RD_SAE.Z xmm xmm k xmm
func VFNMSUB132SD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SD_RD_SAE_Z: bad operands")
}

// VFNMSUB132SD_RN_SAE: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMSUB132SD.RN_SAE xmm xmm k xmm
// 	VFNMSUB132SD.RN_SAE xmm xmm xmm
func VFNMSUB132SD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SD_RN_SAE: bad operands")
}

// VFNMSUB132SD_RN_SAE_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132SD.RN_SAE.Z xmm xmm k xmm
func VFNMSUB132SD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SD_RN_SAE_Z: bad operands")
}

// VFNMSUB132SD_RU_SAE: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMSUB132SD.RU_SAE xmm xmm k xmm
// 	VFNMSUB132SD.RU_SAE xmm xmm xmm
func VFNMSUB132SD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SD_RU_SAE: bad operands")
}

// VFNMSUB132SD_RU_SAE_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132SD.RU_SAE.Z xmm xmm k xmm
func VFNMSUB132SD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SD_RU_SAE_Z: bad operands")
}

// VFNMSUB132SD_RZ_SAE: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMSUB132SD.RZ_SAE xmm xmm k xmm
// 	VFNMSUB132SD.RZ_SAE xmm xmm xmm
func VFNMSUB132SD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SD_RZ_SAE: bad operands")
}

// VFNMSUB132SD_RZ_SAE_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132SD.RZ_SAE.Z xmm xmm k xmm
func VFNMSUB132SD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SD_RZ_SAE_Z: bad operands")
}

// VFNMSUB132SD_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132SD.Z m64 xmm k xmm
// 	VFNMSUB132SD.Z xmm xmm k xmm
func VFNMSUB132SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SD_Z: bad operands")
}

// VFNMSUB132SS: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMSUB132SS m32 xmm xmm
// 	VFNMSUB132SS xmm xmm xmm
// 	VFNMSUB132SS m32 xmm k xmm
// 	VFNMSUB132SS xmm xmm k xmm
func VFNMSUB132SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SS: bad operands")
}

// VFNMSUB132SS_RD_SAE: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMSUB132SS.RD_SAE xmm xmm k xmm
// 	VFNMSUB132SS.RD_SAE xmm xmm xmm
func VFNMSUB132SS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SS_RD_SAE: bad operands")
}

// VFNMSUB132SS_RD_SAE_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132SS.RD_SAE.Z xmm xmm k xmm
func VFNMSUB132SS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SS_RD_SAE_Z: bad operands")
}

// VFNMSUB132SS_RN_SAE: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMSUB132SS.RN_SAE xmm xmm k xmm
// 	VFNMSUB132SS.RN_SAE xmm xmm xmm
func VFNMSUB132SS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SS_RN_SAE: bad operands")
}

// VFNMSUB132SS_RN_SAE_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132SS.RN_SAE.Z xmm xmm k xmm
func VFNMSUB132SS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SS_RN_SAE_Z: bad operands")
}

// VFNMSUB132SS_RU_SAE: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMSUB132SS.RU_SAE xmm xmm k xmm
// 	VFNMSUB132SS.RU_SAE xmm xmm xmm
func VFNMSUB132SS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SS_RU_SAE: bad operands")
}

// VFNMSUB132SS_RU_SAE_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132SS.RU_SAE.Z xmm xmm k xmm
func VFNMSUB132SS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SS_RU_SAE_Z: bad operands")
}

// VFNMSUB132SS_RZ_SAE: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMSUB132SS.RZ_SAE xmm xmm k xmm
// 	VFNMSUB132SS.RZ_SAE xmm xmm xmm
func VFNMSUB132SS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SS_RZ_SAE: bad operands")
}

// VFNMSUB132SS_RZ_SAE_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132SS.RZ_SAE.Z xmm xmm k xmm
func VFNMSUB132SS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SS_RZ_SAE_Z: bad operands")
}

// VFNMSUB132SS_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB132SS.Z m32 xmm k xmm
// 	VFNMSUB132SS.Z xmm xmm k xmm
func VFNMSUB132SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB132SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB132SS_Z: bad operands")
}

// VFNMSUB213PD: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMSUB213PD m128 xmm xmm
// 	VFNMSUB213PD m256 ymm ymm
// 	VFNMSUB213PD xmm  xmm xmm
// 	VFNMSUB213PD ymm  ymm ymm
// 	VFNMSUB213PD m512 zmm k zmm
// 	VFNMSUB213PD m512 zmm zmm
// 	VFNMSUB213PD zmm  zmm k zmm
// 	VFNMSUB213PD zmm  zmm zmm
// 	VFNMSUB213PD m128 xmm k xmm
// 	VFNMSUB213PD m256 ymm k ymm
// 	VFNMSUB213PD xmm  xmm k xmm
// 	VFNMSUB213PD ymm  ymm k ymm
func VFNMSUB213PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PD: bad operands")
}

// VFNMSUB213PD_BCST: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFNMSUB213PD.BCST m64 zmm k zmm
// 	VFNMSUB213PD.BCST m64 zmm zmm
// 	VFNMSUB213PD.BCST m64 xmm k xmm
// 	VFNMSUB213PD.BCST m64 xmm xmm
// 	VFNMSUB213PD.BCST m64 ymm k ymm
// 	VFNMSUB213PD.BCST m64 ymm ymm
func VFNMSUB213PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PD_BCST: bad operands")
}

// VFNMSUB213PD_BCST_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213PD.BCST.Z m64 zmm k zmm
// 	VFNMSUB213PD.BCST.Z m64 xmm k xmm
// 	VFNMSUB213PD.BCST.Z m64 ymm k ymm
func VFNMSUB213PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PD_BCST_Z: bad operands")
}

// VFNMSUB213PD_RD_SAE: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMSUB213PD.RD_SAE zmm zmm k zmm
// 	VFNMSUB213PD.RD_SAE zmm zmm zmm
func VFNMSUB213PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PD_RD_SAE: bad operands")
}

// VFNMSUB213PD_RD_SAE_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213PD.RD_SAE.Z zmm zmm k zmm
func VFNMSUB213PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PD_RD_SAE_Z: bad operands")
}

// VFNMSUB213PD_RN_SAE: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMSUB213PD.RN_SAE zmm zmm k zmm
// 	VFNMSUB213PD.RN_SAE zmm zmm zmm
func VFNMSUB213PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PD_RN_SAE: bad operands")
}

// VFNMSUB213PD_RN_SAE_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213PD.RN_SAE.Z zmm zmm k zmm
func VFNMSUB213PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PD_RN_SAE_Z: bad operands")
}

// VFNMSUB213PD_RU_SAE: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMSUB213PD.RU_SAE zmm zmm k zmm
// 	VFNMSUB213PD.RU_SAE zmm zmm zmm
func VFNMSUB213PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PD_RU_SAE: bad operands")
}

// VFNMSUB213PD_RU_SAE_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213PD.RU_SAE.Z zmm zmm k zmm
func VFNMSUB213PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PD_RU_SAE_Z: bad operands")
}

// VFNMSUB213PD_RZ_SAE: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMSUB213PD.RZ_SAE zmm zmm k zmm
// 	VFNMSUB213PD.RZ_SAE zmm zmm zmm
func VFNMSUB213PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PD_RZ_SAE: bad operands")
}

// VFNMSUB213PD_RZ_SAE_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213PD.RZ_SAE.Z zmm zmm k zmm
func VFNMSUB213PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PD_RZ_SAE_Z: bad operands")
}

// VFNMSUB213PD_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213PD.Z m512 zmm k zmm
// 	VFNMSUB213PD.Z zmm  zmm k zmm
// 	VFNMSUB213PD.Z m128 xmm k xmm
// 	VFNMSUB213PD.Z m256 ymm k ymm
// 	VFNMSUB213PD.Z xmm  xmm k xmm
// 	VFNMSUB213PD.Z ymm  ymm k ymm
func VFNMSUB213PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PD_Z: bad operands")
}

// VFNMSUB213PS: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMSUB213PS m128 xmm xmm
// 	VFNMSUB213PS m256 ymm ymm
// 	VFNMSUB213PS xmm  xmm xmm
// 	VFNMSUB213PS ymm  ymm ymm
// 	VFNMSUB213PS m512 zmm k zmm
// 	VFNMSUB213PS m512 zmm zmm
// 	VFNMSUB213PS zmm  zmm k zmm
// 	VFNMSUB213PS zmm  zmm zmm
// 	VFNMSUB213PS m128 xmm k xmm
// 	VFNMSUB213PS m256 ymm k ymm
// 	VFNMSUB213PS xmm  xmm k xmm
// 	VFNMSUB213PS ymm  ymm k ymm
func VFNMSUB213PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PS: bad operands")
}

// VFNMSUB213PS_BCST: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFNMSUB213PS.BCST m32 zmm k zmm
// 	VFNMSUB213PS.BCST m32 zmm zmm
// 	VFNMSUB213PS.BCST m32 xmm k xmm
// 	VFNMSUB213PS.BCST m32 xmm xmm
// 	VFNMSUB213PS.BCST m32 ymm k ymm
// 	VFNMSUB213PS.BCST m32 ymm ymm
func VFNMSUB213PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PS_BCST: bad operands")
}

// VFNMSUB213PS_BCST_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213PS.BCST.Z m32 zmm k zmm
// 	VFNMSUB213PS.BCST.Z m32 xmm k xmm
// 	VFNMSUB213PS.BCST.Z m32 ymm k ymm
func VFNMSUB213PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PS_BCST_Z: bad operands")
}

// VFNMSUB213PS_RD_SAE: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMSUB213PS.RD_SAE zmm zmm k zmm
// 	VFNMSUB213PS.RD_SAE zmm zmm zmm
func VFNMSUB213PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PS_RD_SAE: bad operands")
}

// VFNMSUB213PS_RD_SAE_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213PS.RD_SAE.Z zmm zmm k zmm
func VFNMSUB213PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PS_RD_SAE_Z: bad operands")
}

// VFNMSUB213PS_RN_SAE: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMSUB213PS.RN_SAE zmm zmm k zmm
// 	VFNMSUB213PS.RN_SAE zmm zmm zmm
func VFNMSUB213PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PS_RN_SAE: bad operands")
}

// VFNMSUB213PS_RN_SAE_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213PS.RN_SAE.Z zmm zmm k zmm
func VFNMSUB213PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PS_RN_SAE_Z: bad operands")
}

// VFNMSUB213PS_RU_SAE: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMSUB213PS.RU_SAE zmm zmm k zmm
// 	VFNMSUB213PS.RU_SAE zmm zmm zmm
func VFNMSUB213PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PS_RU_SAE: bad operands")
}

// VFNMSUB213PS_RU_SAE_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213PS.RU_SAE.Z zmm zmm k zmm
func VFNMSUB213PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PS_RU_SAE_Z: bad operands")
}

// VFNMSUB213PS_RZ_SAE: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMSUB213PS.RZ_SAE zmm zmm k zmm
// 	VFNMSUB213PS.RZ_SAE zmm zmm zmm
func VFNMSUB213PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PS_RZ_SAE: bad operands")
}

// VFNMSUB213PS_RZ_SAE_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213PS.RZ_SAE.Z zmm zmm k zmm
func VFNMSUB213PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PS_RZ_SAE_Z: bad operands")
}

// VFNMSUB213PS_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213PS.Z m512 zmm k zmm
// 	VFNMSUB213PS.Z zmm  zmm k zmm
// 	VFNMSUB213PS.Z m128 xmm k xmm
// 	VFNMSUB213PS.Z m256 ymm k ymm
// 	VFNMSUB213PS.Z xmm  xmm k xmm
// 	VFNMSUB213PS.Z ymm  ymm k ymm
func VFNMSUB213PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213PS_Z: bad operands")
}

// VFNMSUB213SD: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMSUB213SD m64 xmm xmm
// 	VFNMSUB213SD xmm xmm xmm
// 	VFNMSUB213SD m64 xmm k xmm
// 	VFNMSUB213SD xmm xmm k xmm
func VFNMSUB213SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SD: bad operands")
}

// VFNMSUB213SD_RD_SAE: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMSUB213SD.RD_SAE xmm xmm k xmm
// 	VFNMSUB213SD.RD_SAE xmm xmm xmm
func VFNMSUB213SD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SD_RD_SAE: bad operands")
}

// VFNMSUB213SD_RD_SAE_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213SD.RD_SAE.Z xmm xmm k xmm
func VFNMSUB213SD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SD_RD_SAE_Z: bad operands")
}

// VFNMSUB213SD_RN_SAE: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMSUB213SD.RN_SAE xmm xmm k xmm
// 	VFNMSUB213SD.RN_SAE xmm xmm xmm
func VFNMSUB213SD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SD_RN_SAE: bad operands")
}

// VFNMSUB213SD_RN_SAE_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213SD.RN_SAE.Z xmm xmm k xmm
func VFNMSUB213SD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SD_RN_SAE_Z: bad operands")
}

// VFNMSUB213SD_RU_SAE: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMSUB213SD.RU_SAE xmm xmm k xmm
// 	VFNMSUB213SD.RU_SAE xmm xmm xmm
func VFNMSUB213SD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SD_RU_SAE: bad operands")
}

// VFNMSUB213SD_RU_SAE_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213SD.RU_SAE.Z xmm xmm k xmm
func VFNMSUB213SD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SD_RU_SAE_Z: bad operands")
}

// VFNMSUB213SD_RZ_SAE: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMSUB213SD.RZ_SAE xmm xmm k xmm
// 	VFNMSUB213SD.RZ_SAE xmm xmm xmm
func VFNMSUB213SD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SD_RZ_SAE: bad operands")
}

// VFNMSUB213SD_RZ_SAE_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213SD.RZ_SAE.Z xmm xmm k xmm
func VFNMSUB213SD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SD_RZ_SAE_Z: bad operands")
}

// VFNMSUB213SD_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213SD.Z m64 xmm k xmm
// 	VFNMSUB213SD.Z xmm xmm k xmm
func VFNMSUB213SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SD_Z: bad operands")
}

// VFNMSUB213SS: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMSUB213SS m32 xmm xmm
// 	VFNMSUB213SS xmm xmm xmm
// 	VFNMSUB213SS m32 xmm k xmm
// 	VFNMSUB213SS xmm xmm k xmm
func VFNMSUB213SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SS: bad operands")
}

// VFNMSUB213SS_RD_SAE: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMSUB213SS.RD_SAE xmm xmm k xmm
// 	VFNMSUB213SS.RD_SAE xmm xmm xmm
func VFNMSUB213SS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SS_RD_SAE: bad operands")
}

// VFNMSUB213SS_RD_SAE_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213SS.RD_SAE.Z xmm xmm k xmm
func VFNMSUB213SS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SS_RD_SAE_Z: bad operands")
}

// VFNMSUB213SS_RN_SAE: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMSUB213SS.RN_SAE xmm xmm k xmm
// 	VFNMSUB213SS.RN_SAE xmm xmm xmm
func VFNMSUB213SS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SS_RN_SAE: bad operands")
}

// VFNMSUB213SS_RN_SAE_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213SS.RN_SAE.Z xmm xmm k xmm
func VFNMSUB213SS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SS_RN_SAE_Z: bad operands")
}

// VFNMSUB213SS_RU_SAE: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMSUB213SS.RU_SAE xmm xmm k xmm
// 	VFNMSUB213SS.RU_SAE xmm xmm xmm
func VFNMSUB213SS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SS_RU_SAE: bad operands")
}

// VFNMSUB213SS_RU_SAE_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213SS.RU_SAE.Z xmm xmm k xmm
func VFNMSUB213SS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SS_RU_SAE_Z: bad operands")
}

// VFNMSUB213SS_RZ_SAE: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMSUB213SS.RZ_SAE xmm xmm k xmm
// 	VFNMSUB213SS.RZ_SAE xmm xmm xmm
func VFNMSUB213SS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SS_RZ_SAE: bad operands")
}

// VFNMSUB213SS_RZ_SAE_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213SS.RZ_SAE.Z xmm xmm k xmm
func VFNMSUB213SS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SS_RZ_SAE_Z: bad operands")
}

// VFNMSUB213SS_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB213SS.Z m32 xmm k xmm
// 	VFNMSUB213SS.Z xmm xmm k xmm
func VFNMSUB213SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB213SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB213SS_Z: bad operands")
}

// VFNMSUB231PD: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMSUB231PD m128 xmm xmm
// 	VFNMSUB231PD m256 ymm ymm
// 	VFNMSUB231PD xmm  xmm xmm
// 	VFNMSUB231PD ymm  ymm ymm
// 	VFNMSUB231PD m512 zmm k zmm
// 	VFNMSUB231PD m512 zmm zmm
// 	VFNMSUB231PD zmm  zmm k zmm
// 	VFNMSUB231PD zmm  zmm zmm
// 	VFNMSUB231PD m128 xmm k xmm
// 	VFNMSUB231PD m256 ymm k ymm
// 	VFNMSUB231PD xmm  xmm k xmm
// 	VFNMSUB231PD ymm  ymm k ymm
func VFNMSUB231PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PD: bad operands")
}

// VFNMSUB231PD_BCST: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFNMSUB231PD.BCST m64 zmm k zmm
// 	VFNMSUB231PD.BCST m64 zmm zmm
// 	VFNMSUB231PD.BCST m64 xmm k xmm
// 	VFNMSUB231PD.BCST m64 xmm xmm
// 	VFNMSUB231PD.BCST m64 ymm k ymm
// 	VFNMSUB231PD.BCST m64 ymm ymm
func VFNMSUB231PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PD_BCST: bad operands")
}

// VFNMSUB231PD_BCST_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231PD.BCST.Z m64 zmm k zmm
// 	VFNMSUB231PD.BCST.Z m64 xmm k xmm
// 	VFNMSUB231PD.BCST.Z m64 ymm k ymm
func VFNMSUB231PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PD_BCST_Z: bad operands")
}

// VFNMSUB231PD_RD_SAE: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMSUB231PD.RD_SAE zmm zmm k zmm
// 	VFNMSUB231PD.RD_SAE zmm zmm zmm
func VFNMSUB231PD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PD_RD_SAE: bad operands")
}

// VFNMSUB231PD_RD_SAE_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231PD.RD_SAE.Z zmm zmm k zmm
func VFNMSUB231PD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PD_RD_SAE_Z: bad operands")
}

// VFNMSUB231PD_RN_SAE: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMSUB231PD.RN_SAE zmm zmm k zmm
// 	VFNMSUB231PD.RN_SAE zmm zmm zmm
func VFNMSUB231PD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PD_RN_SAE: bad operands")
}

// VFNMSUB231PD_RN_SAE_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231PD.RN_SAE.Z zmm zmm k zmm
func VFNMSUB231PD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PD_RN_SAE_Z: bad operands")
}

// VFNMSUB231PD_RU_SAE: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMSUB231PD.RU_SAE zmm zmm k zmm
// 	VFNMSUB231PD.RU_SAE zmm zmm zmm
func VFNMSUB231PD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PD_RU_SAE: bad operands")
}

// VFNMSUB231PD_RU_SAE_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231PD.RU_SAE.Z zmm zmm k zmm
func VFNMSUB231PD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PD_RU_SAE_Z: bad operands")
}

// VFNMSUB231PD_RZ_SAE: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMSUB231PD.RZ_SAE zmm zmm k zmm
// 	VFNMSUB231PD.RZ_SAE zmm zmm zmm
func VFNMSUB231PD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PD_RZ_SAE: bad operands")
}

// VFNMSUB231PD_RZ_SAE_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231PD.RZ_SAE.Z zmm zmm k zmm
func VFNMSUB231PD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PD_RZ_SAE_Z: bad operands")
}

// VFNMSUB231PD_Z: Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231PD.Z m512 zmm k zmm
// 	VFNMSUB231PD.Z zmm  zmm k zmm
// 	VFNMSUB231PD.Z m128 xmm k xmm
// 	VFNMSUB231PD.Z m256 ymm k ymm
// 	VFNMSUB231PD.Z xmm  xmm k xmm
// 	VFNMSUB231PD.Z ymm  ymm k ymm
func VFNMSUB231PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PD_Z: bad operands")
}

// VFNMSUB231PS: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMSUB231PS m128 xmm xmm
// 	VFNMSUB231PS m256 ymm ymm
// 	VFNMSUB231PS xmm  xmm xmm
// 	VFNMSUB231PS ymm  ymm ymm
// 	VFNMSUB231PS m512 zmm k zmm
// 	VFNMSUB231PS m512 zmm zmm
// 	VFNMSUB231PS zmm  zmm k zmm
// 	VFNMSUB231PS zmm  zmm zmm
// 	VFNMSUB231PS m128 xmm k xmm
// 	VFNMSUB231PS m256 ymm k ymm
// 	VFNMSUB231PS xmm  xmm k xmm
// 	VFNMSUB231PS ymm  ymm k ymm
func VFNMSUB231PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PS: bad operands")
}

// VFNMSUB231PS_BCST: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFNMSUB231PS.BCST m32 zmm k zmm
// 	VFNMSUB231PS.BCST m32 zmm zmm
// 	VFNMSUB231PS.BCST m32 xmm k xmm
// 	VFNMSUB231PS.BCST m32 xmm xmm
// 	VFNMSUB231PS.BCST m32 ymm k ymm
// 	VFNMSUB231PS.BCST m32 ymm ymm
func VFNMSUB231PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PS_BCST: bad operands")
}

// VFNMSUB231PS_BCST_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231PS.BCST.Z m32 zmm k zmm
// 	VFNMSUB231PS.BCST.Z m32 xmm k xmm
// 	VFNMSUB231PS.BCST.Z m32 ymm k ymm
func VFNMSUB231PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PS_BCST_Z: bad operands")
}

// VFNMSUB231PS_RD_SAE: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMSUB231PS.RD_SAE zmm zmm k zmm
// 	VFNMSUB231PS.RD_SAE zmm zmm zmm
func VFNMSUB231PS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PS_RD_SAE: bad operands")
}

// VFNMSUB231PS_RD_SAE_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231PS.RD_SAE.Z zmm zmm k zmm
func VFNMSUB231PS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PS_RD_SAE_Z: bad operands")
}

// VFNMSUB231PS_RN_SAE: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMSUB231PS.RN_SAE zmm zmm k zmm
// 	VFNMSUB231PS.RN_SAE zmm zmm zmm
func VFNMSUB231PS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PS_RN_SAE: bad operands")
}

// VFNMSUB231PS_RN_SAE_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231PS.RN_SAE.Z zmm zmm k zmm
func VFNMSUB231PS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PS_RN_SAE_Z: bad operands")
}

// VFNMSUB231PS_RU_SAE: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMSUB231PS.RU_SAE zmm zmm k zmm
// 	VFNMSUB231PS.RU_SAE zmm zmm zmm
func VFNMSUB231PS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PS_RU_SAE: bad operands")
}

// VFNMSUB231PS_RU_SAE_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231PS.RU_SAE.Z zmm zmm k zmm
func VFNMSUB231PS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PS_RU_SAE_Z: bad operands")
}

// VFNMSUB231PS_RZ_SAE: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMSUB231PS.RZ_SAE zmm zmm k zmm
// 	VFNMSUB231PS.RZ_SAE zmm zmm zmm
func VFNMSUB231PS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PS_RZ_SAE: bad operands")
}

// VFNMSUB231PS_RZ_SAE_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231PS.RZ_SAE.Z zmm zmm k zmm
func VFNMSUB231PS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k, z2},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PS_RZ_SAE_Z: bad operands")
}

// VFNMSUB231PS_Z: Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231PS.Z m512 zmm k zmm
// 	VFNMSUB231PS.Z zmm  zmm k zmm
// 	VFNMSUB231PS.Z m128 xmm k xmm
// 	VFNMSUB231PS.Z m256 ymm k ymm
// 	VFNMSUB231PS.Z xmm  xmm k xmm
// 	VFNMSUB231PS.Z ymm  ymm k ymm
func VFNMSUB231PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231PS_Z: bad operands")
}

// VFNMSUB231SD: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMSUB231SD m64 xmm xmm
// 	VFNMSUB231SD xmm xmm xmm
// 	VFNMSUB231SD m64 xmm k xmm
// 	VFNMSUB231SD xmm xmm k xmm
func VFNMSUB231SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SD: bad operands")
}

// VFNMSUB231SD_RD_SAE: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMSUB231SD.RD_SAE xmm xmm k xmm
// 	VFNMSUB231SD.RD_SAE xmm xmm xmm
func VFNMSUB231SD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SD_RD_SAE: bad operands")
}

// VFNMSUB231SD_RD_SAE_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231SD.RD_SAE.Z xmm xmm k xmm
func VFNMSUB231SD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SD_RD_SAE_Z: bad operands")
}

// VFNMSUB231SD_RN_SAE: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMSUB231SD.RN_SAE xmm xmm k xmm
// 	VFNMSUB231SD.RN_SAE xmm xmm xmm
func VFNMSUB231SD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SD_RN_SAE: bad operands")
}

// VFNMSUB231SD_RN_SAE_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231SD.RN_SAE.Z xmm xmm k xmm
func VFNMSUB231SD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SD_RN_SAE_Z: bad operands")
}

// VFNMSUB231SD_RU_SAE: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMSUB231SD.RU_SAE xmm xmm k xmm
// 	VFNMSUB231SD.RU_SAE xmm xmm xmm
func VFNMSUB231SD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SD_RU_SAE: bad operands")
}

// VFNMSUB231SD_RU_SAE_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231SD.RU_SAE.Z xmm xmm k xmm
func VFNMSUB231SD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SD_RU_SAE_Z: bad operands")
}

// VFNMSUB231SD_RZ_SAE: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMSUB231SD.RZ_SAE xmm xmm k xmm
// 	VFNMSUB231SD.RZ_SAE xmm xmm xmm
func VFNMSUB231SD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SD_RZ_SAE: bad operands")
}

// VFNMSUB231SD_RZ_SAE_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231SD.RZ_SAE.Z xmm xmm k xmm
func VFNMSUB231SD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SD_RZ_SAE_Z: bad operands")
}

// VFNMSUB231SD_Z: Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231SD.Z m64 xmm k xmm
// 	VFNMSUB231SD.Z xmm xmm k xmm
func VFNMSUB231SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SD_Z: bad operands")
}

// VFNMSUB231SS: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFNMSUB231SS m32 xmm xmm
// 	VFNMSUB231SS xmm xmm xmm
// 	VFNMSUB231SS m32 xmm k xmm
// 	VFNMSUB231SS xmm xmm k xmm
func VFNMSUB231SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"FMA3"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SS: bad operands")
}

// VFNMSUB231SS_RD_SAE: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VFNMSUB231SS.RD_SAE xmm xmm k xmm
// 	VFNMSUB231SS.RD_SAE xmm xmm xmm
func VFNMSUB231SS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SS_RD_SAE: bad operands")
}

// VFNMSUB231SS_RD_SAE_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231SS.RD_SAE.Z xmm xmm k xmm
func VFNMSUB231SS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SS_RD_SAE_Z: bad operands")
}

// VFNMSUB231SS_RN_SAE: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VFNMSUB231SS.RN_SAE xmm xmm k xmm
// 	VFNMSUB231SS.RN_SAE xmm xmm xmm
func VFNMSUB231SS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SS_RN_SAE: bad operands")
}

// VFNMSUB231SS_RN_SAE_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231SS.RN_SAE.Z xmm xmm k xmm
func VFNMSUB231SS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SS_RN_SAE_Z: bad operands")
}

// VFNMSUB231SS_RU_SAE: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VFNMSUB231SS.RU_SAE xmm xmm k xmm
// 	VFNMSUB231SS.RU_SAE xmm xmm xmm
func VFNMSUB231SS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SS_RU_SAE: bad operands")
}

// VFNMSUB231SS_RU_SAE_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231SS.RU_SAE.Z xmm xmm k xmm
func VFNMSUB231SS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SS_RU_SAE_Z: bad operands")
}

// VFNMSUB231SS_RZ_SAE: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VFNMSUB231SS.RZ_SAE xmm xmm k xmm
// 	VFNMSUB231SS.RZ_SAE xmm xmm xmm
func VFNMSUB231SS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SS_RZ_SAE: bad operands")
}

// VFNMSUB231SS_RZ_SAE_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231SS.RZ_SAE.Z xmm xmm k xmm
func VFNMSUB231SS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k, x2},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SS_RZ_SAE_Z: bad operands")
}

// VFNMSUB231SS_Z: Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VFNMSUB231SS.Z m32 xmm k xmm
// 	VFNMSUB231SS.Z xmm xmm k xmm
func VFNMSUB231SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VFNMSUB231SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k, x1},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VFNMSUB231SS_Z: bad operands")
}

// VFPCLASSPDX: Test Class of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFPCLASSPDX imm8 m128 k k
// 	VFPCLASSPDX imm8 m128 k
// 	VFPCLASSPDX imm8 xmm  k k
// 	VFPCLASSPDX imm8 xmm  k
func VFPCLASSPDX(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPDX",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPDX",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VFPCLASSPDX: bad operands")
}

// VFPCLASSPDX_BCST: Test Class of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFPCLASSPDX.BCST imm8 m64 k k
// 	VFPCLASSPDX.BCST imm8 m64 k
func VFPCLASSPDX_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPDX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPDX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VFPCLASSPDX_BCST: bad operands")
}

// VFPCLASSPDY: Test Class of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFPCLASSPDY imm8 m256 k k
// 	VFPCLASSPDY imm8 m256 k
// 	VFPCLASSPDY imm8 ymm  k k
// 	VFPCLASSPDY imm8 ymm  k
func VFPCLASSPDY(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPDY",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPDY",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VFPCLASSPDY: bad operands")
}

// VFPCLASSPDY_BCST: Test Class of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFPCLASSPDY.BCST imm8 m64 k k
// 	VFPCLASSPDY.BCST imm8 m64 k
func VFPCLASSPDY_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPDY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPDY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VFPCLASSPDY_BCST: bad operands")
}

// VFPCLASSPDZ: Test Class of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VFPCLASSPDZ imm8 m512 k k
// 	VFPCLASSPDZ imm8 m512 k
// 	VFPCLASSPDZ imm8 zmm  k k
// 	VFPCLASSPDZ imm8 zmm  k
func VFPCLASSPDZ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPDZ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPDZ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VFPCLASSPDZ: bad operands")
}

// VFPCLASSPDZ_BCST: Test Class of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFPCLASSPDZ.BCST imm8 m64 k k
// 	VFPCLASSPDZ.BCST imm8 m64 k
func VFPCLASSPDZ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPDZ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPDZ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VFPCLASSPDZ_BCST: bad operands")
}

// VFPCLASSPSX: Test Class of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFPCLASSPSX imm8 m128 k k
// 	VFPCLASSPSX imm8 m128 k
// 	VFPCLASSPSX imm8 xmm  k k
// 	VFPCLASSPSX imm8 xmm  k
func VFPCLASSPSX(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPSX",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPSX",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VFPCLASSPSX: bad operands")
}

// VFPCLASSPSX_BCST: Test Class of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFPCLASSPSX.BCST imm8 m32 k k
// 	VFPCLASSPSX.BCST imm8 m32 k
func VFPCLASSPSX_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPSX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPSX",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VFPCLASSPSX_BCST: bad operands")
}

// VFPCLASSPSY: Test Class of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFPCLASSPSY imm8 m256 k k
// 	VFPCLASSPSY imm8 m256 k
// 	VFPCLASSPSY imm8 ymm  k k
// 	VFPCLASSPSY imm8 ymm  k
func VFPCLASSPSY(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPSY",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPSY",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VFPCLASSPSY: bad operands")
}

// VFPCLASSPSY_BCST: Test Class of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFPCLASSPSY.BCST imm8 m32 k k
// 	VFPCLASSPSY.BCST imm8 m32 k
func VFPCLASSPSY_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPSY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPSY",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VFPCLASSPSY_BCST: bad operands")
}

// VFPCLASSPSZ: Test Class of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VFPCLASSPSZ imm8 m512 k k
// 	VFPCLASSPSZ imm8 m512 k
// 	VFPCLASSPSZ imm8 zmm  k k
// 	VFPCLASSPSZ imm8 zmm  k
func VFPCLASSPSZ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPSZ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPSZ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VFPCLASSPSZ: bad operands")
}

// VFPCLASSPSZ_BCST: Test Class of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VFPCLASSPSZ.BCST imm8 m32 k k
// 	VFPCLASSPSZ.BCST imm8 m32 k
func VFPCLASSPSZ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPSZ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSPSZ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VFPCLASSPSZ_BCST: bad operands")
}

// VFPCLASSSD: Test Class of Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VFPCLASSSD imm8 m64 k k
// 	VFPCLASSSD imm8 m64 k
// 	VFPCLASSSD imm8 xmm k k
// 	VFPCLASSSD imm8 xmm k
func VFPCLASSSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VFPCLASSSD: bad operands")
}

// VFPCLASSSS: Test Class of Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	VFPCLASSSS imm8 m32 k k
// 	VFPCLASSSS imm8 m32 k
// 	VFPCLASSSS imm8 xmm k k
// 	VFPCLASSSS imm8 xmm k
func VFPCLASSSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VFPCLASSSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VFPCLASSSS: bad operands")
}

// VGATHERDPD: Gather Packed Double-Precision Floating-Point Values Using Signed Doubleword Indices.
//
// Forms:
//
// 	VGATHERDPD xmm   vm32x xmm
// 	VGATHERDPD ymm   vm32x ymm
// 	VGATHERDPD vm32y k     zmm
// 	VGATHERDPD vm32x k     xmm
// 	VGATHERDPD vm32x k     ymm
func VGATHERDPD(vxy, kv, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(vxy) && operand.IsVM32X(kv) && operand.IsXMM(xyz),
		operand.IsYMM(vxy) && operand.IsVM32X(kv) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGATHERDPD",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{vxy, xyz},
			ISA:      []string{"AVX2"},
		}, nil
	case operand.IsVM32Y(vxy) && operand.IsK(kv) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGATHERDPD",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsVM32X(vxy) && operand.IsK(kv) && operand.IsXMM(xyz),
		operand.IsVM32X(vxy) && operand.IsK(kv) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGATHERDPD",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGATHERDPD: bad operands")
}

// VGATHERDPS: Gather Packed Single-Precision Floating-Point Values Using Signed Doubleword Indices.
//
// Forms:
//
// 	VGATHERDPS xmm   vm32x xmm
// 	VGATHERDPS ymm   vm32y ymm
// 	VGATHERDPS vm32z k     zmm
// 	VGATHERDPS vm32x k     xmm
// 	VGATHERDPS vm32y k     ymm
func VGATHERDPS(vxy, kv, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(vxy) && operand.IsVM32X(kv) && operand.IsXMM(xyz),
		operand.IsYMM(vxy) && operand.IsVM32Y(kv) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGATHERDPS",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{vxy, xyz},
			ISA:      []string{"AVX2"},
		}, nil
	case operand.IsVM32Z(vxy) && operand.IsK(kv) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGATHERDPS",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsVM32X(vxy) && operand.IsK(kv) && operand.IsXMM(xyz),
		operand.IsVM32Y(vxy) && operand.IsK(kv) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGATHERDPS",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGATHERDPS: bad operands")
}

// VGATHERQPD: Gather Packed Double-Precision Floating-Point Values Using Signed Quadword Indices.
//
// Forms:
//
// 	VGATHERQPD xmm   vm64x xmm
// 	VGATHERQPD ymm   vm64y ymm
// 	VGATHERQPD vm64z k     zmm
// 	VGATHERQPD vm64x k     xmm
// 	VGATHERQPD vm64y k     ymm
func VGATHERQPD(vxy, kv, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(vxy) && operand.IsVM64X(kv) && operand.IsXMM(xyz),
		operand.IsYMM(vxy) && operand.IsVM64Y(kv) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGATHERQPD",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{vxy, xyz},
			ISA:      []string{"AVX2"},
		}, nil
	case operand.IsVM64Z(vxy) && operand.IsK(kv) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGATHERQPD",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsVM64X(vxy) && operand.IsK(kv) && operand.IsXMM(xyz),
		operand.IsVM64Y(vxy) && operand.IsK(kv) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGATHERQPD",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGATHERQPD: bad operands")
}

// VGATHERQPS: Gather Packed Single-Precision Floating-Point Values Using Signed Quadword Indices.
//
// Forms:
//
// 	VGATHERQPS xmm   vm64x xmm
// 	VGATHERQPS xmm   vm64y xmm
// 	VGATHERQPS vm64z k     ymm
// 	VGATHERQPS vm64x k     xmm
// 	VGATHERQPS vm64y k     xmm
func VGATHERQPS(vx, kv, xy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(vx) && operand.IsVM64X(kv) && operand.IsXMM(xy),
		operand.IsXMM(vx) && operand.IsVM64Y(kv) && operand.IsXMM(xy):
		return &intrep.Instruction{
			Opcode:   "VGATHERQPS",
			Operands: []operand.Op{vx, kv, xy},
			Inputs:   []operand.Op{vx, kv, xy},
			Outputs:  []operand.Op{vx, xy},
			ISA:      []string{"AVX2"},
		}, nil
	case operand.IsVM64Z(vx) && operand.IsK(kv) && operand.IsYMM(xy):
		return &intrep.Instruction{
			Opcode:   "VGATHERQPS",
			Operands: []operand.Op{vx, kv, xy},
			Inputs:   []operand.Op{vx, kv, xy},
			Outputs:  []operand.Op{xy},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsVM64X(vx) && operand.IsK(kv) && operand.IsXMM(xy),
		operand.IsVM64Y(vx) && operand.IsK(kv) && operand.IsXMM(xy):
		return &intrep.Instruction{
			Opcode:   "VGATHERQPS",
			Operands: []operand.Op{vx, kv, xy},
			Inputs:   []operand.Op{vx, kv, xy},
			Outputs:  []operand.Op{xy},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGATHERQPS: bad operands")
}

// VGETEXPPD: Extract Exponents of Packed Double-Precision Floating-Point Values as Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VGETEXPPD m512 k zmm
// 	VGETEXPPD m512 zmm
// 	VGETEXPPD zmm  k zmm
// 	VGETEXPPD zmm  zmm
// 	VGETEXPPD m128 k xmm
// 	VGETEXPPD m128 xmm
// 	VGETEXPPD m256 k ymm
// 	VGETEXPPD m256 ymm
// 	VGETEXPPD xmm  k xmm
// 	VGETEXPPD xmm  xmm
// 	VGETEXPPD ymm  k ymm
// 	VGETEXPPD ymm  ymm
func VGETEXPPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPPD: bad operands")
}

// VGETEXPPD_BCST: Extract Exponents of Packed Double-Precision Floating-Point Values as Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VGETEXPPD.BCST m64 k zmm
// 	VGETEXPPD.BCST m64 zmm
// 	VGETEXPPD.BCST m64 k xmm
// 	VGETEXPPD.BCST m64 k ymm
// 	VGETEXPPD.BCST m64 xmm
// 	VGETEXPPD.BCST m64 ymm
func VGETEXPPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPPD_BCST: bad operands")
}

// VGETEXPPD_BCST_Z: Extract Exponents of Packed Double-Precision Floating-Point Values as Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VGETEXPPD.BCST.Z m64 k zmm
// 	VGETEXPPD.BCST.Z m64 k xmm
// 	VGETEXPPD.BCST.Z m64 k ymm
func VGETEXPPD_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPPD_BCST_Z: bad operands")
}

// VGETEXPPD_SAE: Extract Exponents of Packed Double-Precision Floating-Point Values as Double-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VGETEXPPD.SAE zmm k zmm
// 	VGETEXPPD.SAE zmm zmm
func VGETEXPPD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPPD_SAE: bad operands")
}

// VGETEXPPD_SAE_Z: Extract Exponents of Packed Double-Precision Floating-Point Values as Double-Precision Floating-Point Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VGETEXPPD.SAE.Z zmm k zmm
func VGETEXPPD_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPPD_SAE_Z: bad operands")
}

// VGETEXPPD_Z: Extract Exponents of Packed Double-Precision Floating-Point Values as Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VGETEXPPD.Z m512 k zmm
// 	VGETEXPPD.Z zmm  k zmm
// 	VGETEXPPD.Z m128 k xmm
// 	VGETEXPPD.Z m256 k ymm
// 	VGETEXPPD.Z xmm  k xmm
// 	VGETEXPPD.Z ymm  k ymm
func VGETEXPPD_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPPD_Z: bad operands")
}

// VGETEXPPS: Extract Exponents of Packed Single-Precision Floating-Point Values as Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VGETEXPPS m512 k zmm
// 	VGETEXPPS m512 zmm
// 	VGETEXPPS zmm  k zmm
// 	VGETEXPPS zmm  zmm
// 	VGETEXPPS m128 k xmm
// 	VGETEXPPS m128 xmm
// 	VGETEXPPS m256 k ymm
// 	VGETEXPPS m256 ymm
// 	VGETEXPPS xmm  k xmm
// 	VGETEXPPS xmm  xmm
// 	VGETEXPPS ymm  k ymm
// 	VGETEXPPS ymm  ymm
func VGETEXPPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPPS: bad operands")
}

// VGETEXPPS_BCST: Extract Exponents of Packed Single-Precision Floating-Point Values as Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VGETEXPPS.BCST m32 k zmm
// 	VGETEXPPS.BCST m32 zmm
// 	VGETEXPPS.BCST m32 k xmm
// 	VGETEXPPS.BCST m32 k ymm
// 	VGETEXPPS.BCST m32 xmm
// 	VGETEXPPS.BCST m32 ymm
func VGETEXPPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPPS_BCST: bad operands")
}

// VGETEXPPS_BCST_Z: Extract Exponents of Packed Single-Precision Floating-Point Values as Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VGETEXPPS.BCST.Z m32 k zmm
// 	VGETEXPPS.BCST.Z m32 k xmm
// 	VGETEXPPS.BCST.Z m32 k ymm
func VGETEXPPS_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPPS_BCST_Z: bad operands")
}

// VGETEXPPS_SAE: Extract Exponents of Packed Single-Precision Floating-Point Values as Single-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VGETEXPPS.SAE zmm k zmm
// 	VGETEXPPS.SAE zmm zmm
func VGETEXPPS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPPS_SAE: bad operands")
}

// VGETEXPPS_SAE_Z: Extract Exponents of Packed Single-Precision Floating-Point Values as Single-Precision Floating-Point Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VGETEXPPS.SAE.Z zmm k zmm
func VGETEXPPS_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPPS_SAE_Z: bad operands")
}

// VGETEXPPS_Z: Extract Exponents of Packed Single-Precision Floating-Point Values as Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VGETEXPPS.Z m512 k zmm
// 	VGETEXPPS.Z zmm  k zmm
// 	VGETEXPPS.Z m128 k xmm
// 	VGETEXPPS.Z m256 k ymm
// 	VGETEXPPS.Z xmm  k xmm
// 	VGETEXPPS.Z ymm  k ymm
func VGETEXPPS_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETEXPPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPPS_Z: bad operands")
}

// VGETEXPSD: Extract Exponent of Scalar Double-Precision Floating-Point Value as Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VGETEXPSD m64 xmm k xmm
// 	VGETEXPSD m64 xmm xmm
// 	VGETEXPSD xmm xmm k xmm
// 	VGETEXPSD xmm xmm xmm
func VGETEXPSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPSD: bad operands")
}

// VGETEXPSD_SAE: Extract Exponent of Scalar Double-Precision Floating-Point Value as Double-Precision Floating-Point Value (Suppress All Exceptions).
//
// Forms:
//
// 	VGETEXPSD.SAE xmm xmm k xmm
// 	VGETEXPSD.SAE xmm xmm xmm
func VGETEXPSD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPSD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPSD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPSD_SAE: bad operands")
}

// VGETEXPSD_SAE_Z: Extract Exponent of Scalar Double-Precision Floating-Point Value as Double-Precision Floating-Point Value (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VGETEXPSD.SAE.Z xmm xmm k xmm
func VGETEXPSD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VGETEXPSD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPSD_SAE_Z: bad operands")
}

// VGETEXPSD_Z: Extract Exponent of Scalar Double-Precision Floating-Point Value as Double-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VGETEXPSD.Z m64 xmm k xmm
// 	VGETEXPSD.Z xmm xmm k xmm
func VGETEXPSD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VGETEXPSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPSD_Z: bad operands")
}

// VGETEXPSS: Extract Exponent of Scalar Single-Precision Floating-Point Value as Single-Precision Floating-Point Value.
//
// Forms:
//
// 	VGETEXPSS m32 xmm k xmm
// 	VGETEXPSS m32 xmm xmm
// 	VGETEXPSS xmm xmm k xmm
// 	VGETEXPSS xmm xmm xmm
func VGETEXPSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPSS: bad operands")
}

// VGETEXPSS_SAE: Extract Exponent of Scalar Single-Precision Floating-Point Value as Single-Precision Floating-Point Value (Suppress All Exceptions).
//
// Forms:
//
// 	VGETEXPSS.SAE xmm xmm k xmm
// 	VGETEXPSS.SAE xmm xmm xmm
func VGETEXPSS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPSS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETEXPSS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPSS_SAE: bad operands")
}

// VGETEXPSS_SAE_Z: Extract Exponent of Scalar Single-Precision Floating-Point Value as Single-Precision Floating-Point Value (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VGETEXPSS.SAE.Z xmm xmm k xmm
func VGETEXPSS_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VGETEXPSS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPSS_SAE_Z: bad operands")
}

// VGETEXPSS_Z: Extract Exponent of Scalar Single-Precision Floating-Point Value as Single-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VGETEXPSS.Z m32 xmm k xmm
// 	VGETEXPSS.Z xmm xmm k xmm
func VGETEXPSS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VGETEXPSS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETEXPSS_Z: bad operands")
}

// VGETMANTPD: Extract Normalized Mantissas from Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VGETMANTPD imm8 m512 k zmm
// 	VGETMANTPD imm8 m512 zmm
// 	VGETMANTPD imm8 zmm  k zmm
// 	VGETMANTPD imm8 zmm  zmm
// 	VGETMANTPD imm8 m128 k xmm
// 	VGETMANTPD imm8 m128 xmm
// 	VGETMANTPD imm8 m256 k ymm
// 	VGETMANTPD imm8 m256 ymm
// 	VGETMANTPD imm8 xmm  k xmm
// 	VGETMANTPD imm8 xmm  xmm
// 	VGETMANTPD imm8 ymm  k ymm
// 	VGETMANTPD imm8 ymm  ymm
func VGETMANTPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTPD: bad operands")
}

// VGETMANTPD_BCST: Extract Normalized Mantissas from Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VGETMANTPD.BCST imm8 m64 k zmm
// 	VGETMANTPD.BCST imm8 m64 zmm
// 	VGETMANTPD.BCST imm8 m64 k xmm
// 	VGETMANTPD.BCST imm8 m64 k ymm
// 	VGETMANTPD.BCST imm8 m64 xmm
// 	VGETMANTPD.BCST imm8 m64 ymm
func VGETMANTPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTPD_BCST: bad operands")
}

// VGETMANTPD_BCST_Z: Extract Normalized Mantissas from Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VGETMANTPD.BCST.Z imm8 m64 k zmm
// 	VGETMANTPD.BCST.Z imm8 m64 k xmm
// 	VGETMANTPD.BCST.Z imm8 m64 k ymm
func VGETMANTPD_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTPD_BCST_Z: bad operands")
}

// VGETMANTPD_SAE: Extract Normalized Mantissas from Packed Double-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VGETMANTPD.SAE imm8 zmm k zmm
// 	VGETMANTPD.SAE imm8 zmm zmm
func VGETMANTPD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTPD_SAE: bad operands")
}

// VGETMANTPD_SAE_Z: Extract Normalized Mantissas from Packed Double-Precision Floating-Point Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VGETMANTPD.SAE.Z imm8 zmm k zmm
func VGETMANTPD_SAE_Z(i, z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTPD_SAE_Z: bad operands")
}

// VGETMANTPD_Z: Extract Normalized Mantissas from Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VGETMANTPD.Z imm8 m512 k zmm
// 	VGETMANTPD.Z imm8 zmm  k zmm
// 	VGETMANTPD.Z imm8 m128 k xmm
// 	VGETMANTPD.Z imm8 m256 k ymm
// 	VGETMANTPD.Z imm8 xmm  k xmm
// 	VGETMANTPD.Z imm8 ymm  k ymm
func VGETMANTPD_Z(i, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTPD_Z: bad operands")
}

// VGETMANTPS: Extract Normalized Mantissas from Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VGETMANTPS imm8 m512 k zmm
// 	VGETMANTPS imm8 m512 zmm
// 	VGETMANTPS imm8 zmm  k zmm
// 	VGETMANTPS imm8 zmm  zmm
// 	VGETMANTPS imm8 m128 k xmm
// 	VGETMANTPS imm8 m128 xmm
// 	VGETMANTPS imm8 m256 k ymm
// 	VGETMANTPS imm8 m256 ymm
// 	VGETMANTPS imm8 xmm  k xmm
// 	VGETMANTPS imm8 xmm  xmm
// 	VGETMANTPS imm8 ymm  k ymm
// 	VGETMANTPS imm8 ymm  ymm
func VGETMANTPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTPS: bad operands")
}

// VGETMANTPS_BCST: Extract Normalized Mantissas from Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VGETMANTPS.BCST imm8 m32 k zmm
// 	VGETMANTPS.BCST imm8 m32 zmm
// 	VGETMANTPS.BCST imm8 m32 k xmm
// 	VGETMANTPS.BCST imm8 m32 k ymm
// 	VGETMANTPS.BCST imm8 m32 xmm
// 	VGETMANTPS.BCST imm8 m32 ymm
func VGETMANTPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTPS_BCST: bad operands")
}

// VGETMANTPS_BCST_Z: Extract Normalized Mantissas from Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VGETMANTPS.BCST.Z imm8 m32 k zmm
// 	VGETMANTPS.BCST.Z imm8 m32 k xmm
// 	VGETMANTPS.BCST.Z imm8 m32 k ymm
func VGETMANTPS_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTPS_BCST_Z: bad operands")
}

// VGETMANTPS_SAE: Extract Normalized Mantissas from Packed Single-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VGETMANTPS.SAE imm8 zmm k zmm
// 	VGETMANTPS.SAE imm8 zmm zmm
func VGETMANTPS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTPS_SAE: bad operands")
}

// VGETMANTPS_SAE_Z: Extract Normalized Mantissas from Packed Single-Precision Floating-Point Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VGETMANTPS.SAE.Z imm8 zmm k zmm
func VGETMANTPS_SAE_Z(i, z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTPS_SAE_Z: bad operands")
}

// VGETMANTPS_Z: Extract Normalized Mantissas from Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VGETMANTPS.Z imm8 m512 k zmm
// 	VGETMANTPS.Z imm8 zmm  k zmm
// 	VGETMANTPS.Z imm8 m128 k xmm
// 	VGETMANTPS.Z imm8 m256 k ymm
// 	VGETMANTPS.Z imm8 xmm  k xmm
// 	VGETMANTPS.Z imm8 ymm  k ymm
func VGETMANTPS_Z(i, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VGETMANTPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTPS_Z: bad operands")
}

// VGETMANTSD: Extract Normalized Mantissa from Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VGETMANTSD imm8 m64 xmm k xmm
// 	VGETMANTSD imm8 m64 xmm xmm
// 	VGETMANTSD imm8 xmm xmm k xmm
// 	VGETMANTSD imm8 xmm xmm xmm
func VGETMANTSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTSD: bad operands")
}

// VGETMANTSD_SAE: Extract Normalized Mantissa from Scalar Double-Precision Floating-Point Value (Suppress All Exceptions).
//
// Forms:
//
// 	VGETMANTSD.SAE imm8 xmm xmm k xmm
// 	VGETMANTSD.SAE imm8 xmm xmm xmm
func VGETMANTSD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTSD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTSD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTSD_SAE: bad operands")
}

// VGETMANTSD_SAE_Z: Extract Normalized Mantissa from Scalar Double-Precision Floating-Point Value (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VGETMANTSD.SAE.Z imm8 xmm xmm k xmm
func VGETMANTSD_SAE_Z(i, x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VGETMANTSD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTSD_SAE_Z: bad operands")
}

// VGETMANTSD_Z: Extract Normalized Mantissa from Scalar Double-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VGETMANTSD.Z imm8 m64 xmm k xmm
// 	VGETMANTSD.Z imm8 xmm xmm k xmm
func VGETMANTSD_Z(i, mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VGETMANTSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTSD_Z: bad operands")
}

// VGETMANTSS: Extract Normalized Mantissa from Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	VGETMANTSS imm8 m32 xmm k xmm
// 	VGETMANTSS imm8 m32 xmm xmm
// 	VGETMANTSS imm8 xmm xmm k xmm
// 	VGETMANTSS imm8 xmm xmm xmm
func VGETMANTSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTSS: bad operands")
}

// VGETMANTSS_SAE: Extract Normalized Mantissa from Scalar Single-Precision Floating-Point Value (Suppress All Exceptions).
//
// Forms:
//
// 	VGETMANTSS.SAE imm8 xmm xmm k xmm
// 	VGETMANTSS.SAE imm8 xmm xmm xmm
func VGETMANTSS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTSS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VGETMANTSS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTSS_SAE: bad operands")
}

// VGETMANTSS_SAE_Z: Extract Normalized Mantissa from Scalar Single-Precision Floating-Point Value (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VGETMANTSS.SAE.Z imm8 xmm xmm k xmm
func VGETMANTSS_SAE_Z(i, x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VGETMANTSS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTSS_SAE_Z: bad operands")
}

// VGETMANTSS_Z: Extract Normalized Mantissa from Scalar Single-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VGETMANTSS.Z imm8 m32 xmm k xmm
// 	VGETMANTSS.Z imm8 xmm xmm k xmm
func VGETMANTSS_Z(i, mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VGETMANTSS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VGETMANTSS_Z: bad operands")
}

// VHADDPD: Packed Double-FP Horizontal Add.
//
// Forms:
//
// 	VHADDPD m128 xmm xmm
// 	VHADDPD m256 ymm ymm
// 	VHADDPD xmm  xmm xmm
// 	VHADDPD ymm  ymm ymm
func VHADDPD(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VHADDPD",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VHADDPD: bad operands")
}

// VHADDPS: Packed Single-FP Horizontal Add.
//
// Forms:
//
// 	VHADDPS m128 xmm xmm
// 	VHADDPS m256 ymm ymm
// 	VHADDPS xmm  xmm xmm
// 	VHADDPS ymm  ymm ymm
func VHADDPS(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VHADDPS",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VHADDPS: bad operands")
}

// VHSUBPD: Packed Double-FP Horizontal Subtract.
//
// Forms:
//
// 	VHSUBPD m128 xmm xmm
// 	VHSUBPD m256 ymm ymm
// 	VHSUBPD xmm  xmm xmm
// 	VHSUBPD ymm  ymm ymm
func VHSUBPD(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VHSUBPD",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VHSUBPD: bad operands")
}

// VHSUBPS: Packed Single-FP Horizontal Subtract.
//
// Forms:
//
// 	VHSUBPS m128 xmm xmm
// 	VHSUBPS m256 ymm ymm
// 	VHSUBPS xmm  xmm xmm
// 	VHSUBPS ymm  ymm ymm
func VHSUBPS(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VHSUBPS",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VHSUBPS: bad operands")
}

// VINSERTF128: Insert Packed Floating-Point Values.
//
// Forms:
//
// 	VINSERTF128 imm8 m128 ymm ymm
// 	VINSERTF128 imm8 xmm  ymm ymm
func VINSERTF128(i, mx, y, y1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsYMM(y) && operand.IsYMM(y1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsYMM(y) && operand.IsYMM(y1):
		return &intrep.Instruction{
			Opcode:   "VINSERTF128",
			Operands: []operand.Op{i, mx, y, y1},
			Inputs:   []operand.Op{mx, y},
			Outputs:  []operand.Op{y1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VINSERTF128: bad operands")
}

// VINSERTF32X4: Insert 128 Bits of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VINSERTF32X4 imm8 m128 zmm k zmm
// 	VINSERTF32X4 imm8 m128 zmm zmm
// 	VINSERTF32X4 imm8 xmm  zmm k zmm
// 	VINSERTF32X4 imm8 xmm  zmm zmm
// 	VINSERTF32X4 imm8 m128 ymm k ymm
// 	VINSERTF32X4 imm8 m128 ymm ymm
// 	VINSERTF32X4 imm8 xmm  ymm k ymm
// 	VINSERTF32X4 imm8 xmm  ymm ymm
func VINSERTF32X4(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VINSERTF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VINSERTF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VINSERTF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VINSERTF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VINSERTF32X4: bad operands")
}

// VINSERTF32X4_Z: Insert 128 Bits of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VINSERTF32X4.Z imm8 m128 zmm k zmm
// 	VINSERTF32X4.Z imm8 xmm  zmm k zmm
// 	VINSERTF32X4.Z imm8 m128 ymm k ymm
// 	VINSERTF32X4.Z imm8 xmm  ymm k ymm
func VINSERTF32X4_Z(i, mx, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VINSERTF32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, yz, k, yz1},
			Inputs:   []operand.Op{mx, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VINSERTF32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, yz, k, yz1},
			Inputs:   []operand.Op{mx, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VINSERTF32X4_Z: bad operands")
}

// VINSERTF32X8: Insert 256 Bits of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VINSERTF32X8 imm8 m256 zmm k zmm
// 	VINSERTF32X8 imm8 m256 zmm zmm
// 	VINSERTF32X8 imm8 ymm  zmm k zmm
// 	VINSERTF32X8 imm8 ymm  zmm zmm
func VINSERTF32X8(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VINSERTF32X8",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VINSERTF32X8",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VINSERTF32X8: bad operands")
}

// VINSERTF32X8_Z: Insert 256 Bits of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VINSERTF32X8.Z imm8 m256 zmm k zmm
// 	VINSERTF32X8.Z imm8 ymm  zmm k zmm
func VINSERTF32X8_Z(i, my, z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM256(my) && operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1),
		operand.IsIMM8(i) && operand.IsYMM(my) && operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VINSERTF32X8",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, my, z, k, z1},
			Inputs:   []operand.Op{my, z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VINSERTF32X8_Z: bad operands")
}

// VINSERTF64X2: Insert 128 Bits of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VINSERTF64X2 imm8 m128 zmm k zmm
// 	VINSERTF64X2 imm8 m128 zmm zmm
// 	VINSERTF64X2 imm8 xmm  zmm k zmm
// 	VINSERTF64X2 imm8 xmm  zmm zmm
// 	VINSERTF64X2 imm8 m128 ymm k ymm
// 	VINSERTF64X2 imm8 m128 ymm ymm
// 	VINSERTF64X2 imm8 xmm  ymm k ymm
// 	VINSERTF64X2 imm8 xmm  ymm ymm
func VINSERTF64X2(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VINSERTF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VINSERTF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VINSERTF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VINSERTF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VINSERTF64X2: bad operands")
}

// VINSERTF64X2_Z: Insert 128 Bits of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VINSERTF64X2.Z imm8 m128 zmm k zmm
// 	VINSERTF64X2.Z imm8 xmm  zmm k zmm
// 	VINSERTF64X2.Z imm8 m128 ymm k ymm
// 	VINSERTF64X2.Z imm8 xmm  ymm k ymm
func VINSERTF64X2_Z(i, mx, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VINSERTF64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, yz, k, yz1},
			Inputs:   []operand.Op{mx, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VINSERTF64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, yz, k, yz1},
			Inputs:   []operand.Op{mx, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VINSERTF64X2_Z: bad operands")
}

// VINSERTF64X4: Insert 256 Bits of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VINSERTF64X4 imm8 m256 zmm k zmm
// 	VINSERTF64X4 imm8 m256 zmm zmm
// 	VINSERTF64X4 imm8 ymm  zmm k zmm
// 	VINSERTF64X4 imm8 ymm  zmm zmm
func VINSERTF64X4(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VINSERTF64X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VINSERTF64X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VINSERTF64X4: bad operands")
}

// VINSERTF64X4_Z: Insert 256 Bits of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VINSERTF64X4.Z imm8 m256 zmm k zmm
// 	VINSERTF64X4.Z imm8 ymm  zmm k zmm
func VINSERTF64X4_Z(i, my, z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM256(my) && operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1),
		operand.IsIMM8(i) && operand.IsYMM(my) && operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VINSERTF64X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, my, z, k, z1},
			Inputs:   []operand.Op{my, z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VINSERTF64X4_Z: bad operands")
}

// VINSERTI128: Insert Packed Integer Values.
//
// Forms:
//
// 	VINSERTI128 imm8 m128 ymm ymm
// 	VINSERTI128 imm8 xmm  ymm ymm
func VINSERTI128(i, mx, y, y1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsYMM(y) && operand.IsYMM(y1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsYMM(y) && operand.IsYMM(y1):
		return &intrep.Instruction{
			Opcode:   "VINSERTI128",
			Operands: []operand.Op{i, mx, y, y1},
			Inputs:   []operand.Op{mx, y},
			Outputs:  []operand.Op{y1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VINSERTI128: bad operands")
}

// VINSERTI32X4: Insert 128 Bits of Packed Doubleword Integer Values.
//
// Forms:
//
// 	VINSERTI32X4 imm8 m128 zmm k zmm
// 	VINSERTI32X4 imm8 m128 zmm zmm
// 	VINSERTI32X4 imm8 xmm  zmm k zmm
// 	VINSERTI32X4 imm8 xmm  zmm zmm
// 	VINSERTI32X4 imm8 m128 ymm k ymm
// 	VINSERTI32X4 imm8 m128 ymm ymm
// 	VINSERTI32X4 imm8 xmm  ymm k ymm
// 	VINSERTI32X4 imm8 xmm  ymm ymm
func VINSERTI32X4(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VINSERTI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VINSERTI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VINSERTI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VINSERTI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VINSERTI32X4: bad operands")
}

// VINSERTI32X4_Z: Insert 128 Bits of Packed Doubleword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VINSERTI32X4.Z imm8 m128 zmm k zmm
// 	VINSERTI32X4.Z imm8 xmm  zmm k zmm
// 	VINSERTI32X4.Z imm8 m128 ymm k ymm
// 	VINSERTI32X4.Z imm8 xmm  ymm k ymm
func VINSERTI32X4_Z(i, mx, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VINSERTI32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, yz, k, yz1},
			Inputs:   []operand.Op{mx, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VINSERTI32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, yz, k, yz1},
			Inputs:   []operand.Op{mx, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VINSERTI32X4_Z: bad operands")
}

// VINSERTI32X8: Insert 256 Bits of Packed Doubleword Integer Values.
//
// Forms:
//
// 	VINSERTI32X8 imm8 m256 zmm k zmm
// 	VINSERTI32X8 imm8 m256 zmm zmm
// 	VINSERTI32X8 imm8 ymm  zmm k zmm
// 	VINSERTI32X8 imm8 ymm  zmm zmm
func VINSERTI32X8(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VINSERTI32X8",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VINSERTI32X8",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VINSERTI32X8: bad operands")
}

// VINSERTI32X8_Z: Insert 256 Bits of Packed Doubleword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VINSERTI32X8.Z imm8 m256 zmm k zmm
// 	VINSERTI32X8.Z imm8 ymm  zmm k zmm
func VINSERTI32X8_Z(i, my, z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM256(my) && operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1),
		operand.IsIMM8(i) && operand.IsYMM(my) && operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VINSERTI32X8",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, my, z, k, z1},
			Inputs:   []operand.Op{my, z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VINSERTI32X8_Z: bad operands")
}

// VINSERTI64X2: Insert 128 Bits of Packed Quadword Integer Values.
//
// Forms:
//
// 	VINSERTI64X2 imm8 m128 zmm k zmm
// 	VINSERTI64X2 imm8 m128 zmm zmm
// 	VINSERTI64X2 imm8 xmm  zmm k zmm
// 	VINSERTI64X2 imm8 xmm  zmm zmm
// 	VINSERTI64X2 imm8 m128 ymm k ymm
// 	VINSERTI64X2 imm8 m128 ymm ymm
// 	VINSERTI64X2 imm8 xmm  ymm k ymm
// 	VINSERTI64X2 imm8 xmm  ymm ymm
func VINSERTI64X2(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VINSERTI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VINSERTI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VINSERTI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VINSERTI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VINSERTI64X2: bad operands")
}

// VINSERTI64X2_Z: Insert 128 Bits of Packed Quadword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VINSERTI64X2.Z imm8 m128 zmm k zmm
// 	VINSERTI64X2.Z imm8 xmm  zmm k zmm
// 	VINSERTI64X2.Z imm8 m128 ymm k ymm
// 	VINSERTI64X2.Z imm8 xmm  ymm k ymm
func VINSERTI64X2_Z(i, mx, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VINSERTI64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, yz, k, yz1},
			Inputs:   []operand.Op{mx, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VINSERTI64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, yz, k, yz1},
			Inputs:   []operand.Op{mx, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VINSERTI64X2_Z: bad operands")
}

// VINSERTI64X4: Insert 256 Bits of Packed Quadword Integer Values.
//
// Forms:
//
// 	VINSERTI64X4 imm8 m256 zmm k zmm
// 	VINSERTI64X4 imm8 m256 zmm zmm
// 	VINSERTI64X4 imm8 ymm  zmm k zmm
// 	VINSERTI64X4 imm8 ymm  zmm zmm
func VINSERTI64X4(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VINSERTI64X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VINSERTI64X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VINSERTI64X4: bad operands")
}

// VINSERTI64X4_Z: Insert 256 Bits of Packed Quadword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VINSERTI64X4.Z imm8 m256 zmm k zmm
// 	VINSERTI64X4.Z imm8 ymm  zmm k zmm
func VINSERTI64X4_Z(i, my, z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM256(my) && operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1),
		operand.IsIMM8(i) && operand.IsYMM(my) && operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VINSERTI64X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, my, z, k, z1},
			Inputs:   []operand.Op{my, z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VINSERTI64X4_Z: bad operands")
}

// VINSERTPS: Insert Packed Single Precision Floating-Point Value.
//
// Forms:
//
// 	VINSERTPS imm8 m32 xmm xmm
// 	VINSERTPS imm8 xmm xmm xmm
func VINSERTPS(i, mx, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(mx) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VINSERTPS",
			Operands: []operand.Op{i, mx, x, x1},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VINSERTPS: bad operands")
}

// VLDDQU: Load Unaligned Integer 128 Bits.
//
// Forms:
//
// 	VLDDQU m128 xmm
// 	VLDDQU m256 ymm
func VLDDQU(m, xy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(m) && operand.IsXMM(xy),
		operand.IsM256(m) && operand.IsYMM(xy):
		return &intrep.Instruction{
			Opcode:   "VLDDQU",
			Operands: []operand.Op{m, xy},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{xy},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VLDDQU: bad operands")
}

// VLDMXCSR: Load MXCSR Register.
//
// Forms:
//
// 	VLDMXCSR m32
func VLDMXCSR(m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m):
		return &intrep.Instruction{
			Opcode:   "VLDMXCSR",
			Operands: []operand.Op{m},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VLDMXCSR: bad operands")
}

// VMASKMOVDQU: Store Selected Bytes of Double Quadword.
//
// Forms:
//
// 	VMASKMOVDQU xmm xmm
func VMASKMOVDQU(x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VMASKMOVDQU",
			Operands: []operand.Op{x, x1},
			Inputs:   []operand.Op{x, x1, reg.RDI},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMASKMOVDQU: bad operands")
}

// VMASKMOVPD: Conditional Move Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VMASKMOVPD m128 xmm xmm
// 	VMASKMOVPD m256 ymm ymm
// 	VMASKMOVPD xmm  xmm m128
// 	VMASKMOVPD ymm  ymm m256
func VMASKMOVPD(mxy, xy, mxy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(mxy1),
		operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(mxy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsM128(mxy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsM256(mxy1):
		return &intrep.Instruction{
			Opcode:   "VMASKMOVPD",
			Operands: []operand.Op{mxy, xy, mxy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{mxy1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMASKMOVPD: bad operands")
}

// VMASKMOVPS: Conditional Move Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VMASKMOVPS m128 xmm xmm
// 	VMASKMOVPS m256 ymm ymm
// 	VMASKMOVPS xmm  xmm m128
// 	VMASKMOVPS ymm  ymm m256
func VMASKMOVPS(mxy, xy, mxy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(mxy1),
		operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(mxy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsM128(mxy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsM256(mxy1):
		return &intrep.Instruction{
			Opcode:   "VMASKMOVPS",
			Operands: []operand.Op{mxy, xy, mxy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{mxy1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMASKMOVPS: bad operands")
}

// VMAXPD: Return Maximum Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VMAXPD m128 xmm xmm
// 	VMAXPD m256 ymm ymm
// 	VMAXPD xmm  xmm xmm
// 	VMAXPD ymm  ymm ymm
// 	VMAXPD m512 zmm k zmm
// 	VMAXPD m512 zmm zmm
// 	VMAXPD zmm  zmm k zmm
// 	VMAXPD zmm  zmm zmm
// 	VMAXPD m128 xmm k xmm
// 	VMAXPD m256 ymm k ymm
// 	VMAXPD xmm  xmm k xmm
// 	VMAXPD ymm  ymm k ymm
func VMAXPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXPD: bad operands")
}

// VMAXPD_BCST: Return Maximum Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VMAXPD.BCST m64 zmm k zmm
// 	VMAXPD.BCST m64 zmm zmm
// 	VMAXPD.BCST m64 xmm k xmm
// 	VMAXPD.BCST m64 xmm xmm
// 	VMAXPD.BCST m64 ymm k ymm
// 	VMAXPD.BCST m64 ymm ymm
func VMAXPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXPD_BCST: bad operands")
}

// VMAXPD_BCST_Z: Return Maximum Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VMAXPD.BCST.Z m64 zmm k zmm
// 	VMAXPD.BCST.Z m64 xmm k xmm
// 	VMAXPD.BCST.Z m64 ymm k ymm
func VMAXPD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXPD_BCST_Z: bad operands")
}

// VMAXPD_SAE: Return Maximum Packed Double-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VMAXPD.SAE zmm zmm k zmm
// 	VMAXPD.SAE zmm zmm zmm
func VMAXPD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXPD_SAE: bad operands")
}

// VMAXPD_SAE_Z: Return Maximum Packed Double-Precision Floating-Point Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VMAXPD.SAE.Z zmm zmm k zmm
func VMAXPD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXPD_SAE_Z: bad operands")
}

// VMAXPD_Z: Return Maximum Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VMAXPD.Z m512 zmm k zmm
// 	VMAXPD.Z zmm  zmm k zmm
// 	VMAXPD.Z m128 xmm k xmm
// 	VMAXPD.Z m256 ymm k ymm
// 	VMAXPD.Z xmm  xmm k xmm
// 	VMAXPD.Z ymm  ymm k ymm
func VMAXPD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMAXPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXPD_Z: bad operands")
}

// VMAXPS: Return Maximum Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VMAXPS m128 xmm xmm
// 	VMAXPS m256 ymm ymm
// 	VMAXPS xmm  xmm xmm
// 	VMAXPS ymm  ymm ymm
// 	VMAXPS m512 zmm k zmm
// 	VMAXPS m512 zmm zmm
// 	VMAXPS zmm  zmm k zmm
// 	VMAXPS zmm  zmm zmm
// 	VMAXPS m128 xmm k xmm
// 	VMAXPS m256 ymm k ymm
// 	VMAXPS xmm  xmm k xmm
// 	VMAXPS ymm  ymm k ymm
func VMAXPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXPS: bad operands")
}

// VMAXPS_BCST: Return Maximum Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VMAXPS.BCST m32 zmm k zmm
// 	VMAXPS.BCST m32 zmm zmm
// 	VMAXPS.BCST m32 xmm k xmm
// 	VMAXPS.BCST m32 xmm xmm
// 	VMAXPS.BCST m32 ymm k ymm
// 	VMAXPS.BCST m32 ymm ymm
func VMAXPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXPS_BCST: bad operands")
}

// VMAXPS_BCST_Z: Return Maximum Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VMAXPS.BCST.Z m32 zmm k zmm
// 	VMAXPS.BCST.Z m32 xmm k xmm
// 	VMAXPS.BCST.Z m32 ymm k ymm
func VMAXPS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXPS_BCST_Z: bad operands")
}

// VMAXPS_SAE: Return Maximum Packed Single-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VMAXPS.SAE zmm zmm k zmm
// 	VMAXPS.SAE zmm zmm zmm
func VMAXPS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXPS_SAE: bad operands")
}

// VMAXPS_SAE_Z: Return Maximum Packed Single-Precision Floating-Point Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VMAXPS.SAE.Z zmm zmm k zmm
func VMAXPS_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXPS_SAE_Z: bad operands")
}

// VMAXPS_Z: Return Maximum Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VMAXPS.Z m512 zmm k zmm
// 	VMAXPS.Z zmm  zmm k zmm
// 	VMAXPS.Z m128 xmm k xmm
// 	VMAXPS.Z m256 ymm k ymm
// 	VMAXPS.Z xmm  xmm k xmm
// 	VMAXPS.Z ymm  ymm k ymm
func VMAXPS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMAXPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXPS_Z: bad operands")
}

// VMAXSD: Return Maximum Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VMAXSD m64 xmm xmm
// 	VMAXSD xmm xmm xmm
// 	VMAXSD m64 xmm k xmm
// 	VMAXSD xmm xmm k xmm
func VMAXSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMAXSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMAXSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMAXSD: bad operands")
}

// VMAXSD_SAE: Return Maximum Scalar Double-Precision Floating-Point Value (Suppress All Exceptions).
//
// Forms:
//
// 	VMAXSD.SAE xmm xmm k xmm
// 	VMAXSD.SAE xmm xmm xmm
func VMAXSD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMAXSD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMAXSD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXSD_SAE: bad operands")
}

// VMAXSD_SAE_Z: Return Maximum Scalar Double-Precision Floating-Point Value (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VMAXSD.SAE.Z xmm xmm k xmm
func VMAXSD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VMAXSD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXSD_SAE_Z: bad operands")
}

// VMAXSD_Z: Return Maximum Scalar Double-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VMAXSD.Z m64 xmm k xmm
// 	VMAXSD.Z xmm xmm k xmm
func VMAXSD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VMAXSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXSD_Z: bad operands")
}

// VMAXSS: Return Maximum Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	VMAXSS m32 xmm xmm
// 	VMAXSS xmm xmm xmm
// 	VMAXSS m32 xmm k xmm
// 	VMAXSS xmm xmm k xmm
func VMAXSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMAXSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMAXSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMAXSS: bad operands")
}

// VMAXSS_SAE: Return Maximum Scalar Single-Precision Floating-Point Value (Suppress All Exceptions).
//
// Forms:
//
// 	VMAXSS.SAE xmm xmm k xmm
// 	VMAXSS.SAE xmm xmm xmm
func VMAXSS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMAXSS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMAXSS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXSS_SAE: bad operands")
}

// VMAXSS_SAE_Z: Return Maximum Scalar Single-Precision Floating-Point Value (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VMAXSS.SAE.Z xmm xmm k xmm
func VMAXSS_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VMAXSS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXSS_SAE_Z: bad operands")
}

// VMAXSS_Z: Return Maximum Scalar Single-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VMAXSS.Z m32 xmm k xmm
// 	VMAXSS.Z xmm xmm k xmm
func VMAXSS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VMAXSS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMAXSS_Z: bad operands")
}

// VMINPD: Return Minimum Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VMINPD m128 xmm xmm
// 	VMINPD m256 ymm ymm
// 	VMINPD xmm  xmm xmm
// 	VMINPD ymm  ymm ymm
// 	VMINPD m512 zmm k zmm
// 	VMINPD m512 zmm zmm
// 	VMINPD zmm  zmm k zmm
// 	VMINPD zmm  zmm zmm
// 	VMINPD m128 xmm k xmm
// 	VMINPD m256 ymm k ymm
// 	VMINPD xmm  xmm k xmm
// 	VMINPD ymm  ymm k ymm
func VMINPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINPD: bad operands")
}

// VMINPD_BCST: Return Minimum Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VMINPD.BCST m64 zmm k zmm
// 	VMINPD.BCST m64 zmm zmm
// 	VMINPD.BCST m64 xmm k xmm
// 	VMINPD.BCST m64 xmm xmm
// 	VMINPD.BCST m64 ymm k ymm
// 	VMINPD.BCST m64 ymm ymm
func VMINPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINPD_BCST: bad operands")
}

// VMINPD_BCST_Z: Return Minimum Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VMINPD.BCST.Z m64 zmm k zmm
// 	VMINPD.BCST.Z m64 xmm k xmm
// 	VMINPD.BCST.Z m64 ymm k ymm
func VMINPD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINPD_BCST_Z: bad operands")
}

// VMINPD_SAE: Return Minimum Packed Double-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VMINPD.SAE zmm zmm k zmm
// 	VMINPD.SAE zmm zmm zmm
func VMINPD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINPD_SAE: bad operands")
}

// VMINPD_SAE_Z: Return Minimum Packed Double-Precision Floating-Point Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VMINPD.SAE.Z zmm zmm k zmm
func VMINPD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINPD_SAE_Z: bad operands")
}

// VMINPD_Z: Return Minimum Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VMINPD.Z m512 zmm k zmm
// 	VMINPD.Z zmm  zmm k zmm
// 	VMINPD.Z m128 xmm k xmm
// 	VMINPD.Z m256 ymm k ymm
// 	VMINPD.Z xmm  xmm k xmm
// 	VMINPD.Z ymm  ymm k ymm
func VMINPD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMINPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINPD_Z: bad operands")
}

// VMINPS: Return Minimum Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VMINPS m128 xmm xmm
// 	VMINPS m256 ymm ymm
// 	VMINPS xmm  xmm xmm
// 	VMINPS ymm  ymm ymm
// 	VMINPS m512 zmm k zmm
// 	VMINPS m512 zmm zmm
// 	VMINPS zmm  zmm k zmm
// 	VMINPS zmm  zmm zmm
// 	VMINPS m128 xmm k xmm
// 	VMINPS m256 ymm k ymm
// 	VMINPS xmm  xmm k xmm
// 	VMINPS ymm  ymm k ymm
func VMINPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINPS: bad operands")
}

// VMINPS_BCST: Return Minimum Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VMINPS.BCST m32 zmm k zmm
// 	VMINPS.BCST m32 zmm zmm
// 	VMINPS.BCST m32 xmm k xmm
// 	VMINPS.BCST m32 xmm xmm
// 	VMINPS.BCST m32 ymm k ymm
// 	VMINPS.BCST m32 ymm ymm
func VMINPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINPS_BCST: bad operands")
}

// VMINPS_BCST_Z: Return Minimum Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VMINPS.BCST.Z m32 zmm k zmm
// 	VMINPS.BCST.Z m32 xmm k xmm
// 	VMINPS.BCST.Z m32 ymm k ymm
func VMINPS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINPS_BCST_Z: bad operands")
}

// VMINPS_SAE: Return Minimum Packed Single-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VMINPS.SAE zmm zmm k zmm
// 	VMINPS.SAE zmm zmm zmm
func VMINPS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINPS_SAE: bad operands")
}

// VMINPS_SAE_Z: Return Minimum Packed Single-Precision Floating-Point Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VMINPS.SAE.Z zmm zmm k zmm
func VMINPS_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINPS_SAE_Z: bad operands")
}

// VMINPS_Z: Return Minimum Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VMINPS.Z m512 zmm k zmm
// 	VMINPS.Z zmm  zmm k zmm
// 	VMINPS.Z m128 xmm k xmm
// 	VMINPS.Z m256 ymm k ymm
// 	VMINPS.Z xmm  xmm k xmm
// 	VMINPS.Z ymm  ymm k ymm
func VMINPS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMINPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINPS_Z: bad operands")
}

// VMINSD: Return Minimum Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VMINSD m64 xmm xmm
// 	VMINSD xmm xmm xmm
// 	VMINSD m64 xmm k xmm
// 	VMINSD xmm xmm k xmm
func VMINSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMINSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMINSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMINSD: bad operands")
}

// VMINSD_SAE: Return Minimum Scalar Double-Precision Floating-Point Value (Suppress All Exceptions).
//
// Forms:
//
// 	VMINSD.SAE xmm xmm k xmm
// 	VMINSD.SAE xmm xmm xmm
func VMINSD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMINSD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMINSD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINSD_SAE: bad operands")
}

// VMINSD_SAE_Z: Return Minimum Scalar Double-Precision Floating-Point Value (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VMINSD.SAE.Z xmm xmm k xmm
func VMINSD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VMINSD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINSD_SAE_Z: bad operands")
}

// VMINSD_Z: Return Minimum Scalar Double-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VMINSD.Z m64 xmm k xmm
// 	VMINSD.Z xmm xmm k xmm
func VMINSD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VMINSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINSD_Z: bad operands")
}

// VMINSS: Return Minimum Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	VMINSS m32 xmm xmm
// 	VMINSS xmm xmm xmm
// 	VMINSS m32 xmm k xmm
// 	VMINSS xmm xmm k xmm
func VMINSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMINSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMINSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMINSS: bad operands")
}

// VMINSS_SAE: Return Minimum Scalar Single-Precision Floating-Point Value (Suppress All Exceptions).
//
// Forms:
//
// 	VMINSS.SAE xmm xmm k xmm
// 	VMINSS.SAE xmm xmm xmm
func VMINSS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMINSS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMINSS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINSS_SAE: bad operands")
}

// VMINSS_SAE_Z: Return Minimum Scalar Single-Precision Floating-Point Value (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VMINSS.SAE.Z xmm xmm k xmm
func VMINSS_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VMINSS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINSS_SAE_Z: bad operands")
}

// VMINSS_Z: Return Minimum Scalar Single-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VMINSS.Z m32 xmm k xmm
// 	VMINSS.Z xmm xmm k xmm
func VMINSS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VMINSS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMINSS_Z: bad operands")
}

// VMOVAPD: Move Aligned Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VMOVAPD m128 xmm
// 	VMOVAPD m256 ymm
// 	VMOVAPD xmm  m128
// 	VMOVAPD xmm  xmm
// 	VMOVAPD ymm  m256
// 	VMOVAPD ymm  ymm
// 	VMOVAPD m512 k zmm
// 	VMOVAPD m512 zmm
// 	VMOVAPD zmm  k m512
// 	VMOVAPD zmm  k zmm
// 	VMOVAPD zmm  m512
// 	VMOVAPD zmm  zmm
// 	VMOVAPD m128 k xmm
// 	VMOVAPD m256 k ymm
// 	VMOVAPD xmm  k m128
// 	VMOVAPD xmm  k xmm
// 	VMOVAPD ymm  k m256
// 	VMOVAPD ymm  k ymm
func VMOVAPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM512(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVAPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVAPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVAPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM512(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVAPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVAPD: bad operands")
}

// VMOVAPD_Z: Move Aligned Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VMOVAPD.Z m512 k zmm
// 	VMOVAPD.Z zmm  k m512
// 	VMOVAPD.Z zmm  k zmm
// 	VMOVAPD.Z m128 k xmm
// 	VMOVAPD.Z m256 k ymm
// 	VMOVAPD.Z xmm  k m128
// 	VMOVAPD.Z xmm  k xmm
// 	VMOVAPD.Z ymm  k m256
// 	VMOVAPD.Z ymm  k ymm
func VMOVAPD_Z(mxyz, k, mxyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsM512(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVAPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsM128(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsM256(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVAPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVAPD_Z: bad operands")
}

// VMOVAPS: Move Aligned Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VMOVAPS m128 xmm
// 	VMOVAPS m256 ymm
// 	VMOVAPS xmm  m128
// 	VMOVAPS xmm  xmm
// 	VMOVAPS ymm  m256
// 	VMOVAPS ymm  ymm
// 	VMOVAPS m512 k zmm
// 	VMOVAPS m512 zmm
// 	VMOVAPS zmm  k m512
// 	VMOVAPS zmm  k zmm
// 	VMOVAPS zmm  m512
// 	VMOVAPS zmm  zmm
// 	VMOVAPS m128 k xmm
// 	VMOVAPS m256 k ymm
// 	VMOVAPS xmm  k m128
// 	VMOVAPS xmm  k xmm
// 	VMOVAPS ymm  k m256
// 	VMOVAPS ymm  k ymm
func VMOVAPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM512(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVAPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVAPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVAPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM512(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVAPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVAPS: bad operands")
}

// VMOVAPS_Z: Move Aligned Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VMOVAPS.Z m512 k zmm
// 	VMOVAPS.Z zmm  k m512
// 	VMOVAPS.Z zmm  k zmm
// 	VMOVAPS.Z m128 k xmm
// 	VMOVAPS.Z m256 k ymm
// 	VMOVAPS.Z xmm  k m128
// 	VMOVAPS.Z xmm  k xmm
// 	VMOVAPS.Z ymm  k m256
// 	VMOVAPS.Z ymm  k ymm
func VMOVAPS_Z(mxyz, k, mxyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsM512(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVAPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsM128(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsM256(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVAPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVAPS_Z: bad operands")
}

// VMOVD: Move Doubleword.
//
// Forms:
//
// 	VMOVD m32 xmm
// 	VMOVD r32 xmm
// 	VMOVD xmm m32
// 	VMOVD xmm r32
func VMOVD(mrx, mrx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mrx) && operand.IsXMM(mrx1),
		operand.IsR32(mrx) && operand.IsXMM(mrx1),
		operand.IsXMM(mrx) && operand.IsM32(mrx1),
		operand.IsXMM(mrx) && operand.IsR32(mrx1):
		return &intrep.Instruction{
			Opcode:   "VMOVD",
			Operands: []operand.Op{mrx, mrx1},
			Inputs:   []operand.Op{mrx},
			Outputs:  []operand.Op{mrx1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMOVD: bad operands")
}

// VMOVDDUP: Move One Double-FP and Duplicate.
//
// Forms:
//
// 	VMOVDDUP m256 ymm
// 	VMOVDDUP m64  xmm
// 	VMOVDDUP xmm  xmm
// 	VMOVDDUP ymm  ymm
// 	VMOVDDUP m512 k zmm
// 	VMOVDDUP m512 zmm
// 	VMOVDDUP zmm  k zmm
// 	VMOVDDUP zmm  zmm
// 	VMOVDDUP m256 k ymm
// 	VMOVDDUP m64  k xmm
// 	VMOVDDUP xmm  k xmm
// 	VMOVDDUP ymm  k ymm
func VMOVDDUP(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVDDUP",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVDDUP",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVDDUP",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVDDUP",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVDDUP: bad operands")
}

// VMOVDDUP_Z: Move One Double-FP and Duplicate (Zeroing Masking).
//
// Forms:
//
// 	VMOVDDUP.Z m512 k zmm
// 	VMOVDDUP.Z zmm  k zmm
// 	VMOVDDUP.Z m256 k ymm
// 	VMOVDDUP.Z m64  k xmm
// 	VMOVDDUP.Z xmm  k xmm
// 	VMOVDDUP.Z ymm  k ymm
func VMOVDDUP_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VMOVDDUP",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsM64(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VMOVDDUP",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVDDUP_Z: bad operands")
}

// VMOVDQA: Move Aligned Double Quadword.
//
// Forms:
//
// 	VMOVDQA m128 xmm
// 	VMOVDQA m256 ymm
// 	VMOVDQA xmm  m128
// 	VMOVDQA xmm  xmm
// 	VMOVDQA ymm  m256
// 	VMOVDQA ymm  ymm
func VMOVDQA(mxy, mxy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(mxy1),
		operand.IsM256(mxy) && operand.IsYMM(mxy1),
		operand.IsXMM(mxy) && operand.IsM128(mxy1),
		operand.IsXMM(mxy) && operand.IsXMM(mxy1),
		operand.IsYMM(mxy) && operand.IsM256(mxy1),
		operand.IsYMM(mxy) && operand.IsYMM(mxy1):
		return &intrep.Instruction{
			Opcode:   "VMOVDQA",
			Operands: []operand.Op{mxy, mxy1},
			Inputs:   []operand.Op{mxy},
			Outputs:  []operand.Op{mxy1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMOVDQA: bad operands")
}

// VMOVDQA32: Move Aligned Doubleword Values.
//
// Forms:
//
// 	VMOVDQA32 m512 k zmm
// 	VMOVDQA32 m512 zmm
// 	VMOVDQA32 zmm  k m512
// 	VMOVDQA32 zmm  k zmm
// 	VMOVDQA32 zmm  m512
// 	VMOVDQA32 zmm  zmm
// 	VMOVDQA32 m128 k xmm
// 	VMOVDQA32 m128 xmm
// 	VMOVDQA32 m256 k ymm
// 	VMOVDQA32 m256 ymm
// 	VMOVDQA32 xmm  k m128
// 	VMOVDQA32 xmm  k xmm
// 	VMOVDQA32 xmm  m128
// 	VMOVDQA32 xmm  xmm
// 	VMOVDQA32 ymm  k m256
// 	VMOVDQA32 ymm  k ymm
// 	VMOVDQA32 ymm  m256
// 	VMOVDQA32 ymm  ymm
func VMOVDQA32(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM512(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQA32",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQA32",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM512(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQA32",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQA32",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVDQA32: bad operands")
}

// VMOVDQA32_Z: Move Aligned Doubleword Values (Zeroing Masking).
//
// Forms:
//
// 	VMOVDQA32.Z m512 k zmm
// 	VMOVDQA32.Z zmm  k m512
// 	VMOVDQA32.Z zmm  k zmm
// 	VMOVDQA32.Z m128 k xmm
// 	VMOVDQA32.Z m256 k ymm
// 	VMOVDQA32.Z xmm  k m128
// 	VMOVDQA32.Z xmm  k xmm
// 	VMOVDQA32.Z ymm  k m256
// 	VMOVDQA32.Z ymm  k ymm
func VMOVDQA32_Z(mxyz, k, mxyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsM512(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVDQA32",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsM128(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsM256(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVDQA32",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVDQA32_Z: bad operands")
}

// VMOVDQA64: Move Aligned Quadword Values.
//
// Forms:
//
// 	VMOVDQA64 m512 k zmm
// 	VMOVDQA64 m512 zmm
// 	VMOVDQA64 zmm  k m512
// 	VMOVDQA64 zmm  k zmm
// 	VMOVDQA64 zmm  m512
// 	VMOVDQA64 zmm  zmm
// 	VMOVDQA64 m128 k xmm
// 	VMOVDQA64 m128 xmm
// 	VMOVDQA64 m256 k ymm
// 	VMOVDQA64 m256 ymm
// 	VMOVDQA64 xmm  k m128
// 	VMOVDQA64 xmm  k xmm
// 	VMOVDQA64 xmm  m128
// 	VMOVDQA64 xmm  xmm
// 	VMOVDQA64 ymm  k m256
// 	VMOVDQA64 ymm  k ymm
// 	VMOVDQA64 ymm  m256
// 	VMOVDQA64 ymm  ymm
func VMOVDQA64(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM512(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQA64",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQA64",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM512(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQA64",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQA64",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVDQA64: bad operands")
}

// VMOVDQA64_Z: Move Aligned Quadword Values (Zeroing Masking).
//
// Forms:
//
// 	VMOVDQA64.Z m512 k zmm
// 	VMOVDQA64.Z zmm  k m512
// 	VMOVDQA64.Z zmm  k zmm
// 	VMOVDQA64.Z m128 k xmm
// 	VMOVDQA64.Z m256 k ymm
// 	VMOVDQA64.Z xmm  k m128
// 	VMOVDQA64.Z xmm  k xmm
// 	VMOVDQA64.Z ymm  k m256
// 	VMOVDQA64.Z ymm  k ymm
func VMOVDQA64_Z(mxyz, k, mxyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsM512(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVDQA64",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsM128(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsM256(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVDQA64",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVDQA64_Z: bad operands")
}

// VMOVDQU: Move Unaligned Double Quadword.
//
// Forms:
//
// 	VMOVDQU m128 xmm
// 	VMOVDQU m256 ymm
// 	VMOVDQU xmm  m128
// 	VMOVDQU xmm  xmm
// 	VMOVDQU ymm  m256
// 	VMOVDQU ymm  ymm
func VMOVDQU(mxy, mxy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(mxy1),
		operand.IsM256(mxy) && operand.IsYMM(mxy1),
		operand.IsXMM(mxy) && operand.IsM128(mxy1),
		operand.IsXMM(mxy) && operand.IsXMM(mxy1),
		operand.IsYMM(mxy) && operand.IsM256(mxy1),
		operand.IsYMM(mxy) && operand.IsYMM(mxy1):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU",
			Operands: []operand.Op{mxy, mxy1},
			Inputs:   []operand.Op{mxy},
			Outputs:  []operand.Op{mxy1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMOVDQU: bad operands")
}

// VMOVDQU16: Move Unaligned Word Values.
//
// Forms:
//
// 	VMOVDQU16 m512 k zmm
// 	VMOVDQU16 m512 zmm
// 	VMOVDQU16 zmm  k m512
// 	VMOVDQU16 zmm  k zmm
// 	VMOVDQU16 zmm  m512
// 	VMOVDQU16 zmm  zmm
// 	VMOVDQU16 m128 k xmm
// 	VMOVDQU16 m128 xmm
// 	VMOVDQU16 m256 k ymm
// 	VMOVDQU16 m256 ymm
// 	VMOVDQU16 xmm  k m128
// 	VMOVDQU16 xmm  k xmm
// 	VMOVDQU16 xmm  m128
// 	VMOVDQU16 xmm  xmm
// 	VMOVDQU16 ymm  k m256
// 	VMOVDQU16 ymm  k ymm
// 	VMOVDQU16 ymm  m256
// 	VMOVDQU16 ymm  ymm
func VMOVDQU16(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM512(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU16",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU16",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM512(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU16",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU16",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VMOVDQU16: bad operands")
}

// VMOVDQU16_Z: Move Unaligned Word Values (Zeroing Masking).
//
// Forms:
//
// 	VMOVDQU16.Z m512 k zmm
// 	VMOVDQU16.Z zmm  k m512
// 	VMOVDQU16.Z zmm  k zmm
// 	VMOVDQU16.Z m128 k xmm
// 	VMOVDQU16.Z m256 k ymm
// 	VMOVDQU16.Z xmm  k m128
// 	VMOVDQU16.Z xmm  k xmm
// 	VMOVDQU16.Z ymm  k m256
// 	VMOVDQU16.Z ymm  k ymm
func VMOVDQU16_Z(mxyz, k, mxyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsM512(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU16",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsM128(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsM256(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU16",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VMOVDQU16_Z: bad operands")
}

// VMOVDQU32: Move Unaligned Doubleword Values.
//
// Forms:
//
// 	VMOVDQU32 m512 k zmm
// 	VMOVDQU32 m512 zmm
// 	VMOVDQU32 zmm  k m512
// 	VMOVDQU32 zmm  k zmm
// 	VMOVDQU32 zmm  m512
// 	VMOVDQU32 zmm  zmm
// 	VMOVDQU32 m128 k xmm
// 	VMOVDQU32 m128 xmm
// 	VMOVDQU32 m256 k ymm
// 	VMOVDQU32 m256 ymm
// 	VMOVDQU32 xmm  k m128
// 	VMOVDQU32 xmm  k xmm
// 	VMOVDQU32 xmm  m128
// 	VMOVDQU32 xmm  xmm
// 	VMOVDQU32 ymm  k m256
// 	VMOVDQU32 ymm  k ymm
// 	VMOVDQU32 ymm  m256
// 	VMOVDQU32 ymm  ymm
func VMOVDQU32(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM512(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU32",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU32",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM512(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU32",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU32",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVDQU32: bad operands")
}

// VMOVDQU32_Z: Move Unaligned Doubleword Values (Zeroing Masking).
//
// Forms:
//
// 	VMOVDQU32.Z m512 k zmm
// 	VMOVDQU32.Z zmm  k m512
// 	VMOVDQU32.Z zmm  k zmm
// 	VMOVDQU32.Z m128 k xmm
// 	VMOVDQU32.Z m256 k ymm
// 	VMOVDQU32.Z xmm  k m128
// 	VMOVDQU32.Z xmm  k xmm
// 	VMOVDQU32.Z ymm  k m256
// 	VMOVDQU32.Z ymm  k ymm
func VMOVDQU32_Z(mxyz, k, mxyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsM512(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU32",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsM128(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsM256(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU32",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVDQU32_Z: bad operands")
}

// VMOVDQU64: Move Unaligned Quadword Values.
//
// Forms:
//
// 	VMOVDQU64 m512 k zmm
// 	VMOVDQU64 m512 zmm
// 	VMOVDQU64 zmm  k m512
// 	VMOVDQU64 zmm  k zmm
// 	VMOVDQU64 zmm  m512
// 	VMOVDQU64 zmm  zmm
// 	VMOVDQU64 m128 k xmm
// 	VMOVDQU64 m128 xmm
// 	VMOVDQU64 m256 k ymm
// 	VMOVDQU64 m256 ymm
// 	VMOVDQU64 xmm  k m128
// 	VMOVDQU64 xmm  k xmm
// 	VMOVDQU64 xmm  m128
// 	VMOVDQU64 xmm  xmm
// 	VMOVDQU64 ymm  k m256
// 	VMOVDQU64 ymm  k ymm
// 	VMOVDQU64 ymm  m256
// 	VMOVDQU64 ymm  ymm
func VMOVDQU64(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM512(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU64",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU64",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM512(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU64",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU64",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVDQU64: bad operands")
}

// VMOVDQU64_Z: Move Unaligned Quadword Values (Zeroing Masking).
//
// Forms:
//
// 	VMOVDQU64.Z m512 k zmm
// 	VMOVDQU64.Z zmm  k m512
// 	VMOVDQU64.Z zmm  k zmm
// 	VMOVDQU64.Z m128 k xmm
// 	VMOVDQU64.Z m256 k ymm
// 	VMOVDQU64.Z xmm  k m128
// 	VMOVDQU64.Z xmm  k xmm
// 	VMOVDQU64.Z ymm  k m256
// 	VMOVDQU64.Z ymm  k ymm
func VMOVDQU64_Z(mxyz, k, mxyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsM512(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU64",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsM128(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsM256(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU64",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVDQU64_Z: bad operands")
}

// VMOVDQU8: Move Unaligned Byte Values.
//
// Forms:
//
// 	VMOVDQU8 m512 k zmm
// 	VMOVDQU8 m512 zmm
// 	VMOVDQU8 zmm  k m512
// 	VMOVDQU8 zmm  k zmm
// 	VMOVDQU8 zmm  m512
// 	VMOVDQU8 zmm  zmm
// 	VMOVDQU8 m128 k xmm
// 	VMOVDQU8 m128 xmm
// 	VMOVDQU8 m256 k ymm
// 	VMOVDQU8 m256 ymm
// 	VMOVDQU8 xmm  k m128
// 	VMOVDQU8 xmm  k xmm
// 	VMOVDQU8 xmm  m128
// 	VMOVDQU8 xmm  xmm
// 	VMOVDQU8 ymm  k m256
// 	VMOVDQU8 ymm  k ymm
// 	VMOVDQU8 ymm  m256
// 	VMOVDQU8 ymm  ymm
func VMOVDQU8(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM512(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU8",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU8",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM512(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU8",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU8",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VMOVDQU8: bad operands")
}

// VMOVDQU8_Z: Move Unaligned Byte Values (Zeroing Masking).
//
// Forms:
//
// 	VMOVDQU8.Z m512 k zmm
// 	VMOVDQU8.Z zmm  k m512
// 	VMOVDQU8.Z zmm  k zmm
// 	VMOVDQU8.Z m128 k xmm
// 	VMOVDQU8.Z m256 k ymm
// 	VMOVDQU8.Z xmm  k m128
// 	VMOVDQU8.Z xmm  k xmm
// 	VMOVDQU8.Z ymm  k m256
// 	VMOVDQU8.Z ymm  k ymm
func VMOVDQU8_Z(mxyz, k, mxyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsM512(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU8",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsM128(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsM256(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVDQU8",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VMOVDQU8_Z: bad operands")
}

// VMOVHLPS: Move Packed Single-Precision Floating-Point Values High to Low.
//
// Forms:
//
// 	VMOVHLPS xmm xmm xmm
func VMOVHLPS(x, x1, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VMOVHLPS",
			Operands: []operand.Op{x, x1, x2},
			Inputs:   []operand.Op{x, x1},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMOVHLPS: bad operands")
}

// VMOVHPD: Move High Packed Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VMOVHPD m64 xmm xmm
// 	VMOVHPD xmm m64
func VMOVHPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVHPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM64(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVHPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMOVHPD: bad operands")
}

// VMOVHPS: Move High Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VMOVHPS m64 xmm xmm
// 	VMOVHPS xmm m64
func VMOVHPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVHPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM64(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVHPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMOVHPS: bad operands")
}

// VMOVLHPS: Move Packed Single-Precision Floating-Point Values Low to High.
//
// Forms:
//
// 	VMOVLHPS xmm xmm xmm
func VMOVLHPS(x, x1, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VMOVLHPS",
			Operands: []operand.Op{x, x1, x2},
			Inputs:   []operand.Op{x, x1},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMOVLHPS: bad operands")
}

// VMOVLPD: Move Low Packed Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VMOVLPD m64 xmm xmm
// 	VMOVLPD xmm m64
func VMOVLPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVLPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM64(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVLPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMOVLPD: bad operands")
}

// VMOVLPS: Move Low Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VMOVLPS m64 xmm xmm
// 	VMOVLPS xmm m64
func VMOVLPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVLPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM64(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVLPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMOVLPS: bad operands")
}

// VMOVMSKPD: Extract Packed Double-Precision Floating-Point Sign Mask.
//
// Forms:
//
// 	VMOVMSKPD xmm r32
// 	VMOVMSKPD ymm r32
func VMOVMSKPD(xy, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(xy) && operand.IsR32(r),
		operand.IsYMM(xy) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VMOVMSKPD",
			Operands: []operand.Op{xy, r},
			Inputs:   []operand.Op{xy},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMOVMSKPD: bad operands")
}

// VMOVMSKPS: Extract Packed Single-Precision Floating-Point Sign Mask.
//
// Forms:
//
// 	VMOVMSKPS xmm r32
// 	VMOVMSKPS ymm r32
func VMOVMSKPS(xy, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(xy) && operand.IsR32(r),
		operand.IsYMM(xy) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VMOVMSKPS",
			Operands: []operand.Op{xy, r},
			Inputs:   []operand.Op{xy},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMOVMSKPS: bad operands")
}

// VMOVNTDQ: Store Double Quadword Using Non-Temporal Hint.
//
// Forms:
//
// 	VMOVNTDQ xmm m128
// 	VMOVNTDQ ymm m256
// 	VMOVNTDQ zmm m512
func VMOVNTDQ(xyz, m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(xyz) && operand.IsM128(m),
		operand.IsYMM(xyz) && operand.IsM256(m):
		return &intrep.Instruction{
			Opcode:   "VMOVNTDQ",
			Operands: []operand.Op{xyz, m},
			Inputs:   []operand.Op{xyz},
			Outputs:  []operand.Op{m},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsZMM(xyz) && operand.IsM512(m):
		return &intrep.Instruction{
			Opcode:   "VMOVNTDQ",
			Operands: []operand.Op{xyz, m},
			Inputs:   []operand.Op{xyz},
			Outputs:  []operand.Op{m},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVNTDQ: bad operands")
}

// VMOVNTDQA: Load Double Quadword Non-Temporal Aligned Hint.
//
// Forms:
//
// 	VMOVNTDQA m256 ymm
// 	VMOVNTDQA m128 xmm
// 	VMOVNTDQA m512 zmm
func VMOVNTDQA(m, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(m) && operand.IsXMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VMOVNTDQA",
			Operands: []operand.Op{m, xyz},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsM256(m) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VMOVNTDQA",
			Operands: []operand.Op{m, xyz},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX2"},
		}, nil
	case operand.IsM512(m) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VMOVNTDQA",
			Operands: []operand.Op{m, xyz},
			Inputs:   []operand.Op{m},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVNTDQA: bad operands")
}

// VMOVNTPD: Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint.
//
// Forms:
//
// 	VMOVNTPD xmm m128
// 	VMOVNTPD ymm m256
// 	VMOVNTPD zmm m512
func VMOVNTPD(xyz, m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(xyz) && operand.IsM128(m),
		operand.IsYMM(xyz) && operand.IsM256(m):
		return &intrep.Instruction{
			Opcode:   "VMOVNTPD",
			Operands: []operand.Op{xyz, m},
			Inputs:   []operand.Op{xyz},
			Outputs:  []operand.Op{m},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsZMM(xyz) && operand.IsM512(m):
		return &intrep.Instruction{
			Opcode:   "VMOVNTPD",
			Operands: []operand.Op{xyz, m},
			Inputs:   []operand.Op{xyz},
			Outputs:  []operand.Op{m},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVNTPD: bad operands")
}

// VMOVNTPS: Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint.
//
// Forms:
//
// 	VMOVNTPS xmm m128
// 	VMOVNTPS ymm m256
// 	VMOVNTPS zmm m512
func VMOVNTPS(xyz, m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(xyz) && operand.IsM128(m),
		operand.IsYMM(xyz) && operand.IsM256(m):
		return &intrep.Instruction{
			Opcode:   "VMOVNTPS",
			Operands: []operand.Op{xyz, m},
			Inputs:   []operand.Op{xyz},
			Outputs:  []operand.Op{m},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsZMM(xyz) && operand.IsM512(m):
		return &intrep.Instruction{
			Opcode:   "VMOVNTPS",
			Operands: []operand.Op{xyz, m},
			Inputs:   []operand.Op{xyz},
			Outputs:  []operand.Op{m},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVNTPS: bad operands")
}

// VMOVQ: Move Quadword.
//
// Forms:
//
// 	VMOVQ m64 xmm
// 	VMOVQ r64 xmm
// 	VMOVQ xmm m64
// 	VMOVQ xmm r64
// 	VMOVQ xmm xmm
func VMOVQ(mrx, mrx1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mrx) && operand.IsXMM(mrx1),
		operand.IsR64(mrx) && operand.IsXMM(mrx1),
		operand.IsXMM(mrx) && operand.IsM64(mrx1),
		operand.IsXMM(mrx) && operand.IsR64(mrx1),
		operand.IsXMM(mrx) && operand.IsXMM(mrx1):
		return &intrep.Instruction{
			Opcode:   "VMOVQ",
			Operands: []operand.Op{mrx, mrx1},
			Inputs:   []operand.Op{mrx},
			Outputs:  []operand.Op{mrx1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMOVQ: bad operands")
}

// VMOVSD: Move Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VMOVSD m64 xmm
// 	VMOVSD xmm m64
// 	VMOVSD xmm xmm xmm
// 	VMOVSD m64 k   xmm
// 	VMOVSD xmm k   m64
// 	VMOVSD xmm xmm k xmm
func VMOVSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMOVSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM64(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMOVSD: bad operands")
}

// VMOVSD_Z: Move Scalar Double-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VMOVSD.Z m64 k   xmm
// 	VMOVSD.Z xmm xmm k xmm
func VMOVSD_Z(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMOVSD",
			Suffixes: []string{"Z"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVSD",
			Suffixes: []string{"Z"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVSD_Z: bad operands")
}

// VMOVSHDUP: Move Packed Single-FP High and Duplicate.
//
// Forms:
//
// 	VMOVSHDUP m128 xmm
// 	VMOVSHDUP m256 ymm
// 	VMOVSHDUP xmm  xmm
// 	VMOVSHDUP ymm  ymm
// 	VMOVSHDUP m512 k zmm
// 	VMOVSHDUP m512 zmm
// 	VMOVSHDUP zmm  k zmm
// 	VMOVSHDUP zmm  zmm
// 	VMOVSHDUP m128 k xmm
// 	VMOVSHDUP m256 k ymm
// 	VMOVSHDUP xmm  k xmm
// 	VMOVSHDUP ymm  k ymm
func VMOVSHDUP(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVSHDUP",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVSHDUP",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVSHDUP",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVSHDUP",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVSHDUP: bad operands")
}

// VMOVSHDUP_Z: Move Packed Single-FP High and Duplicate (Zeroing Masking).
//
// Forms:
//
// 	VMOVSHDUP.Z m512 k zmm
// 	VMOVSHDUP.Z zmm  k zmm
// 	VMOVSHDUP.Z m128 k xmm
// 	VMOVSHDUP.Z m256 k ymm
// 	VMOVSHDUP.Z xmm  k xmm
// 	VMOVSHDUP.Z ymm  k ymm
func VMOVSHDUP_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VMOVSHDUP",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VMOVSHDUP",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVSHDUP_Z: bad operands")
}

// VMOVSLDUP: Move Packed Single-FP Low and Duplicate.
//
// Forms:
//
// 	VMOVSLDUP m128 xmm
// 	VMOVSLDUP m256 ymm
// 	VMOVSLDUP xmm  xmm
// 	VMOVSLDUP ymm  ymm
// 	VMOVSLDUP m512 k zmm
// 	VMOVSLDUP m512 zmm
// 	VMOVSLDUP zmm  k zmm
// 	VMOVSLDUP zmm  zmm
// 	VMOVSLDUP m128 k xmm
// 	VMOVSLDUP m256 k ymm
// 	VMOVSLDUP xmm  k xmm
// 	VMOVSLDUP ymm  k ymm
func VMOVSLDUP(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVSLDUP",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVSLDUP",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVSLDUP",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVSLDUP",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVSLDUP: bad operands")
}

// VMOVSLDUP_Z: Move Packed Single-FP Low and Duplicate (Zeroing Masking).
//
// Forms:
//
// 	VMOVSLDUP.Z m512 k zmm
// 	VMOVSLDUP.Z zmm  k zmm
// 	VMOVSLDUP.Z m128 k xmm
// 	VMOVSLDUP.Z m256 k ymm
// 	VMOVSLDUP.Z xmm  k xmm
// 	VMOVSLDUP.Z ymm  k ymm
func VMOVSLDUP_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VMOVSLDUP",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VMOVSLDUP",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVSLDUP_Z: bad operands")
}

// VMOVSS: Move Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VMOVSS m32 xmm
// 	VMOVSS xmm m32
// 	VMOVSS xmm xmm xmm
// 	VMOVSS m32 k   xmm
// 	VMOVSS xmm k   m32
// 	VMOVSS xmm xmm k xmm
func VMOVSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMOVSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM32(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM32(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMOVSS: bad operands")
}

// VMOVSS_Z: Move Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VMOVSS.Z m32 k   xmm
// 	VMOVSS.Z xmm xmm k xmm
func VMOVSS_Z(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMOVSS",
			Suffixes: []string{"Z"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVSS",
			Suffixes: []string{"Z"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVSS_Z: bad operands")
}

// VMOVUPD: Move Unaligned Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VMOVUPD m128 xmm
// 	VMOVUPD m256 ymm
// 	VMOVUPD xmm  m128
// 	VMOVUPD xmm  xmm
// 	VMOVUPD ymm  m256
// 	VMOVUPD ymm  ymm
// 	VMOVUPD m512 k zmm
// 	VMOVUPD m512 zmm
// 	VMOVUPD zmm  k m512
// 	VMOVUPD zmm  k zmm
// 	VMOVUPD zmm  m512
// 	VMOVUPD zmm  zmm
// 	VMOVUPD m128 k xmm
// 	VMOVUPD m256 k ymm
// 	VMOVUPD xmm  k m128
// 	VMOVUPD xmm  k xmm
// 	VMOVUPD ymm  k m256
// 	VMOVUPD ymm  k ymm
func VMOVUPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM512(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVUPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVUPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVUPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM512(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVUPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVUPD: bad operands")
}

// VMOVUPD_Z: Move Unaligned Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VMOVUPD.Z m512 k zmm
// 	VMOVUPD.Z zmm  k m512
// 	VMOVUPD.Z zmm  k zmm
// 	VMOVUPD.Z m128 k xmm
// 	VMOVUPD.Z m256 k ymm
// 	VMOVUPD.Z xmm  k m128
// 	VMOVUPD.Z xmm  k xmm
// 	VMOVUPD.Z ymm  k m256
// 	VMOVUPD.Z ymm  k ymm
func VMOVUPD_Z(mxyz, k, mxyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsM512(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVUPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsM128(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsM256(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVUPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVUPD_Z: bad operands")
}

// VMOVUPS: Move Unaligned Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VMOVUPS m128 xmm
// 	VMOVUPS m256 ymm
// 	VMOVUPS xmm  m128
// 	VMOVUPS xmm  xmm
// 	VMOVUPS ymm  m256
// 	VMOVUPS ymm  ymm
// 	VMOVUPS m512 k zmm
// 	VMOVUPS m512 zmm
// 	VMOVUPS zmm  k m512
// 	VMOVUPS zmm  k zmm
// 	VMOVUPS zmm  m512
// 	VMOVUPS zmm  zmm
// 	VMOVUPS m128 k xmm
// 	VMOVUPS m256 k ymm
// 	VMOVUPS xmm  k m128
// 	VMOVUPS xmm  k xmm
// 	VMOVUPS ymm  k m256
// 	VMOVUPS ymm  k ymm
func VMOVUPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM512(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVUPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMOVUPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVUPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM512(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VMOVUPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVUPS: bad operands")
}

// VMOVUPS_Z: Move Unaligned Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VMOVUPS.Z m512 k zmm
// 	VMOVUPS.Z zmm  k m512
// 	VMOVUPS.Z zmm  k zmm
// 	VMOVUPS.Z m128 k xmm
// 	VMOVUPS.Z m256 k ymm
// 	VMOVUPS.Z xmm  k m128
// 	VMOVUPS.Z xmm  k xmm
// 	VMOVUPS.Z ymm  k m256
// 	VMOVUPS.Z ymm  k ymm
func VMOVUPS_Z(mxyz, k, mxyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsM512(mxyz1),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVUPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsM128(mxyz1),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsM256(mxyz1),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(mxyz1):
		return &intrep.Instruction{
			Opcode:   "VMOVUPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, mxyz1},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{mxyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMOVUPS_Z: bad operands")
}

// VMPSADBW: Compute Multiple Packed Sums of Absolute Difference.
//
// Forms:
//
// 	VMPSADBW imm8 m256 ymm ymm
// 	VMPSADBW imm8 ymm  ymm ymm
// 	VMPSADBW imm8 m128 xmm xmm
// 	VMPSADBW imm8 xmm  xmm xmm
func VMPSADBW(i, mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsIMM8(i) && operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VMPSADBW",
			Operands: []operand.Op{i, mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsIMM8(i) && operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VMPSADBW",
			Operands: []operand.Op{i, mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VMPSADBW: bad operands")
}

// VMULPD: Multiply Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VMULPD m128 xmm xmm
// 	VMULPD m256 ymm ymm
// 	VMULPD xmm  xmm xmm
// 	VMULPD ymm  ymm ymm
// 	VMULPD m512 zmm k zmm
// 	VMULPD m512 zmm zmm
// 	VMULPD zmm  zmm k zmm
// 	VMULPD zmm  zmm zmm
// 	VMULPD m128 xmm k xmm
// 	VMULPD m256 ymm k ymm
// 	VMULPD xmm  xmm k xmm
// 	VMULPD ymm  ymm k ymm
func VMULPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPD: bad operands")
}

// VMULPD_BCST: Multiply Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VMULPD.BCST m64 zmm k zmm
// 	VMULPD.BCST m64 zmm zmm
// 	VMULPD.BCST m64 xmm k xmm
// 	VMULPD.BCST m64 xmm xmm
// 	VMULPD.BCST m64 ymm k ymm
// 	VMULPD.BCST m64 ymm ymm
func VMULPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPD_BCST: bad operands")
}

// VMULPD_BCST_Z: Multiply Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VMULPD.BCST.Z m64 zmm k zmm
// 	VMULPD.BCST.Z m64 xmm k xmm
// 	VMULPD.BCST.Z m64 ymm k ymm
func VMULPD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPD_BCST_Z: bad operands")
}

// VMULPD_RD_SAE: Multiply Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VMULPD.RD_SAE zmm zmm k zmm
// 	VMULPD.RD_SAE zmm zmm zmm
func VMULPD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPD_RD_SAE: bad operands")
}

// VMULPD_RD_SAE_Z: Multiply Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VMULPD.RD_SAE.Z zmm zmm k zmm
func VMULPD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPD_RD_SAE_Z: bad operands")
}

// VMULPD_RN_SAE: Multiply Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VMULPD.RN_SAE zmm zmm k zmm
// 	VMULPD.RN_SAE zmm zmm zmm
func VMULPD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPD_RN_SAE: bad operands")
}

// VMULPD_RN_SAE_Z: Multiply Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VMULPD.RN_SAE.Z zmm zmm k zmm
func VMULPD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPD_RN_SAE_Z: bad operands")
}

// VMULPD_RU_SAE: Multiply Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VMULPD.RU_SAE zmm zmm k zmm
// 	VMULPD.RU_SAE zmm zmm zmm
func VMULPD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPD_RU_SAE: bad operands")
}

// VMULPD_RU_SAE_Z: Multiply Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VMULPD.RU_SAE.Z zmm zmm k zmm
func VMULPD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPD_RU_SAE_Z: bad operands")
}

// VMULPD_RZ_SAE: Multiply Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VMULPD.RZ_SAE zmm zmm k zmm
// 	VMULPD.RZ_SAE zmm zmm zmm
func VMULPD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPD_RZ_SAE: bad operands")
}

// VMULPD_RZ_SAE_Z: Multiply Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VMULPD.RZ_SAE.Z zmm zmm k zmm
func VMULPD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPD_RZ_SAE_Z: bad operands")
}

// VMULPD_Z: Multiply Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VMULPD.Z m512 zmm k zmm
// 	VMULPD.Z zmm  zmm k zmm
// 	VMULPD.Z m128 xmm k xmm
// 	VMULPD.Z m256 ymm k ymm
// 	VMULPD.Z xmm  xmm k xmm
// 	VMULPD.Z ymm  ymm k ymm
func VMULPD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMULPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPD_Z: bad operands")
}

// VMULPS: Multiply Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VMULPS m128 xmm xmm
// 	VMULPS m256 ymm ymm
// 	VMULPS xmm  xmm xmm
// 	VMULPS ymm  ymm ymm
// 	VMULPS m512 zmm k zmm
// 	VMULPS m512 zmm zmm
// 	VMULPS zmm  zmm k zmm
// 	VMULPS zmm  zmm zmm
// 	VMULPS m128 xmm k xmm
// 	VMULPS m256 ymm k ymm
// 	VMULPS xmm  xmm k xmm
// 	VMULPS ymm  ymm k ymm
func VMULPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPS: bad operands")
}

// VMULPS_BCST: Multiply Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VMULPS.BCST m32 zmm k zmm
// 	VMULPS.BCST m32 zmm zmm
// 	VMULPS.BCST m32 xmm k xmm
// 	VMULPS.BCST m32 xmm xmm
// 	VMULPS.BCST m32 ymm k ymm
// 	VMULPS.BCST m32 ymm ymm
func VMULPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPS_BCST: bad operands")
}

// VMULPS_BCST_Z: Multiply Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VMULPS.BCST.Z m32 zmm k zmm
// 	VMULPS.BCST.Z m32 xmm k xmm
// 	VMULPS.BCST.Z m32 ymm k ymm
func VMULPS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPS_BCST_Z: bad operands")
}

// VMULPS_RD_SAE: Multiply Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VMULPS.RD_SAE zmm zmm k zmm
// 	VMULPS.RD_SAE zmm zmm zmm
func VMULPS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPS_RD_SAE: bad operands")
}

// VMULPS_RD_SAE_Z: Multiply Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VMULPS.RD_SAE.Z zmm zmm k zmm
func VMULPS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPS_RD_SAE_Z: bad operands")
}

// VMULPS_RN_SAE: Multiply Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VMULPS.RN_SAE zmm zmm k zmm
// 	VMULPS.RN_SAE zmm zmm zmm
func VMULPS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPS_RN_SAE: bad operands")
}

// VMULPS_RN_SAE_Z: Multiply Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VMULPS.RN_SAE.Z zmm zmm k zmm
func VMULPS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPS_RN_SAE_Z: bad operands")
}

// VMULPS_RU_SAE: Multiply Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VMULPS.RU_SAE zmm zmm k zmm
// 	VMULPS.RU_SAE zmm zmm zmm
func VMULPS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPS_RU_SAE: bad operands")
}

// VMULPS_RU_SAE_Z: Multiply Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VMULPS.RU_SAE.Z zmm zmm k zmm
func VMULPS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPS_RU_SAE_Z: bad operands")
}

// VMULPS_RZ_SAE: Multiply Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VMULPS.RZ_SAE zmm zmm k zmm
// 	VMULPS.RZ_SAE zmm zmm zmm
func VMULPS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPS_RZ_SAE: bad operands")
}

// VMULPS_RZ_SAE_Z: Multiply Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VMULPS.RZ_SAE.Z zmm zmm k zmm
func VMULPS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPS_RZ_SAE_Z: bad operands")
}

// VMULPS_Z: Multiply Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VMULPS.Z m512 zmm k zmm
// 	VMULPS.Z zmm  zmm k zmm
// 	VMULPS.Z m128 xmm k xmm
// 	VMULPS.Z m256 ymm k ymm
// 	VMULPS.Z xmm  xmm k xmm
// 	VMULPS.Z ymm  ymm k ymm
func VMULPS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VMULPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULPS_Z: bad operands")
}

// VMULSD: Multiply Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VMULSD m64 xmm xmm
// 	VMULSD xmm xmm xmm
// 	VMULSD m64 xmm k xmm
// 	VMULSD xmm xmm k xmm
func VMULSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMULSD: bad operands")
}

// VMULSD_RD_SAE: Multiply Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VMULSD.RD_SAE xmm xmm k xmm
// 	VMULSD.RD_SAE xmm xmm xmm
func VMULSD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSD_RD_SAE: bad operands")
}

// VMULSD_RD_SAE_Z: Multiply Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VMULSD.RD_SAE.Z xmm xmm k xmm
func VMULSD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSD_RD_SAE_Z: bad operands")
}

// VMULSD_RN_SAE: Multiply Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VMULSD.RN_SAE xmm xmm k xmm
// 	VMULSD.RN_SAE xmm xmm xmm
func VMULSD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSD_RN_SAE: bad operands")
}

// VMULSD_RN_SAE_Z: Multiply Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VMULSD.RN_SAE.Z xmm xmm k xmm
func VMULSD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSD_RN_SAE_Z: bad operands")
}

// VMULSD_RU_SAE: Multiply Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VMULSD.RU_SAE xmm xmm k xmm
// 	VMULSD.RU_SAE xmm xmm xmm
func VMULSD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSD_RU_SAE: bad operands")
}

// VMULSD_RU_SAE_Z: Multiply Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VMULSD.RU_SAE.Z xmm xmm k xmm
func VMULSD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSD_RU_SAE_Z: bad operands")
}

// VMULSD_RZ_SAE: Multiply Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VMULSD.RZ_SAE xmm xmm k xmm
// 	VMULSD.RZ_SAE xmm xmm xmm
func VMULSD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSD_RZ_SAE: bad operands")
}

// VMULSD_RZ_SAE_Z: Multiply Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VMULSD.RZ_SAE.Z xmm xmm k xmm
func VMULSD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSD_RZ_SAE_Z: bad operands")
}

// VMULSD_Z: Multiply Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VMULSD.Z m64 xmm k xmm
// 	VMULSD.Z xmm xmm k xmm
func VMULSD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VMULSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSD_Z: bad operands")
}

// VMULSS: Multiply Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VMULSS m32 xmm xmm
// 	VMULSS xmm xmm xmm
// 	VMULSS m32 xmm k xmm
// 	VMULSS xmm xmm k xmm
func VMULSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VMULSS: bad operands")
}

// VMULSS_RD_SAE: Multiply Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VMULSS.RD_SAE xmm xmm k xmm
// 	VMULSS.RD_SAE xmm xmm xmm
func VMULSS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSS_RD_SAE: bad operands")
}

// VMULSS_RD_SAE_Z: Multiply Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VMULSS.RD_SAE.Z xmm xmm k xmm
func VMULSS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSS_RD_SAE_Z: bad operands")
}

// VMULSS_RN_SAE: Multiply Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VMULSS.RN_SAE xmm xmm k xmm
// 	VMULSS.RN_SAE xmm xmm xmm
func VMULSS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSS_RN_SAE: bad operands")
}

// VMULSS_RN_SAE_Z: Multiply Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VMULSS.RN_SAE.Z xmm xmm k xmm
func VMULSS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSS_RN_SAE_Z: bad operands")
}

// VMULSS_RU_SAE: Multiply Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VMULSS.RU_SAE xmm xmm k xmm
// 	VMULSS.RU_SAE xmm xmm xmm
func VMULSS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSS_RU_SAE: bad operands")
}

// VMULSS_RU_SAE_Z: Multiply Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VMULSS.RU_SAE.Z xmm xmm k xmm
func VMULSS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSS_RU_SAE_Z: bad operands")
}

// VMULSS_RZ_SAE: Multiply Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VMULSS.RZ_SAE xmm xmm k xmm
// 	VMULSS.RZ_SAE xmm xmm xmm
func VMULSS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSS_RZ_SAE: bad operands")
}

// VMULSS_RZ_SAE_Z: Multiply Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VMULSS.RZ_SAE.Z xmm xmm k xmm
func VMULSS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSS_RZ_SAE_Z: bad operands")
}

// VMULSS_Z: Multiply Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VMULSS.Z m32 xmm k xmm
// 	VMULSS.Z xmm xmm k xmm
func VMULSS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VMULSS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VMULSS_Z: bad operands")
}

// VORPD: Bitwise Logical OR of Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VORPD m128 xmm xmm
// 	VORPD m256 ymm ymm
// 	VORPD xmm  xmm xmm
// 	VORPD ymm  ymm ymm
// 	VORPD m512 zmm k zmm
// 	VORPD m512 zmm zmm
// 	VORPD zmm  zmm k zmm
// 	VORPD zmm  zmm zmm
// 	VORPD m128 xmm k xmm
// 	VORPD m256 ymm k ymm
// 	VORPD xmm  xmm k xmm
// 	VORPD ymm  ymm k ymm
func VORPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VORPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VORPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VORPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VORPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VORPD: bad operands")
}

// VORPD_BCST: Bitwise Logical OR of Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VORPD.BCST m64 zmm k zmm
// 	VORPD.BCST m64 zmm zmm
// 	VORPD.BCST m64 xmm k xmm
// 	VORPD.BCST m64 xmm xmm
// 	VORPD.BCST m64 ymm k ymm
// 	VORPD.BCST m64 ymm ymm
func VORPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VORPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VORPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VORPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VORPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VORPD_BCST: bad operands")
}

// VORPD_BCST_Z: Bitwise Logical OR of Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VORPD.BCST.Z m64 zmm k zmm
// 	VORPD.BCST.Z m64 xmm k xmm
// 	VORPD.BCST.Z m64 ymm k ymm
func VORPD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VORPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VORPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VORPD_BCST_Z: bad operands")
}

// VORPD_Z: Bitwise Logical OR of Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VORPD.Z m512 zmm k zmm
// 	VORPD.Z zmm  zmm k zmm
// 	VORPD.Z m128 xmm k xmm
// 	VORPD.Z m256 ymm k ymm
// 	VORPD.Z xmm  xmm k xmm
// 	VORPD.Z ymm  ymm k ymm
func VORPD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VORPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VORPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VORPD_Z: bad operands")
}

// VORPS: Bitwise Logical OR of Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VORPS m128 xmm xmm
// 	VORPS m256 ymm ymm
// 	VORPS xmm  xmm xmm
// 	VORPS ymm  ymm ymm
// 	VORPS m512 zmm k zmm
// 	VORPS m512 zmm zmm
// 	VORPS zmm  zmm k zmm
// 	VORPS zmm  zmm zmm
// 	VORPS m128 xmm k xmm
// 	VORPS m256 ymm k ymm
// 	VORPS xmm  xmm k xmm
// 	VORPS ymm  ymm k ymm
func VORPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VORPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VORPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VORPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VORPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VORPS: bad operands")
}

// VORPS_BCST: Bitwise Logical OR of Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VORPS.BCST m32 zmm k zmm
// 	VORPS.BCST m32 zmm zmm
// 	VORPS.BCST m32 xmm k xmm
// 	VORPS.BCST m32 xmm xmm
// 	VORPS.BCST m32 ymm k ymm
// 	VORPS.BCST m32 ymm ymm
func VORPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VORPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VORPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VORPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VORPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VORPS_BCST: bad operands")
}

// VORPS_BCST_Z: Bitwise Logical OR of Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VORPS.BCST.Z m32 zmm k zmm
// 	VORPS.BCST.Z m32 xmm k xmm
// 	VORPS.BCST.Z m32 ymm k ymm
func VORPS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VORPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VORPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VORPS_BCST_Z: bad operands")
}

// VORPS_Z: Bitwise Logical OR of Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VORPS.Z m512 zmm k zmm
// 	VORPS.Z zmm  zmm k zmm
// 	VORPS.Z m128 xmm k xmm
// 	VORPS.Z m256 ymm k ymm
// 	VORPS.Z xmm  xmm k xmm
// 	VORPS.Z ymm  ymm k ymm
func VORPS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VORPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VORPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VORPS_Z: bad operands")
}

// VPABSB: Packed Absolute Value of Byte Integers.
//
// Forms:
//
// 	VPABSB m256 ymm
// 	VPABSB ymm  ymm
// 	VPABSB m128 xmm
// 	VPABSB xmm  xmm
// 	VPABSB m512 k zmm
// 	VPABSB m512 zmm
// 	VPABSB zmm  k zmm
// 	VPABSB zmm  zmm
// 	VPABSB m128 k xmm
// 	VPABSB m256 k ymm
// 	VPABSB xmm  k xmm
// 	VPABSB ymm  k ymm
func VPABSB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPABSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPABSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPABSB: bad operands")
}

// VPABSB_Z: Packed Absolute Value of Byte Integers (Zeroing Masking).
//
// Forms:
//
// 	VPABSB.Z m512 k zmm
// 	VPABSB.Z zmm  k zmm
// 	VPABSB.Z m128 k xmm
// 	VPABSB.Z m256 k ymm
// 	VPABSB.Z xmm  k xmm
// 	VPABSB.Z ymm  k ymm
func VPABSB_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPABSB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPABSB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPABSB_Z: bad operands")
}

// VPABSD: Packed Absolute Value of Doubleword Integers.
//
// Forms:
//
// 	VPABSD m256 ymm
// 	VPABSD ymm  ymm
// 	VPABSD m128 xmm
// 	VPABSD xmm  xmm
// 	VPABSD m512 k zmm
// 	VPABSD m512 zmm
// 	VPABSD zmm  k zmm
// 	VPABSD zmm  zmm
// 	VPABSD m128 k xmm
// 	VPABSD m256 k ymm
// 	VPABSD xmm  k xmm
// 	VPABSD ymm  k ymm
func VPABSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPABSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPABSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPABSD: bad operands")
}

// VPABSD_BCST: Packed Absolute Value of Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VPABSD.BCST m32 k zmm
// 	VPABSD.BCST m32 zmm
// 	VPABSD.BCST m32 k xmm
// 	VPABSD.BCST m32 k ymm
// 	VPABSD.BCST m32 xmm
// 	VPABSD.BCST m32 ymm
func VPABSD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPABSD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPABSD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPABSD_BCST: bad operands")
}

// VPABSD_BCST_Z: Packed Absolute Value of Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPABSD.BCST.Z m32 k zmm
// 	VPABSD.BCST.Z m32 k xmm
// 	VPABSD.BCST.Z m32 k ymm
func VPABSD_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPABSD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPABSD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPABSD_BCST_Z: bad operands")
}

// VPABSD_Z: Packed Absolute Value of Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPABSD.Z m512 k zmm
// 	VPABSD.Z zmm  k zmm
// 	VPABSD.Z m128 k xmm
// 	VPABSD.Z m256 k ymm
// 	VPABSD.Z xmm  k xmm
// 	VPABSD.Z ymm  k ymm
func VPABSD_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPABSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPABSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPABSD_Z: bad operands")
}

// VPABSQ: Packed Absolute Value of Quadword Integers.
//
// Forms:
//
// 	VPABSQ m512 k zmm
// 	VPABSQ m512 zmm
// 	VPABSQ zmm  k zmm
// 	VPABSQ zmm  zmm
// 	VPABSQ m128 k xmm
// 	VPABSQ m128 xmm
// 	VPABSQ m256 k ymm
// 	VPABSQ m256 ymm
// 	VPABSQ xmm  k xmm
// 	VPABSQ xmm  xmm
// 	VPABSQ ymm  k ymm
// 	VPABSQ ymm  ymm
func VPABSQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPABSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPABSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPABSQ: bad operands")
}

// VPABSQ_BCST: Packed Absolute Value of Quadword Integers (Broadcast).
//
// Forms:
//
// 	VPABSQ.BCST m64 k zmm
// 	VPABSQ.BCST m64 zmm
// 	VPABSQ.BCST m64 k xmm
// 	VPABSQ.BCST m64 k ymm
// 	VPABSQ.BCST m64 xmm
// 	VPABSQ.BCST m64 ymm
func VPABSQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPABSQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPABSQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPABSQ_BCST: bad operands")
}

// VPABSQ_BCST_Z: Packed Absolute Value of Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPABSQ.BCST.Z m64 k zmm
// 	VPABSQ.BCST.Z m64 k xmm
// 	VPABSQ.BCST.Z m64 k ymm
func VPABSQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPABSQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPABSQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPABSQ_BCST_Z: bad operands")
}

// VPABSQ_Z: Packed Absolute Value of Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPABSQ.Z m512 k zmm
// 	VPABSQ.Z zmm  k zmm
// 	VPABSQ.Z m128 k xmm
// 	VPABSQ.Z m256 k ymm
// 	VPABSQ.Z xmm  k xmm
// 	VPABSQ.Z ymm  k ymm
func VPABSQ_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPABSQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPABSQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPABSQ_Z: bad operands")
}

// VPABSW: Packed Absolute Value of Word Integers.
//
// Forms:
//
// 	VPABSW m256 ymm
// 	VPABSW ymm  ymm
// 	VPABSW m128 xmm
// 	VPABSW xmm  xmm
// 	VPABSW m512 k zmm
// 	VPABSW m512 zmm
// 	VPABSW zmm  k zmm
// 	VPABSW zmm  zmm
// 	VPABSW m128 k xmm
// 	VPABSW m256 k ymm
// 	VPABSW xmm  k xmm
// 	VPABSW ymm  k ymm
func VPABSW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPABSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPABSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPABSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPABSW: bad operands")
}

// VPABSW_Z: Packed Absolute Value of Word Integers (Zeroing Masking).
//
// Forms:
//
// 	VPABSW.Z m512 k zmm
// 	VPABSW.Z zmm  k zmm
// 	VPABSW.Z m128 k xmm
// 	VPABSW.Z m256 k ymm
// 	VPABSW.Z xmm  k xmm
// 	VPABSW.Z ymm  k ymm
func VPABSW_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPABSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPABSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPABSW_Z: bad operands")
}

// VPACKSSDW: Pack Doublewords into Words with Signed Saturation.
//
// Forms:
//
// 	VPACKSSDW m256 ymm ymm
// 	VPACKSSDW ymm  ymm ymm
// 	VPACKSSDW m128 xmm xmm
// 	VPACKSSDW xmm  xmm xmm
// 	VPACKSSDW m512 zmm k zmm
// 	VPACKSSDW m512 zmm zmm
// 	VPACKSSDW zmm  zmm k zmm
// 	VPACKSSDW zmm  zmm zmm
// 	VPACKSSDW m128 xmm k xmm
// 	VPACKSSDW m256 ymm k ymm
// 	VPACKSSDW xmm  xmm k xmm
// 	VPACKSSDW ymm  ymm k ymm
func VPACKSSDW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPACKSSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPACKSSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKSSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKSSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKSSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPACKSSDW: bad operands")
}

// VPACKSSDW_BCST: Pack Doublewords into Words with Signed Saturation (Broadcast).
//
// Forms:
//
// 	VPACKSSDW.BCST m32 zmm k zmm
// 	VPACKSSDW.BCST m32 zmm zmm
// 	VPACKSSDW.BCST m32 xmm k xmm
// 	VPACKSSDW.BCST m32 xmm xmm
// 	VPACKSSDW.BCST m32 ymm k ymm
// 	VPACKSSDW.BCST m32 ymm ymm
func VPACKSSDW_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPACKSSDW",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPACKSSDW",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKSSDW",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKSSDW",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPACKSSDW_BCST: bad operands")
}

// VPACKSSDW_BCST_Z: Pack Doublewords into Words with Signed Saturation (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPACKSSDW.BCST.Z m32 zmm k zmm
// 	VPACKSSDW.BCST.Z m32 xmm k xmm
// 	VPACKSSDW.BCST.Z m32 ymm k ymm
func VPACKSSDW_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPACKSSDW",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPACKSSDW",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPACKSSDW_BCST_Z: bad operands")
}

// VPACKSSDW_Z: Pack Doublewords into Words with Signed Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPACKSSDW.Z m512 zmm k zmm
// 	VPACKSSDW.Z zmm  zmm k zmm
// 	VPACKSSDW.Z m128 xmm k xmm
// 	VPACKSSDW.Z m256 ymm k ymm
// 	VPACKSSDW.Z xmm  xmm k xmm
// 	VPACKSSDW.Z ymm  ymm k ymm
func VPACKSSDW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPACKSSDW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPACKSSDW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPACKSSDW_Z: bad operands")
}

// VPACKSSWB: Pack Words into Bytes with Signed Saturation.
//
// Forms:
//
// 	VPACKSSWB m256 ymm ymm
// 	VPACKSSWB ymm  ymm ymm
// 	VPACKSSWB m128 xmm xmm
// 	VPACKSSWB xmm  xmm xmm
// 	VPACKSSWB m512 zmm k zmm
// 	VPACKSSWB m512 zmm zmm
// 	VPACKSSWB zmm  zmm k zmm
// 	VPACKSSWB zmm  zmm zmm
// 	VPACKSSWB m128 xmm k xmm
// 	VPACKSSWB m256 ymm k ymm
// 	VPACKSSWB xmm  xmm k xmm
// 	VPACKSSWB ymm  ymm k ymm
func VPACKSSWB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPACKSSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPACKSSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKSSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKSSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKSSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPACKSSWB: bad operands")
}

// VPACKSSWB_Z: Pack Words into Bytes with Signed Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPACKSSWB.Z m512 zmm k zmm
// 	VPACKSSWB.Z zmm  zmm k zmm
// 	VPACKSSWB.Z m128 xmm k xmm
// 	VPACKSSWB.Z m256 ymm k ymm
// 	VPACKSSWB.Z xmm  xmm k xmm
// 	VPACKSSWB.Z ymm  ymm k ymm
func VPACKSSWB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPACKSSWB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPACKSSWB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPACKSSWB_Z: bad operands")
}

// VPACKUSDW: Pack Doublewords into Words with Unsigned Saturation.
//
// Forms:
//
// 	VPACKUSDW m256 ymm ymm
// 	VPACKUSDW ymm  ymm ymm
// 	VPACKUSDW m128 xmm xmm
// 	VPACKUSDW xmm  xmm xmm
// 	VPACKUSDW m512 zmm k zmm
// 	VPACKUSDW m512 zmm zmm
// 	VPACKUSDW zmm  zmm k zmm
// 	VPACKUSDW zmm  zmm zmm
// 	VPACKUSDW m128 xmm k xmm
// 	VPACKUSDW m256 ymm k ymm
// 	VPACKUSDW xmm  xmm k xmm
// 	VPACKUSDW ymm  ymm k ymm
func VPACKUSDW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPACKUSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPACKUSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKUSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKUSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKUSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPACKUSDW: bad operands")
}

// VPACKUSDW_BCST: Pack Doublewords into Words with Unsigned Saturation (Broadcast).
//
// Forms:
//
// 	VPACKUSDW.BCST m32 zmm k zmm
// 	VPACKUSDW.BCST m32 zmm zmm
// 	VPACKUSDW.BCST m32 xmm k xmm
// 	VPACKUSDW.BCST m32 xmm xmm
// 	VPACKUSDW.BCST m32 ymm k ymm
// 	VPACKUSDW.BCST m32 ymm ymm
func VPACKUSDW_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPACKUSDW",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPACKUSDW",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKUSDW",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKUSDW",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPACKUSDW_BCST: bad operands")
}

// VPACKUSDW_BCST_Z: Pack Doublewords into Words with Unsigned Saturation (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPACKUSDW.BCST.Z m32 zmm k zmm
// 	VPACKUSDW.BCST.Z m32 xmm k xmm
// 	VPACKUSDW.BCST.Z m32 ymm k ymm
func VPACKUSDW_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPACKUSDW",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPACKUSDW",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPACKUSDW_BCST_Z: bad operands")
}

// VPACKUSDW_Z: Pack Doublewords into Words with Unsigned Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPACKUSDW.Z m512 zmm k zmm
// 	VPACKUSDW.Z zmm  zmm k zmm
// 	VPACKUSDW.Z m128 xmm k xmm
// 	VPACKUSDW.Z m256 ymm k ymm
// 	VPACKUSDW.Z xmm  xmm k xmm
// 	VPACKUSDW.Z ymm  ymm k ymm
func VPACKUSDW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPACKUSDW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPACKUSDW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPACKUSDW_Z: bad operands")
}

// VPACKUSWB: Pack Words into Bytes with Unsigned Saturation.
//
// Forms:
//
// 	VPACKUSWB m256 ymm ymm
// 	VPACKUSWB ymm  ymm ymm
// 	VPACKUSWB m128 xmm xmm
// 	VPACKUSWB xmm  xmm xmm
// 	VPACKUSWB m512 zmm k zmm
// 	VPACKUSWB m512 zmm zmm
// 	VPACKUSWB zmm  zmm k zmm
// 	VPACKUSWB zmm  zmm zmm
// 	VPACKUSWB m128 xmm k xmm
// 	VPACKUSWB m256 ymm k ymm
// 	VPACKUSWB xmm  xmm k xmm
// 	VPACKUSWB ymm  ymm k ymm
func VPACKUSWB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPACKUSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPACKUSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKUSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKUSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPACKUSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPACKUSWB: bad operands")
}

// VPACKUSWB_Z: Pack Words into Bytes with Unsigned Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPACKUSWB.Z m512 zmm k zmm
// 	VPACKUSWB.Z zmm  zmm k zmm
// 	VPACKUSWB.Z m128 xmm k xmm
// 	VPACKUSWB.Z m256 ymm k ymm
// 	VPACKUSWB.Z xmm  xmm k xmm
// 	VPACKUSWB.Z ymm  ymm k ymm
func VPACKUSWB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPACKUSWB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPACKUSWB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPACKUSWB_Z: bad operands")
}

// VPADDB: Add Packed Byte Integers.
//
// Forms:
//
// 	VPADDB m256 ymm ymm
// 	VPADDB ymm  ymm ymm
// 	VPADDB m128 xmm xmm
// 	VPADDB xmm  xmm xmm
// 	VPADDB m512 zmm k zmm
// 	VPADDB m512 zmm zmm
// 	VPADDB zmm  zmm k zmm
// 	VPADDB zmm  zmm zmm
// 	VPADDB m128 xmm k xmm
// 	VPADDB m256 ymm k ymm
// 	VPADDB xmm  xmm k xmm
// 	VPADDB ymm  ymm k ymm
func VPADDB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPADDB: bad operands")
}

// VPADDB_Z: Add Packed Byte Integers (Zeroing Masking).
//
// Forms:
//
// 	VPADDB.Z m512 zmm k zmm
// 	VPADDB.Z zmm  zmm k zmm
// 	VPADDB.Z m128 xmm k xmm
// 	VPADDB.Z m256 ymm k ymm
// 	VPADDB.Z xmm  xmm k xmm
// 	VPADDB.Z ymm  ymm k ymm
func VPADDB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPADDB_Z: bad operands")
}

// VPADDD: Add Packed Doubleword Integers.
//
// Forms:
//
// 	VPADDD m256 ymm ymm
// 	VPADDD ymm  ymm ymm
// 	VPADDD m128 xmm xmm
// 	VPADDD xmm  xmm xmm
// 	VPADDD m512 zmm k zmm
// 	VPADDD m512 zmm zmm
// 	VPADDD zmm  zmm k zmm
// 	VPADDD zmm  zmm zmm
// 	VPADDD m128 xmm k xmm
// 	VPADDD m256 ymm k ymm
// 	VPADDD xmm  xmm k xmm
// 	VPADDD ymm  ymm k ymm
func VPADDD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPADDD: bad operands")
}

// VPADDD_BCST: Add Packed Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VPADDD.BCST m32 zmm k zmm
// 	VPADDD.BCST m32 zmm zmm
// 	VPADDD.BCST m32 xmm k xmm
// 	VPADDD.BCST m32 xmm xmm
// 	VPADDD.BCST m32 ymm k ymm
// 	VPADDD.BCST m32 ymm ymm
func VPADDD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPADDD_BCST: bad operands")
}

// VPADDD_BCST_Z: Add Packed Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPADDD.BCST.Z m32 zmm k zmm
// 	VPADDD.BCST.Z m32 xmm k xmm
// 	VPADDD.BCST.Z m32 ymm k ymm
func VPADDD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPADDD_BCST_Z: bad operands")
}

// VPADDD_Z: Add Packed Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPADDD.Z m512 zmm k zmm
// 	VPADDD.Z zmm  zmm k zmm
// 	VPADDD.Z m128 xmm k xmm
// 	VPADDD.Z m256 ymm k ymm
// 	VPADDD.Z xmm  xmm k xmm
// 	VPADDD.Z ymm  ymm k ymm
func VPADDD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPADDD_Z: bad operands")
}

// VPADDQ: Add Packed Quadword Integers.
//
// Forms:
//
// 	VPADDQ m256 ymm ymm
// 	VPADDQ ymm  ymm ymm
// 	VPADDQ m128 xmm xmm
// 	VPADDQ xmm  xmm xmm
// 	VPADDQ m512 zmm k zmm
// 	VPADDQ m512 zmm zmm
// 	VPADDQ zmm  zmm k zmm
// 	VPADDQ zmm  zmm zmm
// 	VPADDQ m128 xmm k xmm
// 	VPADDQ m256 ymm k ymm
// 	VPADDQ xmm  xmm k xmm
// 	VPADDQ ymm  ymm k ymm
func VPADDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPADDQ: bad operands")
}

// VPADDQ_BCST: Add Packed Quadword Integers (Broadcast).
//
// Forms:
//
// 	VPADDQ.BCST m64 zmm k zmm
// 	VPADDQ.BCST m64 zmm zmm
// 	VPADDQ.BCST m64 xmm k xmm
// 	VPADDQ.BCST m64 xmm xmm
// 	VPADDQ.BCST m64 ymm k ymm
// 	VPADDQ.BCST m64 ymm ymm
func VPADDQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPADDQ_BCST: bad operands")
}

// VPADDQ_BCST_Z: Add Packed Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPADDQ.BCST.Z m64 zmm k zmm
// 	VPADDQ.BCST.Z m64 xmm k xmm
// 	VPADDQ.BCST.Z m64 ymm k ymm
func VPADDQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPADDQ_BCST_Z: bad operands")
}

// VPADDQ_Z: Add Packed Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPADDQ.Z m512 zmm k zmm
// 	VPADDQ.Z zmm  zmm k zmm
// 	VPADDQ.Z m128 xmm k xmm
// 	VPADDQ.Z m256 ymm k ymm
// 	VPADDQ.Z xmm  xmm k xmm
// 	VPADDQ.Z ymm  ymm k ymm
func VPADDQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPADDQ_Z: bad operands")
}

// VPADDSB: Add Packed Signed Byte Integers with Signed Saturation.
//
// Forms:
//
// 	VPADDSB m256 ymm ymm
// 	VPADDSB ymm  ymm ymm
// 	VPADDSB m128 xmm xmm
// 	VPADDSB xmm  xmm xmm
// 	VPADDSB m512 zmm k zmm
// 	VPADDSB m512 zmm zmm
// 	VPADDSB zmm  zmm k zmm
// 	VPADDSB zmm  zmm zmm
// 	VPADDSB m128 xmm k xmm
// 	VPADDSB m256 ymm k ymm
// 	VPADDSB xmm  xmm k xmm
// 	VPADDSB ymm  ymm k ymm
func VPADDSB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPADDSB: bad operands")
}

// VPADDSB_Z: Add Packed Signed Byte Integers with Signed Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPADDSB.Z m512 zmm k zmm
// 	VPADDSB.Z zmm  zmm k zmm
// 	VPADDSB.Z m128 xmm k xmm
// 	VPADDSB.Z m256 ymm k ymm
// 	VPADDSB.Z xmm  xmm k xmm
// 	VPADDSB.Z ymm  ymm k ymm
func VPADDSB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDSB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDSB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPADDSB_Z: bad operands")
}

// VPADDSW: Add Packed Signed Word Integers with Signed Saturation.
//
// Forms:
//
// 	VPADDSW m256 ymm ymm
// 	VPADDSW ymm  ymm ymm
// 	VPADDSW m128 xmm xmm
// 	VPADDSW xmm  xmm xmm
// 	VPADDSW m512 zmm k zmm
// 	VPADDSW m512 zmm zmm
// 	VPADDSW zmm  zmm k zmm
// 	VPADDSW zmm  zmm zmm
// 	VPADDSW m128 xmm k xmm
// 	VPADDSW m256 ymm k ymm
// 	VPADDSW xmm  xmm k xmm
// 	VPADDSW ymm  ymm k ymm
func VPADDSW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPADDSW: bad operands")
}

// VPADDSW_Z: Add Packed Signed Word Integers with Signed Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPADDSW.Z m512 zmm k zmm
// 	VPADDSW.Z zmm  zmm k zmm
// 	VPADDSW.Z m128 xmm k xmm
// 	VPADDSW.Z m256 ymm k ymm
// 	VPADDSW.Z xmm  xmm k xmm
// 	VPADDSW.Z ymm  ymm k ymm
func VPADDSW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPADDSW_Z: bad operands")
}

// VPADDUSB: Add Packed Unsigned Byte Integers with Unsigned Saturation.
//
// Forms:
//
// 	VPADDUSB m256 ymm ymm
// 	VPADDUSB ymm  ymm ymm
// 	VPADDUSB m128 xmm xmm
// 	VPADDUSB xmm  xmm xmm
// 	VPADDUSB m512 zmm k zmm
// 	VPADDUSB m512 zmm zmm
// 	VPADDUSB zmm  zmm k zmm
// 	VPADDUSB zmm  zmm zmm
// 	VPADDUSB m128 xmm k xmm
// 	VPADDUSB m256 ymm k ymm
// 	VPADDUSB xmm  xmm k xmm
// 	VPADDUSB ymm  ymm k ymm
func VPADDUSB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDUSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDUSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDUSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDUSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDUSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPADDUSB: bad operands")
}

// VPADDUSB_Z: Add Packed Unsigned Byte Integers with Unsigned Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPADDUSB.Z m512 zmm k zmm
// 	VPADDUSB.Z zmm  zmm k zmm
// 	VPADDUSB.Z m128 xmm k xmm
// 	VPADDUSB.Z m256 ymm k ymm
// 	VPADDUSB.Z xmm  xmm k xmm
// 	VPADDUSB.Z ymm  ymm k ymm
func VPADDUSB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDUSB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDUSB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPADDUSB_Z: bad operands")
}

// VPADDUSW: Add Packed Unsigned Word Integers with Unsigned Saturation.
//
// Forms:
//
// 	VPADDUSW m256 ymm ymm
// 	VPADDUSW ymm  ymm ymm
// 	VPADDUSW m128 xmm xmm
// 	VPADDUSW xmm  xmm xmm
// 	VPADDUSW m512 zmm k zmm
// 	VPADDUSW m512 zmm zmm
// 	VPADDUSW zmm  zmm k zmm
// 	VPADDUSW zmm  zmm zmm
// 	VPADDUSW m128 xmm k xmm
// 	VPADDUSW m256 ymm k ymm
// 	VPADDUSW xmm  xmm k xmm
// 	VPADDUSW ymm  ymm k ymm
func VPADDUSW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDUSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDUSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDUSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDUSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDUSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPADDUSW: bad operands")
}

// VPADDUSW_Z: Add Packed Unsigned Word Integers with Unsigned Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPADDUSW.Z m512 zmm k zmm
// 	VPADDUSW.Z zmm  zmm k zmm
// 	VPADDUSW.Z m128 xmm k xmm
// 	VPADDUSW.Z m256 ymm k ymm
// 	VPADDUSW.Z xmm  xmm k xmm
// 	VPADDUSW.Z ymm  ymm k ymm
func VPADDUSW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDUSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDUSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPADDUSW_Z: bad operands")
}

// VPADDW: Add Packed Word Integers.
//
// Forms:
//
// 	VPADDW m256 ymm ymm
// 	VPADDW ymm  ymm ymm
// 	VPADDW m128 xmm xmm
// 	VPADDW xmm  xmm xmm
// 	VPADDW m512 zmm k zmm
// 	VPADDW m512 zmm zmm
// 	VPADDW zmm  zmm k zmm
// 	VPADDW zmm  zmm zmm
// 	VPADDW m128 xmm k xmm
// 	VPADDW m256 ymm k ymm
// 	VPADDW xmm  xmm k xmm
// 	VPADDW ymm  ymm k ymm
func VPADDW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPADDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPADDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPADDW: bad operands")
}

// VPADDW_Z: Add Packed Word Integers (Zeroing Masking).
//
// Forms:
//
// 	VPADDW.Z m512 zmm k zmm
// 	VPADDW.Z zmm  zmm k zmm
// 	VPADDW.Z m128 xmm k xmm
// 	VPADDW.Z m256 ymm k ymm
// 	VPADDW.Z xmm  xmm k xmm
// 	VPADDW.Z ymm  ymm k ymm
func VPADDW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPADDW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPADDW_Z: bad operands")
}

// VPALIGNR: Packed Align Right.
//
// Forms:
//
// 	VPALIGNR imm8 m256 ymm ymm
// 	VPALIGNR imm8 ymm  ymm ymm
// 	VPALIGNR imm8 m128 xmm xmm
// 	VPALIGNR imm8 xmm  xmm xmm
// 	VPALIGNR imm8 m512 zmm k zmm
// 	VPALIGNR imm8 m512 zmm zmm
// 	VPALIGNR imm8 zmm  zmm k zmm
// 	VPALIGNR imm8 zmm  zmm zmm
// 	VPALIGNR imm8 m128 xmm k xmm
// 	VPALIGNR imm8 m256 ymm k ymm
// 	VPALIGNR imm8 xmm  xmm k xmm
// 	VPALIGNR imm8 ymm  ymm k ymm
func VPALIGNR(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPALIGNR",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPALIGNR",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPALIGNR",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPALIGNR",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPALIGNR",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPALIGNR: bad operands")
}

// VPALIGNR_Z: Packed Align Right (Zeroing Masking).
//
// Forms:
//
// 	VPALIGNR.Z imm8 m512 zmm k zmm
// 	VPALIGNR.Z imm8 zmm  zmm k zmm
// 	VPALIGNR.Z imm8 m128 xmm k xmm
// 	VPALIGNR.Z imm8 m256 ymm k ymm
// 	VPALIGNR.Z imm8 xmm  xmm k xmm
// 	VPALIGNR.Z imm8 ymm  ymm k ymm
func VPALIGNR_Z(i, mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPALIGNR",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPALIGNR",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPALIGNR_Z: bad operands")
}

// VPAND: Packed Bitwise Logical AND.
//
// Forms:
//
// 	VPAND m256 ymm ymm
// 	VPAND ymm  ymm ymm
// 	VPAND m128 xmm xmm
// 	VPAND xmm  xmm xmm
func VPAND(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPAND",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPAND",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPAND: bad operands")
}

// VPANDD: Bitwise Logical AND of Packed Doubleword Integers.
//
// Forms:
//
// 	VPANDD m512 zmm k zmm
// 	VPANDD m512 zmm zmm
// 	VPANDD zmm  zmm k zmm
// 	VPANDD zmm  zmm zmm
// 	VPANDD m128 xmm k xmm
// 	VPANDD m128 xmm xmm
// 	VPANDD m256 ymm k ymm
// 	VPANDD m256 ymm ymm
// 	VPANDD xmm  xmm k xmm
// 	VPANDD xmm  xmm xmm
// 	VPANDD ymm  ymm k ymm
// 	VPANDD ymm  ymm ymm
func VPANDD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDD: bad operands")
}

// VPANDD_BCST: Bitwise Logical AND of Packed Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VPANDD.BCST m32 zmm k zmm
// 	VPANDD.BCST m32 zmm zmm
// 	VPANDD.BCST m32 xmm k xmm
// 	VPANDD.BCST m32 xmm xmm
// 	VPANDD.BCST m32 ymm k ymm
// 	VPANDD.BCST m32 ymm ymm
func VPANDD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDD_BCST: bad operands")
}

// VPANDD_BCST_Z: Bitwise Logical AND of Packed Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPANDD.BCST.Z m32 zmm k zmm
// 	VPANDD.BCST.Z m32 xmm k xmm
// 	VPANDD.BCST.Z m32 ymm k ymm
func VPANDD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDD_BCST_Z: bad operands")
}

// VPANDD_Z: Bitwise Logical AND of Packed Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPANDD.Z m512 zmm k zmm
// 	VPANDD.Z zmm  zmm k zmm
// 	VPANDD.Z m128 xmm k xmm
// 	VPANDD.Z m256 ymm k ymm
// 	VPANDD.Z xmm  xmm k xmm
// 	VPANDD.Z ymm  ymm k ymm
func VPANDD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDD_Z: bad operands")
}

// VPANDN: Packed Bitwise Logical AND NOT.
//
// Forms:
//
// 	VPANDN m256 ymm ymm
// 	VPANDN ymm  ymm ymm
// 	VPANDN m128 xmm xmm
// 	VPANDN xmm  xmm xmm
func VPANDN(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:           "VPANDN",
			Operands:         []operand.Op{mxy, xy, xy1},
			Inputs:           []operand.Op{mxy, xy},
			Outputs:          []operand.Op{xy1},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPANDN",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:           "VPANDN",
			Operands:         []operand.Op{mxy, xy, xy1},
			Inputs:           []operand.Op{mxy, xy},
			Outputs:          []operand.Op{xy1},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPANDN",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPANDN: bad operands")
}

// VPANDND: Bitwise Logical AND NOT of Packed Doubleword Integers.
//
// Forms:
//
// 	VPANDND m512 zmm k zmm
// 	VPANDND m512 zmm zmm
// 	VPANDND zmm  zmm k zmm
// 	VPANDND zmm  zmm zmm
// 	VPANDND m128 xmm k xmm
// 	VPANDND m128 xmm xmm
// 	VPANDND m256 ymm k ymm
// 	VPANDND m256 ymm ymm
// 	VPANDND xmm  xmm k xmm
// 	VPANDND xmm  xmm xmm
// 	VPANDND ymm  ymm k ymm
// 	VPANDND ymm  ymm ymm
func VPANDND(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDND",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDND",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDND",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDND",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDND: bad operands")
}

// VPANDND_BCST: Bitwise Logical AND NOT of Packed Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VPANDND.BCST m32 zmm k zmm
// 	VPANDND.BCST m32 zmm zmm
// 	VPANDND.BCST m32 xmm k xmm
// 	VPANDND.BCST m32 xmm xmm
// 	VPANDND.BCST m32 ymm k ymm
// 	VPANDND.BCST m32 ymm ymm
func VPANDND_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDND",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDND",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDND",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDND",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDND_BCST: bad operands")
}

// VPANDND_BCST_Z: Bitwise Logical AND NOT of Packed Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPANDND.BCST.Z m32 zmm k zmm
// 	VPANDND.BCST.Z m32 xmm k xmm
// 	VPANDND.BCST.Z m32 ymm k ymm
func VPANDND_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDND",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDND",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDND_BCST_Z: bad operands")
}

// VPANDND_Z: Bitwise Logical AND NOT of Packed Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPANDND.Z m512 zmm k zmm
// 	VPANDND.Z zmm  zmm k zmm
// 	VPANDND.Z m128 xmm k xmm
// 	VPANDND.Z m256 ymm k ymm
// 	VPANDND.Z xmm  xmm k xmm
// 	VPANDND.Z ymm  ymm k ymm
func VPANDND_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDND",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDND",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDND_Z: bad operands")
}

// VPANDNQ: Bitwise Logical AND NOT of Packed Quadword Integers.
//
// Forms:
//
// 	VPANDNQ m512 zmm k zmm
// 	VPANDNQ m512 zmm zmm
// 	VPANDNQ zmm  zmm k zmm
// 	VPANDNQ zmm  zmm zmm
// 	VPANDNQ m128 xmm k xmm
// 	VPANDNQ m128 xmm xmm
// 	VPANDNQ m256 ymm k ymm
// 	VPANDNQ m256 ymm ymm
// 	VPANDNQ xmm  xmm k xmm
// 	VPANDNQ xmm  xmm xmm
// 	VPANDNQ ymm  ymm k ymm
// 	VPANDNQ ymm  ymm ymm
func VPANDNQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDNQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDNQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDNQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDNQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDNQ: bad operands")
}

// VPANDNQ_BCST: Bitwise Logical AND NOT of Packed Quadword Integers (Broadcast).
//
// Forms:
//
// 	VPANDNQ.BCST m64 zmm k zmm
// 	VPANDNQ.BCST m64 zmm zmm
// 	VPANDNQ.BCST m64 xmm k xmm
// 	VPANDNQ.BCST m64 xmm xmm
// 	VPANDNQ.BCST m64 ymm k ymm
// 	VPANDNQ.BCST m64 ymm ymm
func VPANDNQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDNQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDNQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDNQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDNQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDNQ_BCST: bad operands")
}

// VPANDNQ_BCST_Z: Bitwise Logical AND NOT of Packed Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPANDNQ.BCST.Z m64 zmm k zmm
// 	VPANDNQ.BCST.Z m64 xmm k xmm
// 	VPANDNQ.BCST.Z m64 ymm k ymm
func VPANDNQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDNQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDNQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDNQ_BCST_Z: bad operands")
}

// VPANDNQ_Z: Bitwise Logical AND NOT of Packed Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPANDNQ.Z m512 zmm k zmm
// 	VPANDNQ.Z zmm  zmm k zmm
// 	VPANDNQ.Z m128 xmm k xmm
// 	VPANDNQ.Z m256 ymm k ymm
// 	VPANDNQ.Z xmm  xmm k xmm
// 	VPANDNQ.Z ymm  ymm k ymm
func VPANDNQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDNQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDNQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDNQ_Z: bad operands")
}

// VPANDQ: Bitwise Logical AND of Packed Quadword Integers.
//
// Forms:
//
// 	VPANDQ m512 zmm k zmm
// 	VPANDQ m512 zmm zmm
// 	VPANDQ zmm  zmm k zmm
// 	VPANDQ zmm  zmm zmm
// 	VPANDQ m128 xmm k xmm
// 	VPANDQ m128 xmm xmm
// 	VPANDQ m256 ymm k ymm
// 	VPANDQ m256 ymm ymm
// 	VPANDQ xmm  xmm k xmm
// 	VPANDQ xmm  xmm xmm
// 	VPANDQ ymm  ymm k ymm
// 	VPANDQ ymm  ymm ymm
func VPANDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDQ: bad operands")
}

// VPANDQ_BCST: Bitwise Logical AND of Packed Quadword Integers (Broadcast).
//
// Forms:
//
// 	VPANDQ.BCST m64 zmm k zmm
// 	VPANDQ.BCST m64 zmm zmm
// 	VPANDQ.BCST m64 xmm k xmm
// 	VPANDQ.BCST m64 xmm xmm
// 	VPANDQ.BCST m64 ymm k ymm
// 	VPANDQ.BCST m64 ymm ymm
func VPANDQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPANDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPANDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDQ_BCST: bad operands")
}

// VPANDQ_BCST_Z: Bitwise Logical AND of Packed Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPANDQ.BCST.Z m64 zmm k zmm
// 	VPANDQ.BCST.Z m64 xmm k xmm
// 	VPANDQ.BCST.Z m64 ymm k ymm
func VPANDQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDQ_BCST_Z: bad operands")
}

// VPANDQ_Z: Bitwise Logical AND of Packed Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPANDQ.Z m512 zmm k zmm
// 	VPANDQ.Z zmm  zmm k zmm
// 	VPANDQ.Z m128 xmm k xmm
// 	VPANDQ.Z m256 ymm k ymm
// 	VPANDQ.Z xmm  xmm k xmm
// 	VPANDQ.Z ymm  ymm k ymm
func VPANDQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPANDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPANDQ_Z: bad operands")
}

// VPAVGB: Average Packed Byte Integers.
//
// Forms:
//
// 	VPAVGB m256 ymm ymm
// 	VPAVGB ymm  ymm ymm
// 	VPAVGB m128 xmm xmm
// 	VPAVGB xmm  xmm xmm
// 	VPAVGB m512 zmm k zmm
// 	VPAVGB m512 zmm zmm
// 	VPAVGB zmm  zmm k zmm
// 	VPAVGB zmm  zmm zmm
// 	VPAVGB m128 xmm k xmm
// 	VPAVGB m256 ymm k ymm
// 	VPAVGB xmm  xmm k xmm
// 	VPAVGB ymm  ymm k ymm
func VPAVGB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPAVGB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPAVGB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPAVGB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPAVGB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPAVGB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPAVGB: bad operands")
}

// VPAVGB_Z: Average Packed Byte Integers (Zeroing Masking).
//
// Forms:
//
// 	VPAVGB.Z m512 zmm k zmm
// 	VPAVGB.Z zmm  zmm k zmm
// 	VPAVGB.Z m128 xmm k xmm
// 	VPAVGB.Z m256 ymm k ymm
// 	VPAVGB.Z xmm  xmm k xmm
// 	VPAVGB.Z ymm  ymm k ymm
func VPAVGB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPAVGB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPAVGB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPAVGB_Z: bad operands")
}

// VPAVGW: Average Packed Word Integers.
//
// Forms:
//
// 	VPAVGW m256 ymm ymm
// 	VPAVGW ymm  ymm ymm
// 	VPAVGW m128 xmm xmm
// 	VPAVGW xmm  xmm xmm
// 	VPAVGW m512 zmm k zmm
// 	VPAVGW m512 zmm zmm
// 	VPAVGW zmm  zmm k zmm
// 	VPAVGW zmm  zmm zmm
// 	VPAVGW m128 xmm k xmm
// 	VPAVGW m256 ymm k ymm
// 	VPAVGW xmm  xmm k xmm
// 	VPAVGW ymm  ymm k ymm
func VPAVGW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPAVGW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPAVGW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPAVGW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPAVGW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPAVGW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPAVGW: bad operands")
}

// VPAVGW_Z: Average Packed Word Integers (Zeroing Masking).
//
// Forms:
//
// 	VPAVGW.Z m512 zmm k zmm
// 	VPAVGW.Z zmm  zmm k zmm
// 	VPAVGW.Z m128 xmm k xmm
// 	VPAVGW.Z m256 ymm k ymm
// 	VPAVGW.Z xmm  xmm k xmm
// 	VPAVGW.Z ymm  ymm k ymm
func VPAVGW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPAVGW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPAVGW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPAVGW_Z: bad operands")
}

// VPBLENDD: Blend Packed Doublewords.
//
// Forms:
//
// 	VPBLENDD imm8 m128 xmm xmm
// 	VPBLENDD imm8 m256 ymm ymm
// 	VPBLENDD imm8 xmm  xmm xmm
// 	VPBLENDD imm8 ymm  ymm ymm
func VPBLENDD(i, mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsIMM8(i) && operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsIMM8(i) && operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsIMM8(i) && operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDD",
			Operands: []operand.Op{i, mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPBLENDD: bad operands")
}

// VPBLENDMB: Blend Byte Vectors Using an OpMask Control.
//
// Forms:
//
// 	VPBLENDMB m512 zmm k zmm
// 	VPBLENDMB m512 zmm zmm
// 	VPBLENDMB zmm  zmm k zmm
// 	VPBLENDMB zmm  zmm zmm
// 	VPBLENDMB m128 xmm k xmm
// 	VPBLENDMB m128 xmm xmm
// 	VPBLENDMB m256 ymm k ymm
// 	VPBLENDMB m256 ymm ymm
// 	VPBLENDMB xmm  xmm k xmm
// 	VPBLENDMB xmm  xmm xmm
// 	VPBLENDMB ymm  ymm k ymm
// 	VPBLENDMB ymm  ymm ymm
func VPBLENDMB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPBLENDMB: bad operands")
}

// VPBLENDMB_Z: Blend Byte Vectors Using an OpMask Control (Zeroing Masking).
//
// Forms:
//
// 	VPBLENDMB.Z m512 zmm k zmm
// 	VPBLENDMB.Z zmm  zmm k zmm
// 	VPBLENDMB.Z m128 xmm k xmm
// 	VPBLENDMB.Z m256 ymm k ymm
// 	VPBLENDMB.Z xmm  xmm k xmm
// 	VPBLENDMB.Z ymm  ymm k ymm
func VPBLENDMB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPBLENDMB_Z: bad operands")
}

// VPBLENDMD: Blend Doubleword Vectors Using an OpMask Control.
//
// Forms:
//
// 	VPBLENDMD m512 zmm k zmm
// 	VPBLENDMD m512 zmm zmm
// 	VPBLENDMD zmm  zmm k zmm
// 	VPBLENDMD zmm  zmm zmm
// 	VPBLENDMD m128 xmm k xmm
// 	VPBLENDMD m128 xmm xmm
// 	VPBLENDMD m256 ymm k ymm
// 	VPBLENDMD m256 ymm ymm
// 	VPBLENDMD xmm  xmm k xmm
// 	VPBLENDMD xmm  xmm xmm
// 	VPBLENDMD ymm  ymm k ymm
// 	VPBLENDMD ymm  ymm ymm
func VPBLENDMD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPBLENDMD: bad operands")
}

// VPBLENDMD_BCST: Blend Doubleword Vectors Using an OpMask Control (Broadcast).
//
// Forms:
//
// 	VPBLENDMD.BCST m32 zmm k zmm
// 	VPBLENDMD.BCST m32 zmm zmm
// 	VPBLENDMD.BCST m32 xmm k xmm
// 	VPBLENDMD.BCST m32 xmm xmm
// 	VPBLENDMD.BCST m32 ymm k ymm
// 	VPBLENDMD.BCST m32 ymm ymm
func VPBLENDMD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPBLENDMD_BCST: bad operands")
}

// VPBLENDMD_BCST_Z: Blend Doubleword Vectors Using an OpMask Control (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPBLENDMD.BCST.Z m32 zmm k zmm
// 	VPBLENDMD.BCST.Z m32 xmm k xmm
// 	VPBLENDMD.BCST.Z m32 ymm k ymm
func VPBLENDMD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPBLENDMD_BCST_Z: bad operands")
}

// VPBLENDMD_Z: Blend Doubleword Vectors Using an OpMask Control (Zeroing Masking).
//
// Forms:
//
// 	VPBLENDMD.Z m512 zmm k zmm
// 	VPBLENDMD.Z zmm  zmm k zmm
// 	VPBLENDMD.Z m128 xmm k xmm
// 	VPBLENDMD.Z m256 ymm k ymm
// 	VPBLENDMD.Z xmm  xmm k xmm
// 	VPBLENDMD.Z ymm  ymm k ymm
func VPBLENDMD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPBLENDMD_Z: bad operands")
}

// VPBLENDMQ: Blend Quadword Vectors Using an OpMask Control.
//
// Forms:
//
// 	VPBLENDMQ m512 zmm k zmm
// 	VPBLENDMQ m512 zmm zmm
// 	VPBLENDMQ zmm  zmm k zmm
// 	VPBLENDMQ zmm  zmm zmm
// 	VPBLENDMQ m128 xmm k xmm
// 	VPBLENDMQ m128 xmm xmm
// 	VPBLENDMQ m256 ymm k ymm
// 	VPBLENDMQ m256 ymm ymm
// 	VPBLENDMQ xmm  xmm k xmm
// 	VPBLENDMQ xmm  xmm xmm
// 	VPBLENDMQ ymm  ymm k ymm
// 	VPBLENDMQ ymm  ymm ymm
func VPBLENDMQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPBLENDMQ: bad operands")
}

// VPBLENDMQ_BCST: Blend Quadword Vectors Using an OpMask Control (Broadcast).
//
// Forms:
//
// 	VPBLENDMQ.BCST m64 zmm k zmm
// 	VPBLENDMQ.BCST m64 zmm zmm
// 	VPBLENDMQ.BCST m64 xmm k xmm
// 	VPBLENDMQ.BCST m64 xmm xmm
// 	VPBLENDMQ.BCST m64 ymm k ymm
// 	VPBLENDMQ.BCST m64 ymm ymm
func VPBLENDMQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPBLENDMQ_BCST: bad operands")
}

// VPBLENDMQ_BCST_Z: Blend Quadword Vectors Using an OpMask Control (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPBLENDMQ.BCST.Z m64 zmm k zmm
// 	VPBLENDMQ.BCST.Z m64 xmm k xmm
// 	VPBLENDMQ.BCST.Z m64 ymm k ymm
func VPBLENDMQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPBLENDMQ_BCST_Z: bad operands")
}

// VPBLENDMQ_Z: Blend Quadword Vectors Using an OpMask Control (Zeroing Masking).
//
// Forms:
//
// 	VPBLENDMQ.Z m512 zmm k zmm
// 	VPBLENDMQ.Z zmm  zmm k zmm
// 	VPBLENDMQ.Z m128 xmm k xmm
// 	VPBLENDMQ.Z m256 ymm k ymm
// 	VPBLENDMQ.Z xmm  xmm k xmm
// 	VPBLENDMQ.Z ymm  ymm k ymm
func VPBLENDMQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPBLENDMQ_Z: bad operands")
}

// VPBLENDMW: Blend Word Vectors Using an OpMask Control.
//
// Forms:
//
// 	VPBLENDMW m512 zmm k zmm
// 	VPBLENDMW m512 zmm zmm
// 	VPBLENDMW zmm  zmm k zmm
// 	VPBLENDMW zmm  zmm zmm
// 	VPBLENDMW m128 xmm k xmm
// 	VPBLENDMW m128 xmm xmm
// 	VPBLENDMW m256 ymm k ymm
// 	VPBLENDMW m256 ymm ymm
// 	VPBLENDMW xmm  xmm k xmm
// 	VPBLENDMW xmm  xmm xmm
// 	VPBLENDMW ymm  ymm k ymm
// 	VPBLENDMW ymm  ymm ymm
func VPBLENDMW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPBLENDMW: bad operands")
}

// VPBLENDMW_Z: Blend Word Vectors Using an OpMask Control (Zeroing Masking).
//
// Forms:
//
// 	VPBLENDMW.Z m512 zmm k zmm
// 	VPBLENDMW.Z zmm  zmm k zmm
// 	VPBLENDMW.Z m128 xmm k xmm
// 	VPBLENDMW.Z m256 ymm k ymm
// 	VPBLENDMW.Z xmm  xmm k xmm
// 	VPBLENDMW.Z ymm  ymm k ymm
func VPBLENDMW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDMW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPBLENDMW_Z: bad operands")
}

// VPBLENDVB: Variable Blend Packed Bytes.
//
// Forms:
//
// 	VPBLENDVB ymm m256 ymm ymm
// 	VPBLENDVB ymm ymm  ymm ymm
// 	VPBLENDVB xmm m128 xmm xmm
// 	VPBLENDVB xmm xmm  xmm xmm
func VPBLENDVB(xy, mxy, xy1, xy2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(xy) && operand.IsM128(mxy) && operand.IsXMM(xy1) && operand.IsXMM(xy2),
		operand.IsXMM(xy) && operand.IsXMM(mxy) && operand.IsXMM(xy1) && operand.IsXMM(xy2):
		return &intrep.Instruction{
			Opcode:   "VPBLENDVB",
			Operands: []operand.Op{xy, mxy, xy1, xy2},
			Inputs:   []operand.Op{xy, mxy, xy1},
			Outputs:  []operand.Op{xy2},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsYMM(xy) && operand.IsM256(mxy) && operand.IsYMM(xy1) && operand.IsYMM(xy2),
		operand.IsYMM(xy) && operand.IsYMM(mxy) && operand.IsYMM(xy1) && operand.IsYMM(xy2):
		return &intrep.Instruction{
			Opcode:   "VPBLENDVB",
			Operands: []operand.Op{xy, mxy, xy1, xy2},
			Inputs:   []operand.Op{xy, mxy, xy1},
			Outputs:  []operand.Op{xy2},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPBLENDVB: bad operands")
}

// VPBLENDW: Blend Packed Words.
//
// Forms:
//
// 	VPBLENDW imm8 m256 ymm ymm
// 	VPBLENDW imm8 ymm  ymm ymm
// 	VPBLENDW imm8 m128 xmm xmm
// 	VPBLENDW imm8 xmm  xmm xmm
func VPBLENDW(i, mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsIMM8(i) && operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDW",
			Operands: []operand.Op{i, mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsIMM8(i) && operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPBLENDW",
			Operands: []operand.Op{i, mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPBLENDW: bad operands")
}

// VPBROADCASTB: Broadcast Byte Integer.
//
// Forms:
//
// 	VPBROADCASTB m8  xmm
// 	VPBROADCASTB m8  ymm
// 	VPBROADCASTB xmm xmm
// 	VPBROADCASTB xmm ymm
// 	VPBROADCASTB m8  k zmm
// 	VPBROADCASTB m8  zmm
// 	VPBROADCASTB r32 k zmm
// 	VPBROADCASTB r32 zmm
// 	VPBROADCASTB xmm k zmm
// 	VPBROADCASTB xmm zmm
// 	VPBROADCASTB m8  k xmm
// 	VPBROADCASTB m8  k ymm
// 	VPBROADCASTB r32 k xmm
// 	VPBROADCASTB r32 k ymm
// 	VPBROADCASTB r32 xmm
// 	VPBROADCASTB r32 ymm
// 	VPBROADCASTB xmm k xmm
// 	VPBROADCASTB xmm k ymm
func VPBROADCASTB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM8(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsR32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM8(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM8(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsR32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsR32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsM8(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM8(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM8(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsR32(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsR32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsR32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPBROADCASTB: bad operands")
}

// VPBROADCASTB_Z: Broadcast Byte Integer (Zeroing Masking).
//
// Forms:
//
// 	VPBROADCASTB.Z m8  k zmm
// 	VPBROADCASTB.Z r32 k zmm
// 	VPBROADCASTB.Z xmm k zmm
// 	VPBROADCASTB.Z m8  k xmm
// 	VPBROADCASTB.Z m8  k ymm
// 	VPBROADCASTB.Z r32 k xmm
// 	VPBROADCASTB.Z r32 k ymm
// 	VPBROADCASTB.Z xmm k xmm
// 	VPBROADCASTB.Z xmm k ymm
func VPBROADCASTB_Z(mrx, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mrx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsR32(mrx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(mrx) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mrx, k, xyz},
			Inputs:   []operand.Op{mrx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM8(mrx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM8(mrx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsR32(mrx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsR32(mrx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mrx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mrx) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mrx, k, xyz},
			Inputs:   []operand.Op{mrx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPBROADCASTB_Z: bad operands")
}

// VPBROADCASTD: Broadcast Doubleword Integer.
//
// Forms:
//
// 	VPBROADCASTD m32 xmm
// 	VPBROADCASTD m32 ymm
// 	VPBROADCASTD xmm xmm
// 	VPBROADCASTD xmm ymm
// 	VPBROADCASTD m32 k zmm
// 	VPBROADCASTD m32 zmm
// 	VPBROADCASTD r32 k zmm
// 	VPBROADCASTD r32 zmm
// 	VPBROADCASTD xmm k zmm
// 	VPBROADCASTD xmm zmm
// 	VPBROADCASTD m32 k xmm
// 	VPBROADCASTD m32 k ymm
// 	VPBROADCASTD r32 k xmm
// 	VPBROADCASTD r32 k ymm
// 	VPBROADCASTD r32 xmm
// 	VPBROADCASTD r32 ymm
// 	VPBROADCASTD xmm k xmm
// 	VPBROADCASTD xmm k ymm
func VPBROADCASTD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsR32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsR32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsR32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsR32(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsR32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsR32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPBROADCASTD: bad operands")
}

// VPBROADCASTD_Z: Broadcast Doubleword Integer (Zeroing Masking).
//
// Forms:
//
// 	VPBROADCASTD.Z m32 k zmm
// 	VPBROADCASTD.Z r32 k zmm
// 	VPBROADCASTD.Z xmm k zmm
// 	VPBROADCASTD.Z m32 k xmm
// 	VPBROADCASTD.Z m32 k ymm
// 	VPBROADCASTD.Z r32 k xmm
// 	VPBROADCASTD.Z r32 k ymm
// 	VPBROADCASTD.Z xmm k xmm
// 	VPBROADCASTD.Z xmm k ymm
func VPBROADCASTD_Z(mrx, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mrx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsR32(mrx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(mrx) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mrx, k, xyz},
			Inputs:   []operand.Op{mrx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(mrx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(mrx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsR32(mrx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsR32(mrx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mrx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mrx) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mrx, k, xyz},
			Inputs:   []operand.Op{mrx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPBROADCASTD_Z: bad operands")
}

// VPBROADCASTMB2Q: Broadcast Low Byte of Mask Register to Packed Quadword Values.
//
// Forms:
//
// 	VPBROADCASTMB2Q k zmm
// 	VPBROADCASTMB2Q k xmm
// 	VPBROADCASTMB2Q k ymm
func VPBROADCASTMB2Q(k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTMB2Q",
			Operands: []operand.Op{k, xyz},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512CD"},
		}, nil
	case operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTMB2Q",
			Operands: []operand.Op{k, xyz},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPBROADCASTMB2Q: bad operands")
}

// VPBROADCASTMW2D: Broadcast Low Word of Mask Register to Packed Doubleword Values.
//
// Forms:
//
// 	VPBROADCASTMW2D k zmm
// 	VPBROADCASTMW2D k xmm
// 	VPBROADCASTMW2D k ymm
func VPBROADCASTMW2D(k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTMW2D",
			Operands: []operand.Op{k, xyz},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512CD"},
		}, nil
	case operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTMW2D",
			Operands: []operand.Op{k, xyz},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPBROADCASTMW2D: bad operands")
}

// VPBROADCASTQ: Broadcast Quadword Integer.
//
// Forms:
//
// 	VPBROADCASTQ m64 xmm
// 	VPBROADCASTQ m64 ymm
// 	VPBROADCASTQ xmm xmm
// 	VPBROADCASTQ xmm ymm
// 	VPBROADCASTQ m64 k zmm
// 	VPBROADCASTQ m64 zmm
// 	VPBROADCASTQ r64 k zmm
// 	VPBROADCASTQ r64 zmm
// 	VPBROADCASTQ xmm k zmm
// 	VPBROADCASTQ xmm zmm
// 	VPBROADCASTQ m64 k xmm
// 	VPBROADCASTQ m64 k ymm
// 	VPBROADCASTQ r64 k xmm
// 	VPBROADCASTQ r64 k ymm
// 	VPBROADCASTQ r64 xmm
// 	VPBROADCASTQ r64 ymm
// 	VPBROADCASTQ xmm k xmm
// 	VPBROADCASTQ xmm k ymm
func VPBROADCASTQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsR64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsR64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsR64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsR64(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsR64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsR64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPBROADCASTQ: bad operands")
}

// VPBROADCASTQ_Z: Broadcast Quadword Integer (Zeroing Masking).
//
// Forms:
//
// 	VPBROADCASTQ.Z m64 k zmm
// 	VPBROADCASTQ.Z r64 k zmm
// 	VPBROADCASTQ.Z xmm k zmm
// 	VPBROADCASTQ.Z m64 k xmm
// 	VPBROADCASTQ.Z m64 k ymm
// 	VPBROADCASTQ.Z r64 k xmm
// 	VPBROADCASTQ.Z r64 k ymm
// 	VPBROADCASTQ.Z xmm k xmm
// 	VPBROADCASTQ.Z xmm k ymm
func VPBROADCASTQ_Z(mrx, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mrx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsR64(mrx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(mrx) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mrx, k, xyz},
			Inputs:   []operand.Op{mrx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(mrx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(mrx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsR64(mrx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsR64(mrx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mrx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mrx) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mrx, k, xyz},
			Inputs:   []operand.Op{mrx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPBROADCASTQ_Z: bad operands")
}

// VPBROADCASTW: Broadcast Word Integer.
//
// Forms:
//
// 	VPBROADCASTW m16 xmm
// 	VPBROADCASTW m16 ymm
// 	VPBROADCASTW xmm xmm
// 	VPBROADCASTW xmm ymm
// 	VPBROADCASTW m16 k zmm
// 	VPBROADCASTW m16 zmm
// 	VPBROADCASTW r32 k zmm
// 	VPBROADCASTW r32 zmm
// 	VPBROADCASTW xmm k zmm
// 	VPBROADCASTW xmm zmm
// 	VPBROADCASTW m16 k xmm
// 	VPBROADCASTW m16 k ymm
// 	VPBROADCASTW r32 k xmm
// 	VPBROADCASTW r32 k ymm
// 	VPBROADCASTW r32 xmm
// 	VPBROADCASTW r32 ymm
// 	VPBROADCASTW xmm k xmm
// 	VPBROADCASTW xmm k ymm
func VPBROADCASTW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM16(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsR32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM16(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM16(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsR32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsR32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsM16(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM16(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM16(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsR32(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsR32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsR32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPBROADCASTW: bad operands")
}

// VPBROADCASTW_Z: Broadcast Word Integer (Zeroing Masking).
//
// Forms:
//
// 	VPBROADCASTW.Z m16 k zmm
// 	VPBROADCASTW.Z r32 k zmm
// 	VPBROADCASTW.Z xmm k zmm
// 	VPBROADCASTW.Z m16 k xmm
// 	VPBROADCASTW.Z m16 k ymm
// 	VPBROADCASTW.Z r32 k xmm
// 	VPBROADCASTW.Z r32 k ymm
// 	VPBROADCASTW.Z xmm k xmm
// 	VPBROADCASTW.Z xmm k ymm
func VPBROADCASTW_Z(mrx, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM16(mrx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsR32(mrx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(mrx) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mrx, k, xyz},
			Inputs:   []operand.Op{mrx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM16(mrx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM16(mrx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsR32(mrx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsR32(mrx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mrx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mrx) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPBROADCASTW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mrx, k, xyz},
			Inputs:   []operand.Op{mrx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPBROADCASTW_Z: bad operands")
}

// VPCLMULQDQ: Carry-Less Quadword Multiplication.
//
// Forms:
//
// 	VPCLMULQDQ imm8 m128 xmm xmm
// 	VPCLMULQDQ imm8 xmm  xmm xmm
func VPCLMULQDQ(i, mx, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VPCLMULQDQ",
			Operands: []operand.Op{i, mx, x, x1},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX", "PCLMULQDQ"},
		}, nil
	}
	return nil, errors.New("VPCLMULQDQ: bad operands")
}

// VPCMPB: Compare Packed Signed Byte Values.
//
// Forms:
//
// 	VPCMPB imm8 m512 zmm k k
// 	VPCMPB imm8 m512 zmm k
// 	VPCMPB imm8 zmm  zmm k k
// 	VPCMPB imm8 zmm  zmm k
// 	VPCMPB imm8 m128 xmm k k
// 	VPCMPB imm8 m128 xmm k
// 	VPCMPB imm8 m256 ymm k k
// 	VPCMPB imm8 m256 ymm k
// 	VPCMPB imm8 xmm  xmm k k
// 	VPCMPB imm8 xmm  xmm k
// 	VPCMPB imm8 ymm  ymm k k
// 	VPCMPB imm8 ymm  ymm k
func VPCMPB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPB",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPB",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPB",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPB",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPCMPB: bad operands")
}

// VPCMPD: Compare Packed Signed Doubleword Values.
//
// Forms:
//
// 	VPCMPD imm8 m512 zmm k k
// 	VPCMPD imm8 m512 zmm k
// 	VPCMPD imm8 zmm  zmm k k
// 	VPCMPD imm8 zmm  zmm k
// 	VPCMPD imm8 m128 xmm k k
// 	VPCMPD imm8 m128 xmm k
// 	VPCMPD imm8 m256 ymm k k
// 	VPCMPD imm8 m256 ymm k
// 	VPCMPD imm8 xmm  xmm k k
// 	VPCMPD imm8 xmm  xmm k
// 	VPCMPD imm8 ymm  ymm k k
// 	VPCMPD imm8 ymm  ymm k
func VPCMPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPD: bad operands")
}

// VPCMPD_BCST: Compare Packed Signed Doubleword Values (Broadcast).
//
// Forms:
//
// 	VPCMPD.BCST imm8 m32 zmm k k
// 	VPCMPD.BCST imm8 m32 zmm k
// 	VPCMPD.BCST imm8 m32 xmm k k
// 	VPCMPD.BCST imm8 m32 xmm k
// 	VPCMPD.BCST imm8 m32 ymm k k
// 	VPCMPD.BCST imm8 m32 ymm k
func VPCMPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPD_BCST: bad operands")
}

// VPCMPEQB: Compare Packed Byte Data for Equality.
//
// Forms:
//
// 	VPCMPEQB m256 ymm ymm
// 	VPCMPEQB ymm  ymm ymm
// 	VPCMPEQB m128 xmm xmm
// 	VPCMPEQB xmm  xmm xmm
// 	VPCMPEQB m512 zmm k k
// 	VPCMPEQB m512 zmm k
// 	VPCMPEQB zmm  zmm k k
// 	VPCMPEQB zmm  zmm k
// 	VPCMPEQB m128 xmm k k
// 	VPCMPEQB m128 xmm k
// 	VPCMPEQB m256 ymm k k
// 	VPCMPEQB m256 ymm k
// 	VPCMPEQB xmm  xmm k k
// 	VPCMPEQB xmm  xmm k
// 	VPCMPEQB ymm  ymm k k
// 	VPCMPEQB ymm  ymm k
func VPCMPEQB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPCMPEQB: bad operands")
}

// VPCMPEQD: Compare Packed Doubleword Data for Equality.
//
// Forms:
//
// 	VPCMPEQD m256 ymm ymm
// 	VPCMPEQD ymm  ymm ymm
// 	VPCMPEQD m128 xmm xmm
// 	VPCMPEQD xmm  xmm xmm
// 	VPCMPEQD m512 zmm k k
// 	VPCMPEQD m512 zmm k
// 	VPCMPEQD zmm  zmm k k
// 	VPCMPEQD zmm  zmm k
// 	VPCMPEQD m128 xmm k k
// 	VPCMPEQD m128 xmm k
// 	VPCMPEQD m256 ymm k k
// 	VPCMPEQD m256 ymm k
// 	VPCMPEQD xmm  xmm k k
// 	VPCMPEQD xmm  xmm k
// 	VPCMPEQD ymm  ymm k k
// 	VPCMPEQD ymm  ymm k
func VPCMPEQD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512VL", "AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPEQD: bad operands")
}

// VPCMPEQD_BCST: Compare Packed Doubleword Data for Equality (Broadcast).
//
// Forms:
//
// 	VPCMPEQD.BCST m32 zmm k k
// 	VPCMPEQD.BCST m32 zmm k
// 	VPCMPEQD.BCST m32 xmm k k
// 	VPCMPEQD.BCST m32 xmm k
// 	VPCMPEQD.BCST m32 ymm k k
// 	VPCMPEQD.BCST m32 ymm k
func VPCMPEQD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPEQD_BCST: bad operands")
}

// VPCMPEQQ: Compare Packed Quadword Data for Equality.
//
// Forms:
//
// 	VPCMPEQQ m256 ymm ymm
// 	VPCMPEQQ ymm  ymm ymm
// 	VPCMPEQQ m128 xmm xmm
// 	VPCMPEQQ xmm  xmm xmm
// 	VPCMPEQQ m512 zmm k k
// 	VPCMPEQQ m512 zmm k
// 	VPCMPEQQ zmm  zmm k k
// 	VPCMPEQQ zmm  zmm k
// 	VPCMPEQQ m128 xmm k k
// 	VPCMPEQQ m128 xmm k
// 	VPCMPEQQ m256 ymm k k
// 	VPCMPEQQ m256 ymm k
// 	VPCMPEQQ xmm  xmm k k
// 	VPCMPEQQ xmm  xmm k
// 	VPCMPEQQ ymm  ymm k k
// 	VPCMPEQQ ymm  ymm k
func VPCMPEQQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512VL", "AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPEQQ: bad operands")
}

// VPCMPEQQ_BCST: Compare Packed Quadword Data for Equality (Broadcast).
//
// Forms:
//
// 	VPCMPEQQ.BCST m64 zmm k k
// 	VPCMPEQQ.BCST m64 zmm k
// 	VPCMPEQQ.BCST m64 xmm k k
// 	VPCMPEQQ.BCST m64 xmm k
// 	VPCMPEQQ.BCST m64 ymm k k
// 	VPCMPEQQ.BCST m64 ymm k
func VPCMPEQQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPEQQ_BCST: bad operands")
}

// VPCMPEQW: Compare Packed Word Data for Equality.
//
// Forms:
//
// 	VPCMPEQW m256 ymm ymm
// 	VPCMPEQW ymm  ymm ymm
// 	VPCMPEQW m128 xmm xmm
// 	VPCMPEQW xmm  xmm xmm
// 	VPCMPEQW m512 zmm k k
// 	VPCMPEQW m512 zmm k
// 	VPCMPEQW zmm  zmm k k
// 	VPCMPEQW zmm  zmm k
// 	VPCMPEQW m128 xmm k k
// 	VPCMPEQW m128 xmm k
// 	VPCMPEQW m256 ymm k k
// 	VPCMPEQW m256 ymm k
// 	VPCMPEQW xmm  xmm k k
// 	VPCMPEQW xmm  xmm k
// 	VPCMPEQW ymm  ymm k k
// 	VPCMPEQW ymm  ymm k
func VPCMPEQW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPEQW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPEQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPCMPEQW: bad operands")
}

// VPCMPESTRI: Packed Compare Explicit Length Strings, Return Index.
//
// Forms:
//
// 	VPCMPESTRI imm8 m128 xmm
// 	VPCMPESTRI imm8 xmm  xmm
func VPCMPESTRI(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VPCMPESTRI",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x, reg.EAX, reg.EDX},
			Outputs:  []operand.Op{reg.ECX},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPCMPESTRI: bad operands")
}

// VPCMPESTRM: Packed Compare Explicit Length Strings, Return Mask.
//
// Forms:
//
// 	VPCMPESTRM imm8 m128 xmm
// 	VPCMPESTRM imm8 xmm  xmm
func VPCMPESTRM(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VPCMPESTRM",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x, reg.EAX, reg.EDX},
			Outputs:  []operand.Op{reg.X0},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPCMPESTRM: bad operands")
}

// VPCMPGTB: Compare Packed Signed Byte Integers for Greater Than.
//
// Forms:
//
// 	VPCMPGTB m256 ymm ymm
// 	VPCMPGTB ymm  ymm ymm
// 	VPCMPGTB m128 xmm xmm
// 	VPCMPGTB xmm  xmm xmm
// 	VPCMPGTB m512 zmm k k
// 	VPCMPGTB m512 zmm k
// 	VPCMPGTB zmm  zmm k k
// 	VPCMPGTB zmm  zmm k
// 	VPCMPGTB m128 xmm k k
// 	VPCMPGTB m128 xmm k
// 	VPCMPGTB m256 ymm k k
// 	VPCMPGTB m256 ymm k
// 	VPCMPGTB xmm  xmm k k
// 	VPCMPGTB xmm  xmm k
// 	VPCMPGTB ymm  ymm k k
// 	VPCMPGTB ymm  ymm k
func VPCMPGTB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPCMPGTB: bad operands")
}

// VPCMPGTD: Compare Packed Signed Doubleword Integers for Greater Than.
//
// Forms:
//
// 	VPCMPGTD m256 ymm ymm
// 	VPCMPGTD ymm  ymm ymm
// 	VPCMPGTD m128 xmm xmm
// 	VPCMPGTD xmm  xmm xmm
// 	VPCMPGTD m512 zmm k k
// 	VPCMPGTD m512 zmm k
// 	VPCMPGTD zmm  zmm k k
// 	VPCMPGTD zmm  zmm k
// 	VPCMPGTD m128 xmm k k
// 	VPCMPGTD m128 xmm k
// 	VPCMPGTD m256 ymm k k
// 	VPCMPGTD m256 ymm k
// 	VPCMPGTD xmm  xmm k k
// 	VPCMPGTD xmm  xmm k
// 	VPCMPGTD ymm  ymm k k
// 	VPCMPGTD ymm  ymm k
func VPCMPGTD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512VL", "AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPGTD: bad operands")
}

// VPCMPGTD_BCST: Compare Packed Signed Doubleword Integers for Greater Than (Broadcast).
//
// Forms:
//
// 	VPCMPGTD.BCST m32 zmm k k
// 	VPCMPGTD.BCST m32 zmm k
// 	VPCMPGTD.BCST m32 xmm k k
// 	VPCMPGTD.BCST m32 xmm k
// 	VPCMPGTD.BCST m32 ymm k k
// 	VPCMPGTD.BCST m32 ymm k
func VPCMPGTD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPGTD_BCST: bad operands")
}

// VPCMPGTQ: Compare Packed Data for Greater Than.
//
// Forms:
//
// 	VPCMPGTQ m256 ymm ymm
// 	VPCMPGTQ ymm  ymm ymm
// 	VPCMPGTQ m128 xmm xmm
// 	VPCMPGTQ xmm  xmm xmm
// 	VPCMPGTQ m512 zmm k k
// 	VPCMPGTQ m512 zmm k
// 	VPCMPGTQ zmm  zmm k k
// 	VPCMPGTQ zmm  zmm k
// 	VPCMPGTQ m128 xmm k k
// 	VPCMPGTQ m128 xmm k
// 	VPCMPGTQ m256 ymm k k
// 	VPCMPGTQ m256 ymm k
// 	VPCMPGTQ xmm  xmm k k
// 	VPCMPGTQ xmm  xmm k
// 	VPCMPGTQ ymm  ymm k k
// 	VPCMPGTQ ymm  ymm k
func VPCMPGTQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512VL", "AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPGTQ: bad operands")
}

// VPCMPGTQ_BCST: Compare Packed Data for Greater Than (Broadcast).
//
// Forms:
//
// 	VPCMPGTQ.BCST m64 zmm k k
// 	VPCMPGTQ.BCST m64 zmm k
// 	VPCMPGTQ.BCST m64 xmm k k
// 	VPCMPGTQ.BCST m64 xmm k
// 	VPCMPGTQ.BCST m64 ymm k k
// 	VPCMPGTQ.BCST m64 ymm k
func VPCMPGTQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPGTQ_BCST: bad operands")
}

// VPCMPGTW: Compare Packed Signed Word Integers for Greater Than.
//
// Forms:
//
// 	VPCMPGTW m256 ymm ymm
// 	VPCMPGTW ymm  ymm ymm
// 	VPCMPGTW m128 xmm xmm
// 	VPCMPGTW xmm  xmm xmm
// 	VPCMPGTW m512 zmm k k
// 	VPCMPGTW m512 zmm k
// 	VPCMPGTW zmm  zmm k k
// 	VPCMPGTW zmm  zmm k
// 	VPCMPGTW m128 xmm k k
// 	VPCMPGTW m128 xmm k
// 	VPCMPGTW m256 ymm k k
// 	VPCMPGTW m256 ymm k
// 	VPCMPGTW xmm  xmm k k
// 	VPCMPGTW xmm  xmm k
// 	VPCMPGTW ymm  ymm k k
// 	VPCMPGTW ymm  ymm k
func VPCMPGTW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPCMPGTW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCMPGTW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPCMPGTW: bad operands")
}

// VPCMPISTRI: Packed Compare Implicit Length Strings, Return Index.
//
// Forms:
//
// 	VPCMPISTRI imm8 m128 xmm
// 	VPCMPISTRI imm8 xmm  xmm
func VPCMPISTRI(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VPCMPISTRI",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{reg.ECX},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPCMPISTRI: bad operands")
}

// VPCMPISTRM: Packed Compare Implicit Length Strings, Return Mask.
//
// Forms:
//
// 	VPCMPISTRM imm8 m128 xmm
// 	VPCMPISTRM imm8 xmm  xmm
func VPCMPISTRM(i, mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VPCMPISTRM",
			Operands: []operand.Op{i, mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{reg.X0},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPCMPISTRM: bad operands")
}

// VPCMPQ: Compare Packed Signed Quadword Values.
//
// Forms:
//
// 	VPCMPQ imm8 m512 zmm k k
// 	VPCMPQ imm8 m512 zmm k
// 	VPCMPQ imm8 zmm  zmm k k
// 	VPCMPQ imm8 zmm  zmm k
// 	VPCMPQ imm8 m128 xmm k k
// 	VPCMPQ imm8 m128 xmm k
// 	VPCMPQ imm8 m256 ymm k k
// 	VPCMPQ imm8 m256 ymm k
// 	VPCMPQ imm8 xmm  xmm k k
// 	VPCMPQ imm8 xmm  xmm k
// 	VPCMPQ imm8 ymm  ymm k k
// 	VPCMPQ imm8 ymm  ymm k
func VPCMPQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPQ: bad operands")
}

// VPCMPQ_BCST: Compare Packed Signed Quadword Values (Broadcast).
//
// Forms:
//
// 	VPCMPQ.BCST imm8 m64 zmm k k
// 	VPCMPQ.BCST imm8 m64 zmm k
// 	VPCMPQ.BCST imm8 m64 xmm k k
// 	VPCMPQ.BCST imm8 m64 xmm k
// 	VPCMPQ.BCST imm8 m64 ymm k k
// 	VPCMPQ.BCST imm8 m64 ymm k
func VPCMPQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPQ_BCST: bad operands")
}

// VPCMPUB: Compare Packed Unsigned Byte Values.
//
// Forms:
//
// 	VPCMPUB imm8 m512 zmm k k
// 	VPCMPUB imm8 m512 zmm k
// 	VPCMPUB imm8 zmm  zmm k k
// 	VPCMPUB imm8 zmm  zmm k
// 	VPCMPUB imm8 m128 xmm k k
// 	VPCMPUB imm8 m128 xmm k
// 	VPCMPUB imm8 m256 ymm k k
// 	VPCMPUB imm8 m256 ymm k
// 	VPCMPUB imm8 xmm  xmm k k
// 	VPCMPUB imm8 xmm  xmm k
// 	VPCMPUB imm8 ymm  ymm k k
// 	VPCMPUB imm8 ymm  ymm k
func VPCMPUB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUB",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUB",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUB",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUB",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPCMPUB: bad operands")
}

// VPCMPUD: Compare Packed Unsigned Doubleword Values.
//
// Forms:
//
// 	VPCMPUD imm8 m512 zmm k k
// 	VPCMPUD imm8 m512 zmm k
// 	VPCMPUD imm8 zmm  zmm k k
// 	VPCMPUD imm8 zmm  zmm k
// 	VPCMPUD imm8 m128 xmm k k
// 	VPCMPUD imm8 m128 xmm k
// 	VPCMPUD imm8 m256 ymm k k
// 	VPCMPUD imm8 m256 ymm k
// 	VPCMPUD imm8 xmm  xmm k k
// 	VPCMPUD imm8 xmm  xmm k
// 	VPCMPUD imm8 ymm  ymm k k
// 	VPCMPUD imm8 ymm  ymm k
func VPCMPUD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPUD: bad operands")
}

// VPCMPUD_BCST: Compare Packed Unsigned Doubleword Values (Broadcast).
//
// Forms:
//
// 	VPCMPUD.BCST imm8 m32 zmm k k
// 	VPCMPUD.BCST imm8 m32 zmm k
// 	VPCMPUD.BCST imm8 m32 xmm k k
// 	VPCMPUD.BCST imm8 m32 xmm k
// 	VPCMPUD.BCST imm8 m32 ymm k k
// 	VPCMPUD.BCST imm8 m32 ymm k
func VPCMPUD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPUD_BCST: bad operands")
}

// VPCMPUQ: Compare Packed Unsigned Quadword Values.
//
// Forms:
//
// 	VPCMPUQ imm8 m512 zmm k k
// 	VPCMPUQ imm8 m512 zmm k
// 	VPCMPUQ imm8 zmm  zmm k k
// 	VPCMPUQ imm8 zmm  zmm k
// 	VPCMPUQ imm8 m128 xmm k k
// 	VPCMPUQ imm8 m128 xmm k
// 	VPCMPUQ imm8 m256 ymm k k
// 	VPCMPUQ imm8 m256 ymm k
// 	VPCMPUQ imm8 xmm  xmm k k
// 	VPCMPUQ imm8 xmm  xmm k
// 	VPCMPUQ imm8 ymm  ymm k k
// 	VPCMPUQ imm8 ymm  ymm k
func VPCMPUQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPUQ: bad operands")
}

// VPCMPUQ_BCST: Compare Packed Unsigned Quadword Values (Broadcast).
//
// Forms:
//
// 	VPCMPUQ.BCST imm8 m64 zmm k k
// 	VPCMPUQ.BCST imm8 m64 zmm k
// 	VPCMPUQ.BCST imm8 m64 xmm k k
// 	VPCMPUQ.BCST imm8 m64 xmm k
// 	VPCMPUQ.BCST imm8 m64 ymm k k
// 	VPCMPUQ.BCST imm8 m64 ymm k
func VPCMPUQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCMPUQ_BCST: bad operands")
}

// VPCMPUW: Compare Packed Unsigned Word Values.
//
// Forms:
//
// 	VPCMPUW imm8 m512 zmm k k
// 	VPCMPUW imm8 m512 zmm k
// 	VPCMPUW imm8 zmm  zmm k k
// 	VPCMPUW imm8 zmm  zmm k
// 	VPCMPUW imm8 m128 xmm k k
// 	VPCMPUW imm8 m128 xmm k
// 	VPCMPUW imm8 m256 ymm k k
// 	VPCMPUW imm8 m256 ymm k
// 	VPCMPUW imm8 xmm  xmm k k
// 	VPCMPUW imm8 xmm  xmm k
// 	VPCMPUW imm8 ymm  ymm k k
// 	VPCMPUW imm8 ymm  ymm k
func VPCMPUW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPCMPUW: bad operands")
}

// VPCMPW: Compare Packed Signed Word Values.
//
// Forms:
//
// 	VPCMPW imm8 m512 zmm k k
// 	VPCMPW imm8 m512 zmm k
// 	VPCMPW imm8 zmm  zmm k k
// 	VPCMPW imm8 zmm  zmm k
// 	VPCMPW imm8 m128 xmm k k
// 	VPCMPW imm8 m128 xmm k
// 	VPCMPW imm8 m256 ymm k k
// 	VPCMPW imm8 m256 ymm k
// 	VPCMPW imm8 xmm  xmm k k
// 	VPCMPW imm8 xmm  xmm k
// 	VPCMPW imm8 ymm  ymm k k
// 	VPCMPW imm8 ymm  ymm k
func VPCMPW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsK(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPCMPW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPCMPW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPCMPW: bad operands")
}

// VPCOMPRESSD: Store Sparse Packed Doubleword Integer Values into Dense Memory/Register.
//
// Forms:
//
// 	VPCOMPRESSD zmm k m512
// 	VPCOMPRESSD zmm k zmm
// 	VPCOMPRESSD zmm m512
// 	VPCOMPRESSD zmm zmm
// 	VPCOMPRESSD xmm k m128
// 	VPCOMPRESSD xmm k xmm
// 	VPCOMPRESSD xmm m128
// 	VPCOMPRESSD xmm xmm
// 	VPCOMPRESSD ymm k m256
// 	VPCOMPRESSD ymm k ymm
// 	VPCOMPRESSD ymm m256
// 	VPCOMPRESSD ymm ymm
func VPCOMPRESSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM512(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCOMPRESSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCOMPRESSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM512(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPCOMPRESSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPCOMPRESSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCOMPRESSD: bad operands")
}

// VPCOMPRESSD_Z: Store Sparse Packed Doubleword Integer Values into Dense Memory/Register (Zeroing Masking).
//
// Forms:
//
// 	VPCOMPRESSD.Z zmm k m512
// 	VPCOMPRESSD.Z zmm k zmm
// 	VPCOMPRESSD.Z xmm k m128
// 	VPCOMPRESSD.Z xmm k xmm
// 	VPCOMPRESSD.Z ymm k m256
// 	VPCOMPRESSD.Z ymm k ymm
func VPCOMPRESSD_Z(xyz, k, mxyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM512(mxyz),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(mxyz):
		return &intrep.Instruction{
			Opcode:   "VPCOMPRESSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxyz},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM128(mxyz),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mxyz),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM256(mxyz),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(mxyz):
		return &intrep.Instruction{
			Opcode:   "VPCOMPRESSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxyz},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCOMPRESSD_Z: bad operands")
}

// VPCOMPRESSQ: Store Sparse Packed Quadword Integer Values into Dense Memory/Register.
//
// Forms:
//
// 	VPCOMPRESSQ zmm k m512
// 	VPCOMPRESSQ zmm k zmm
// 	VPCOMPRESSQ zmm m512
// 	VPCOMPRESSQ zmm zmm
// 	VPCOMPRESSQ xmm k m128
// 	VPCOMPRESSQ xmm k xmm
// 	VPCOMPRESSQ xmm m128
// 	VPCOMPRESSQ xmm xmm
// 	VPCOMPRESSQ ymm k m256
// 	VPCOMPRESSQ ymm k ymm
// 	VPCOMPRESSQ ymm m256
// 	VPCOMPRESSQ ymm ymm
func VPCOMPRESSQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM512(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCOMPRESSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCOMPRESSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM512(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPCOMPRESSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPCOMPRESSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCOMPRESSQ: bad operands")
}

// VPCOMPRESSQ_Z: Store Sparse Packed Quadword Integer Values into Dense Memory/Register (Zeroing Masking).
//
// Forms:
//
// 	VPCOMPRESSQ.Z zmm k m512
// 	VPCOMPRESSQ.Z zmm k zmm
// 	VPCOMPRESSQ.Z xmm k m128
// 	VPCOMPRESSQ.Z xmm k xmm
// 	VPCOMPRESSQ.Z ymm k m256
// 	VPCOMPRESSQ.Z ymm k ymm
func VPCOMPRESSQ_Z(xyz, k, mxyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM512(mxyz),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(mxyz):
		return &intrep.Instruction{
			Opcode:   "VPCOMPRESSQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxyz},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM128(mxyz),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mxyz),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM256(mxyz),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(mxyz):
		return &intrep.Instruction{
			Opcode:   "VPCOMPRESSQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxyz},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPCOMPRESSQ_Z: bad operands")
}

// VPCONFLICTD: Detect Conflicts Within a Vector of Packed Doubleword Values into Dense Memory/Register.
//
// Forms:
//
// 	VPCONFLICTD m512 k zmm
// 	VPCONFLICTD m512 zmm
// 	VPCONFLICTD zmm  k zmm
// 	VPCONFLICTD zmm  zmm
// 	VPCONFLICTD m128 k xmm
// 	VPCONFLICTD m128 xmm
// 	VPCONFLICTD m256 k ymm
// 	VPCONFLICTD m256 ymm
// 	VPCONFLICTD xmm  k xmm
// 	VPCONFLICTD xmm  xmm
// 	VPCONFLICTD ymm  k ymm
// 	VPCONFLICTD ymm  ymm
func VPCONFLICTD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPCONFLICTD: bad operands")
}

// VPCONFLICTD_BCST: Detect Conflicts Within a Vector of Packed Doubleword Values into Dense Memory/Register (Broadcast).
//
// Forms:
//
// 	VPCONFLICTD.BCST m32 k zmm
// 	VPCONFLICTD.BCST m32 zmm
// 	VPCONFLICTD.BCST m32 k xmm
// 	VPCONFLICTD.BCST m32 k ymm
// 	VPCONFLICTD.BCST m32 xmm
// 	VPCONFLICTD.BCST m32 ymm
func VPCONFLICTD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPCONFLICTD_BCST: bad operands")
}

// VPCONFLICTD_BCST_Z: Detect Conflicts Within a Vector of Packed Doubleword Values into Dense Memory/Register (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPCONFLICTD.BCST.Z m32 k zmm
// 	VPCONFLICTD.BCST.Z m32 k xmm
// 	VPCONFLICTD.BCST.Z m32 k ymm
func VPCONFLICTD_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512CD"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPCONFLICTD_BCST_Z: bad operands")
}

// VPCONFLICTD_Z: Detect Conflicts Within a Vector of Packed Doubleword Values into Dense Memory/Register (Zeroing Masking).
//
// Forms:
//
// 	VPCONFLICTD.Z m512 k zmm
// 	VPCONFLICTD.Z zmm  k zmm
// 	VPCONFLICTD.Z m128 k xmm
// 	VPCONFLICTD.Z m256 k ymm
// 	VPCONFLICTD.Z xmm  k xmm
// 	VPCONFLICTD.Z ymm  k ymm
func VPCONFLICTD_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512CD"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPCONFLICTD_Z: bad operands")
}

// VPCONFLICTQ: Detect Conflicts Within a Vector of Packed Quadword Values into Dense Memory/Register.
//
// Forms:
//
// 	VPCONFLICTQ m512 k zmm
// 	VPCONFLICTQ m512 zmm
// 	VPCONFLICTQ zmm  k zmm
// 	VPCONFLICTQ zmm  zmm
// 	VPCONFLICTQ m128 k xmm
// 	VPCONFLICTQ m128 xmm
// 	VPCONFLICTQ m256 k ymm
// 	VPCONFLICTQ m256 ymm
// 	VPCONFLICTQ xmm  k xmm
// 	VPCONFLICTQ xmm  xmm
// 	VPCONFLICTQ ymm  k ymm
// 	VPCONFLICTQ ymm  ymm
func VPCONFLICTQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPCONFLICTQ: bad operands")
}

// VPCONFLICTQ_BCST: Detect Conflicts Within a Vector of Packed Quadword Values into Dense Memory/Register (Broadcast).
//
// Forms:
//
// 	VPCONFLICTQ.BCST m64 k zmm
// 	VPCONFLICTQ.BCST m64 zmm
// 	VPCONFLICTQ.BCST m64 k xmm
// 	VPCONFLICTQ.BCST m64 k ymm
// 	VPCONFLICTQ.BCST m64 xmm
// 	VPCONFLICTQ.BCST m64 ymm
func VPCONFLICTQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPCONFLICTQ_BCST: bad operands")
}

// VPCONFLICTQ_BCST_Z: Detect Conflicts Within a Vector of Packed Quadword Values into Dense Memory/Register (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPCONFLICTQ.BCST.Z m64 k zmm
// 	VPCONFLICTQ.BCST.Z m64 k xmm
// 	VPCONFLICTQ.BCST.Z m64 k ymm
func VPCONFLICTQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512CD"},
		}, nil
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPCONFLICTQ_BCST_Z: bad operands")
}

// VPCONFLICTQ_Z: Detect Conflicts Within a Vector of Packed Quadword Values into Dense Memory/Register (Zeroing Masking).
//
// Forms:
//
// 	VPCONFLICTQ.Z m512 k zmm
// 	VPCONFLICTQ.Z zmm  k zmm
// 	VPCONFLICTQ.Z m128 k xmm
// 	VPCONFLICTQ.Z m256 k ymm
// 	VPCONFLICTQ.Z xmm  k xmm
// 	VPCONFLICTQ.Z ymm  k ymm
func VPCONFLICTQ_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512CD"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPCONFLICTQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPCONFLICTQ_Z: bad operands")
}

// VPERM2F128: Permute Floating-Point Values.
//
// Forms:
//
// 	VPERM2F128 imm8 m256 ymm ymm
// 	VPERM2F128 imm8 ymm  ymm ymm
func VPERM2F128(i, my, y, y1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM256(my) && operand.IsYMM(y) && operand.IsYMM(y1),
		operand.IsIMM8(i) && operand.IsYMM(my) && operand.IsYMM(y) && operand.IsYMM(y1):
		return &intrep.Instruction{
			Opcode:   "VPERM2F128",
			Operands: []operand.Op{i, my, y, y1},
			Inputs:   []operand.Op{my, y},
			Outputs:  []operand.Op{y1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPERM2F128: bad operands")
}

// VPERM2I128: Permute 128-Bit Integer Values.
//
// Forms:
//
// 	VPERM2I128 imm8 m256 ymm ymm
// 	VPERM2I128 imm8 ymm  ymm ymm
func VPERM2I128(i, my, y, y1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM256(my) && operand.IsYMM(y) && operand.IsYMM(y1),
		operand.IsIMM8(i) && operand.IsYMM(my) && operand.IsYMM(y) && operand.IsYMM(y1):
		return &intrep.Instruction{
			Opcode:   "VPERM2I128",
			Operands: []operand.Op{i, my, y, y1},
			Inputs:   []operand.Op{my, y},
			Outputs:  []operand.Op{y1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPERM2I128: bad operands")
}

// VPERMB: Permute Byte Integers.
//
// Forms:
//
// 	VPERMB m512 zmm k zmm
// 	VPERMB m512 zmm zmm
// 	VPERMB zmm  zmm k zmm
// 	VPERMB zmm  zmm zmm
// 	VPERMB m128 xmm k xmm
// 	VPERMB m128 xmm xmm
// 	VPERMB m256 ymm k ymm
// 	VPERMB m256 ymm ymm
// 	VPERMB xmm  xmm k xmm
// 	VPERMB xmm  xmm xmm
// 	VPERMB ymm  ymm k ymm
// 	VPERMB ymm  ymm ymm
func VPERMB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512VBMI"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512VBMI"},
		}, nil
	}
	return nil, errors.New("VPERMB: bad operands")
}

// VPERMB_Z: Permute Byte Integers (Zeroing Masking).
//
// Forms:
//
// 	VPERMB.Z m512 zmm k zmm
// 	VPERMB.Z zmm  zmm k zmm
// 	VPERMB.Z m128 xmm k xmm
// 	VPERMB.Z m256 ymm k ymm
// 	VPERMB.Z xmm  xmm k xmm
// 	VPERMB.Z ymm  ymm k ymm
func VPERMB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512VBMI"},
		}, nil
	}
	return nil, errors.New("VPERMB_Z: bad operands")
}

// VPERMD: Permute Doubleword Integers.
//
// Forms:
//
// 	VPERMD m256 ymm ymm
// 	VPERMD ymm  ymm ymm
// 	VPERMD m512 zmm k zmm
// 	VPERMD m512 zmm zmm
// 	VPERMD zmm  zmm k zmm
// 	VPERMD zmm  zmm zmm
// 	VPERMD m256 ymm k ymm
// 	VPERMD ymm  ymm k ymm
func VPERMD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMD: bad operands")
}

// VPERMD_BCST: Permute Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VPERMD.BCST m32 zmm k zmm
// 	VPERMD.BCST m32 zmm zmm
// 	VPERMD.BCST m32 ymm k ymm
// 	VPERMD.BCST m32 ymm ymm
func VPERMD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMD_BCST: bad operands")
}

// VPERMD_BCST_Z: Permute Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPERMD.BCST.Z m32 zmm k zmm
// 	VPERMD.BCST.Z m32 ymm k ymm
func VPERMD_BCST_Z(m, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VPERMD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, yz, k, yz1},
			Inputs:   []operand.Op{m, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VPERMD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, yz, k, yz1},
			Inputs:   []operand.Op{m, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMD_BCST_Z: bad operands")
}

// VPERMD_Z: Permute Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPERMD.Z m512 zmm k zmm
// 	VPERMD.Z zmm  zmm k zmm
// 	VPERMD.Z m256 ymm k ymm
// 	VPERMD.Z ymm  ymm k ymm
func VPERMD_Z(myz, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(myz) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1),
		operand.IsZMM(myz) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VPERMD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{myz, yz, k, yz1},
			Inputs:   []operand.Op{myz, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM256(myz) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1),
		operand.IsYMM(myz) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VPERMD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{myz, yz, k, yz1},
			Inputs:   []operand.Op{myz, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMD_Z: bad operands")
}

// VPERMI2B: Full Permute of Bytes From Two Tables Overwriting the Index.
//
// Forms:
//
// 	VPERMI2B m512 zmm k zmm
// 	VPERMI2B m512 zmm zmm
// 	VPERMI2B zmm  zmm k zmm
// 	VPERMI2B zmm  zmm zmm
// 	VPERMI2B m128 xmm k xmm
// 	VPERMI2B m128 xmm xmm
// 	VPERMI2B m256 ymm k ymm
// 	VPERMI2B m256 ymm ymm
// 	VPERMI2B xmm  xmm k xmm
// 	VPERMI2B xmm  xmm xmm
// 	VPERMI2B ymm  ymm k ymm
// 	VPERMI2B ymm  ymm ymm
func VPERMI2B(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2B",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2B",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512VBMI"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2B",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2B",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512VBMI"},
		}, nil
	}
	return nil, errors.New("VPERMI2B: bad operands")
}

// VPERMI2B_Z: Full Permute of Bytes From Two Tables Overwriting the Index (Zeroing Masking).
//
// Forms:
//
// 	VPERMI2B.Z m512 zmm k zmm
// 	VPERMI2B.Z zmm  zmm k zmm
// 	VPERMI2B.Z m128 xmm k xmm
// 	VPERMI2B.Z m256 ymm k ymm
// 	VPERMI2B.Z xmm  xmm k xmm
// 	VPERMI2B.Z ymm  ymm k ymm
func VPERMI2B_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2B",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2B",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512VBMI"},
		}, nil
	}
	return nil, errors.New("VPERMI2B_Z: bad operands")
}

// VPERMI2D: Full Permute of Doublewords From Two Tables Overwriting the Index.
//
// Forms:
//
// 	VPERMI2D m512 zmm k zmm
// 	VPERMI2D m512 zmm zmm
// 	VPERMI2D zmm  zmm k zmm
// 	VPERMI2D zmm  zmm zmm
// 	VPERMI2D m128 xmm k xmm
// 	VPERMI2D m128 xmm xmm
// 	VPERMI2D m256 ymm k ymm
// 	VPERMI2D m256 ymm ymm
// 	VPERMI2D xmm  xmm k xmm
// 	VPERMI2D xmm  xmm xmm
// 	VPERMI2D ymm  ymm k ymm
// 	VPERMI2D ymm  ymm ymm
func VPERMI2D(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2D",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2D",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2D",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2D",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2D: bad operands")
}

// VPERMI2D_BCST: Full Permute of Doublewords From Two Tables Overwriting the Index (Broadcast).
//
// Forms:
//
// 	VPERMI2D.BCST m32 zmm k zmm
// 	VPERMI2D.BCST m32 zmm zmm
// 	VPERMI2D.BCST m32 xmm k xmm
// 	VPERMI2D.BCST m32 xmm xmm
// 	VPERMI2D.BCST m32 ymm k ymm
// 	VPERMI2D.BCST m32 ymm ymm
func VPERMI2D_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2D",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2D",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2D",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2D",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2D_BCST: bad operands")
}

// VPERMI2D_BCST_Z: Full Permute of Doublewords From Two Tables Overwriting the Index (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPERMI2D.BCST.Z m32 zmm k zmm
// 	VPERMI2D.BCST.Z m32 xmm k xmm
// 	VPERMI2D.BCST.Z m32 ymm k ymm
func VPERMI2D_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2D",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2D",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2D_BCST_Z: bad operands")
}

// VPERMI2D_Z: Full Permute of Doublewords From Two Tables Overwriting the Index (Zeroing Masking).
//
// Forms:
//
// 	VPERMI2D.Z m512 zmm k zmm
// 	VPERMI2D.Z zmm  zmm k zmm
// 	VPERMI2D.Z m128 xmm k xmm
// 	VPERMI2D.Z m256 ymm k ymm
// 	VPERMI2D.Z xmm  xmm k xmm
// 	VPERMI2D.Z ymm  ymm k ymm
func VPERMI2D_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2D",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2D",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2D_Z: bad operands")
}

// VPERMI2PD: Full Permute of Double-Precision Floating-Point Values From Two Tables Overwriting the Index.
//
// Forms:
//
// 	VPERMI2PD m512 zmm k zmm
// 	VPERMI2PD m512 zmm zmm
// 	VPERMI2PD zmm  zmm k zmm
// 	VPERMI2PD zmm  zmm zmm
// 	VPERMI2PD m128 xmm k xmm
// 	VPERMI2PD m128 xmm xmm
// 	VPERMI2PD m256 ymm k ymm
// 	VPERMI2PD m256 ymm ymm
// 	VPERMI2PD xmm  xmm k xmm
// 	VPERMI2PD xmm  xmm xmm
// 	VPERMI2PD ymm  ymm k ymm
// 	VPERMI2PD ymm  ymm ymm
func VPERMI2PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2PD: bad operands")
}

// VPERMI2PD_BCST: Full Permute of Double-Precision Floating-Point Values From Two Tables Overwriting the Index (Broadcast).
//
// Forms:
//
// 	VPERMI2PD.BCST m64 zmm k zmm
// 	VPERMI2PD.BCST m64 zmm zmm
// 	VPERMI2PD.BCST m64 xmm k xmm
// 	VPERMI2PD.BCST m64 xmm xmm
// 	VPERMI2PD.BCST m64 ymm k ymm
// 	VPERMI2PD.BCST m64 ymm ymm
func VPERMI2PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2PD_BCST: bad operands")
}

// VPERMI2PD_BCST_Z: Full Permute of Double-Precision Floating-Point Values From Two Tables Overwriting the Index (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPERMI2PD.BCST.Z m64 zmm k zmm
// 	VPERMI2PD.BCST.Z m64 xmm k xmm
// 	VPERMI2PD.BCST.Z m64 ymm k ymm
func VPERMI2PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2PD_BCST_Z: bad operands")
}

// VPERMI2PD_Z: Full Permute of Double-Precision Floating-Point Values From Two Tables Overwriting the Index (Zeroing Masking).
//
// Forms:
//
// 	VPERMI2PD.Z m512 zmm k zmm
// 	VPERMI2PD.Z zmm  zmm k zmm
// 	VPERMI2PD.Z m128 xmm k xmm
// 	VPERMI2PD.Z m256 ymm k ymm
// 	VPERMI2PD.Z xmm  xmm k xmm
// 	VPERMI2PD.Z ymm  ymm k ymm
func VPERMI2PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2PD_Z: bad operands")
}

// VPERMI2PS: Full Permute of Single-Precision Floating-Point Values From Two Tables Overwriting the Index.
//
// Forms:
//
// 	VPERMI2PS m512 zmm k zmm
// 	VPERMI2PS m512 zmm zmm
// 	VPERMI2PS zmm  zmm k zmm
// 	VPERMI2PS zmm  zmm zmm
// 	VPERMI2PS m128 xmm k xmm
// 	VPERMI2PS m128 xmm xmm
// 	VPERMI2PS m256 ymm k ymm
// 	VPERMI2PS m256 ymm ymm
// 	VPERMI2PS xmm  xmm k xmm
// 	VPERMI2PS xmm  xmm xmm
// 	VPERMI2PS ymm  ymm k ymm
// 	VPERMI2PS ymm  ymm ymm
func VPERMI2PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2PS: bad operands")
}

// VPERMI2PS_BCST: Full Permute of Single-Precision Floating-Point Values From Two Tables Overwriting the Index (Broadcast).
//
// Forms:
//
// 	VPERMI2PS.BCST m32 zmm k zmm
// 	VPERMI2PS.BCST m32 zmm zmm
// 	VPERMI2PS.BCST m32 xmm k xmm
// 	VPERMI2PS.BCST m32 xmm xmm
// 	VPERMI2PS.BCST m32 ymm k ymm
// 	VPERMI2PS.BCST m32 ymm ymm
func VPERMI2PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2PS_BCST: bad operands")
}

// VPERMI2PS_BCST_Z: Full Permute of Single-Precision Floating-Point Values From Two Tables Overwriting the Index (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPERMI2PS.BCST.Z m32 zmm k zmm
// 	VPERMI2PS.BCST.Z m32 xmm k xmm
// 	VPERMI2PS.BCST.Z m32 ymm k ymm
func VPERMI2PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2PS_BCST_Z: bad operands")
}

// VPERMI2PS_Z: Full Permute of Single-Precision Floating-Point Values From Two Tables Overwriting the Index (Zeroing Masking).
//
// Forms:
//
// 	VPERMI2PS.Z m512 zmm k zmm
// 	VPERMI2PS.Z zmm  zmm k zmm
// 	VPERMI2PS.Z m128 xmm k xmm
// 	VPERMI2PS.Z m256 ymm k ymm
// 	VPERMI2PS.Z xmm  xmm k xmm
// 	VPERMI2PS.Z ymm  ymm k ymm
func VPERMI2PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2PS_Z: bad operands")
}

// VPERMI2Q: Full Permute of Quadwords From Two Tables Overwriting the Index.
//
// Forms:
//
// 	VPERMI2Q m512 zmm k zmm
// 	VPERMI2Q m512 zmm zmm
// 	VPERMI2Q zmm  zmm k zmm
// 	VPERMI2Q zmm  zmm zmm
// 	VPERMI2Q m128 xmm k xmm
// 	VPERMI2Q m128 xmm xmm
// 	VPERMI2Q m256 ymm k ymm
// 	VPERMI2Q m256 ymm ymm
// 	VPERMI2Q xmm  xmm k xmm
// 	VPERMI2Q xmm  xmm xmm
// 	VPERMI2Q ymm  ymm k ymm
// 	VPERMI2Q ymm  ymm ymm
func VPERMI2Q(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2Q",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2Q",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2Q",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2Q",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2Q: bad operands")
}

// VPERMI2Q_BCST: Full Permute of Quadwords From Two Tables Overwriting the Index (Broadcast).
//
// Forms:
//
// 	VPERMI2Q.BCST m64 zmm k zmm
// 	VPERMI2Q.BCST m64 zmm zmm
// 	VPERMI2Q.BCST m64 xmm k xmm
// 	VPERMI2Q.BCST m64 xmm xmm
// 	VPERMI2Q.BCST m64 ymm k ymm
// 	VPERMI2Q.BCST m64 ymm ymm
func VPERMI2Q_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2Q",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2Q",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2Q",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2Q",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2Q_BCST: bad operands")
}

// VPERMI2Q_BCST_Z: Full Permute of Quadwords From Two Tables Overwriting the Index (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPERMI2Q.BCST.Z m64 zmm k zmm
// 	VPERMI2Q.BCST.Z m64 xmm k xmm
// 	VPERMI2Q.BCST.Z m64 ymm k ymm
func VPERMI2Q_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2Q",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2Q",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2Q_BCST_Z: bad operands")
}

// VPERMI2Q_Z: Full Permute of Quadwords From Two Tables Overwriting the Index (Zeroing Masking).
//
// Forms:
//
// 	VPERMI2Q.Z m512 zmm k zmm
// 	VPERMI2Q.Z zmm  zmm k zmm
// 	VPERMI2Q.Z m128 xmm k xmm
// 	VPERMI2Q.Z m256 ymm k ymm
// 	VPERMI2Q.Z xmm  xmm k xmm
// 	VPERMI2Q.Z ymm  ymm k ymm
func VPERMI2Q_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2Q",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2Q",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMI2Q_Z: bad operands")
}

// VPERMI2W: Full Permute of Words From Two Tables Overwriting the Index.
//
// Forms:
//
// 	VPERMI2W m512 zmm k zmm
// 	VPERMI2W m512 zmm zmm
// 	VPERMI2W zmm  zmm k zmm
// 	VPERMI2W zmm  zmm zmm
// 	VPERMI2W m128 xmm k xmm
// 	VPERMI2W m128 xmm xmm
// 	VPERMI2W m256 ymm k ymm
// 	VPERMI2W m256 ymm ymm
// 	VPERMI2W xmm  xmm k xmm
// 	VPERMI2W xmm  xmm xmm
// 	VPERMI2W ymm  ymm k ymm
// 	VPERMI2W ymm  ymm ymm
func VPERMI2W(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2W",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2W",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2W",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMI2W",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPERMI2W: bad operands")
}

// VPERMI2W_Z: Full Permute of Words From Two Tables Overwriting the Index (Zeroing Masking).
//
// Forms:
//
// 	VPERMI2W.Z m512 zmm k zmm
// 	VPERMI2W.Z zmm  zmm k zmm
// 	VPERMI2W.Z m128 xmm k xmm
// 	VPERMI2W.Z m256 ymm k ymm
// 	VPERMI2W.Z xmm  xmm k xmm
// 	VPERMI2W.Z ymm  ymm k ymm
func VPERMI2W_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2W",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMI2W",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPERMI2W_Z: bad operands")
}

// VPERMILPD: Permute Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VPERMILPD imm8 m128 xmm
// 	VPERMILPD imm8 m256 ymm
// 	VPERMILPD imm8 xmm  xmm
// 	VPERMILPD imm8 ymm  ymm
// 	VPERMILPD m128 xmm  xmm
// 	VPERMILPD m256 ymm  ymm
// 	VPERMILPD xmm  xmm  xmm
// 	VPERMILPD ymm  ymm  ymm
// 	VPERMILPD imm8 m512 k zmm
// 	VPERMILPD imm8 m512 zmm
// 	VPERMILPD imm8 zmm  k zmm
// 	VPERMILPD imm8 zmm  zmm
// 	VPERMILPD m512 zmm  k zmm
// 	VPERMILPD m512 zmm  zmm
// 	VPERMILPD zmm  zmm  k zmm
// 	VPERMILPD zmm  zmm  zmm
// 	VPERMILPD imm8 m128 k xmm
// 	VPERMILPD imm8 m256 k ymm
// 	VPERMILPD imm8 xmm  k xmm
// 	VPERMILPD imm8 ymm  k ymm
// 	VPERMILPD m128 xmm  k xmm
// 	VPERMILPD m256 ymm  k ymm
// 	VPERMILPD xmm  xmm  k xmm
// 	VPERMILPD ymm  ymm  k ymm
func VPERMILPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMILPD: bad operands")
}

// VPERMILPD_BCST: Permute Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VPERMILPD.BCST imm8 m64 k zmm
// 	VPERMILPD.BCST imm8 m64 zmm
// 	VPERMILPD.BCST m64  zmm k zmm
// 	VPERMILPD.BCST m64  zmm zmm
// 	VPERMILPD.BCST imm8 m64 k xmm
// 	VPERMILPD.BCST imm8 m64 k ymm
// 	VPERMILPD.BCST imm8 m64 xmm
// 	VPERMILPD.BCST imm8 m64 ymm
// 	VPERMILPD.BCST m64  xmm k xmm
// 	VPERMILPD.BCST m64  xmm xmm
// 	VPERMILPD.BCST m64  ymm k ymm
// 	VPERMILPD.BCST m64  ymm ymm
func VPERMILPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMILPD_BCST: bad operands")
}

// VPERMILPD_BCST_Z: Permute Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPERMILPD.BCST.Z imm8 m64 k zmm
// 	VPERMILPD.BCST.Z m64  zmm k zmm
// 	VPERMILPD.BCST.Z imm8 m64 k xmm
// 	VPERMILPD.BCST.Z imm8 m64 k ymm
// 	VPERMILPD.BCST.Z m64  xmm k xmm
// 	VPERMILPD.BCST.Z m64  ymm k ymm
func VPERMILPD_BCST_Z(im, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(im) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, mxyz, k, xyz},
			Inputs:   []operand.Op{im, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(im) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(im) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, mxyz, k, xyz},
			Inputs:   []operand.Op{im, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(im) && operand.IsM64(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(im) && operand.IsM64(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(im) && operand.IsM64(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMILPD_BCST_Z: bad operands")
}

// VPERMILPD_Z: Permute Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VPERMILPD.Z imm8 m512 k zmm
// 	VPERMILPD.Z imm8 zmm  k zmm
// 	VPERMILPD.Z m512 zmm  k zmm
// 	VPERMILPD.Z zmm  zmm  k zmm
// 	VPERMILPD.Z imm8 m128 k xmm
// 	VPERMILPD.Z imm8 m256 k ymm
// 	VPERMILPD.Z imm8 xmm  k xmm
// 	VPERMILPD.Z imm8 ymm  k ymm
// 	VPERMILPD.Z m128 xmm  k xmm
// 	VPERMILPD.Z m256 ymm  k ymm
// 	VPERMILPD.Z xmm  xmm  k xmm
// 	VPERMILPD.Z ymm  ymm  k ymm
func VPERMILPD_Z(imxyz, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(imxyz) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(imxyz) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imxyz, mxyz, k, xyz},
			Inputs:   []operand.Op{imxyz, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(imxyz) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(imxyz) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(imxyz) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(imxyz) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imxyz, mxyz, k, xyz},
			Inputs:   []operand.Op{imxyz, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(imxyz) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(imxyz) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imxyz, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(imxyz) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imxyz) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(imxyz) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imxyz) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imxyz, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMILPD_Z: bad operands")
}

// VPERMILPS: Permute Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VPERMILPS imm8 m128 xmm
// 	VPERMILPS imm8 m256 ymm
// 	VPERMILPS imm8 xmm  xmm
// 	VPERMILPS imm8 ymm  ymm
// 	VPERMILPS m128 xmm  xmm
// 	VPERMILPS m256 ymm  ymm
// 	VPERMILPS xmm  xmm  xmm
// 	VPERMILPS ymm  ymm  ymm
// 	VPERMILPS imm8 m512 k zmm
// 	VPERMILPS imm8 m512 zmm
// 	VPERMILPS imm8 zmm  k zmm
// 	VPERMILPS imm8 zmm  zmm
// 	VPERMILPS m512 zmm  k zmm
// 	VPERMILPS m512 zmm  zmm
// 	VPERMILPS zmm  zmm  k zmm
// 	VPERMILPS zmm  zmm  zmm
// 	VPERMILPS imm8 m128 k xmm
// 	VPERMILPS imm8 m256 k ymm
// 	VPERMILPS imm8 xmm  k xmm
// 	VPERMILPS imm8 ymm  k ymm
// 	VPERMILPS m128 xmm  k xmm
// 	VPERMILPS m256 ymm  k ymm
// 	VPERMILPS xmm  xmm  k xmm
// 	VPERMILPS ymm  ymm  k ymm
func VPERMILPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMILPS: bad operands")
}

// VPERMILPS_BCST: Permute Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VPERMILPS.BCST imm8 m32 k zmm
// 	VPERMILPS.BCST imm8 m32 zmm
// 	VPERMILPS.BCST m32  zmm k zmm
// 	VPERMILPS.BCST m32  zmm zmm
// 	VPERMILPS.BCST imm8 m32 k xmm
// 	VPERMILPS.BCST imm8 m32 k ymm
// 	VPERMILPS.BCST imm8 m32 xmm
// 	VPERMILPS.BCST imm8 m32 ymm
// 	VPERMILPS.BCST m32  xmm k xmm
// 	VPERMILPS.BCST m32  xmm xmm
// 	VPERMILPS.BCST m32  ymm k ymm
// 	VPERMILPS.BCST m32  ymm ymm
func VPERMILPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMILPS_BCST: bad operands")
}

// VPERMILPS_BCST_Z: Permute Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPERMILPS.BCST.Z imm8 m32 k zmm
// 	VPERMILPS.BCST.Z m32  zmm k zmm
// 	VPERMILPS.BCST.Z imm8 m32 k xmm
// 	VPERMILPS.BCST.Z imm8 m32 k ymm
// 	VPERMILPS.BCST.Z m32  xmm k xmm
// 	VPERMILPS.BCST.Z m32  ymm k ymm
func VPERMILPS_BCST_Z(im, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(im) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, mxyz, k, xyz},
			Inputs:   []operand.Op{im, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(im) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(im) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, mxyz, k, xyz},
			Inputs:   []operand.Op{im, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(im) && operand.IsM32(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(im) && operand.IsM32(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(im) && operand.IsM32(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMILPS_BCST_Z: bad operands")
}

// VPERMILPS_Z: Permute Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VPERMILPS.Z imm8 m512 k zmm
// 	VPERMILPS.Z imm8 zmm  k zmm
// 	VPERMILPS.Z m512 zmm  k zmm
// 	VPERMILPS.Z zmm  zmm  k zmm
// 	VPERMILPS.Z imm8 m128 k xmm
// 	VPERMILPS.Z imm8 m256 k ymm
// 	VPERMILPS.Z imm8 xmm  k xmm
// 	VPERMILPS.Z imm8 ymm  k ymm
// 	VPERMILPS.Z m128 xmm  k xmm
// 	VPERMILPS.Z m256 ymm  k ymm
// 	VPERMILPS.Z xmm  xmm  k xmm
// 	VPERMILPS.Z ymm  ymm  k ymm
func VPERMILPS_Z(imxyz, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(imxyz) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(imxyz) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imxyz, mxyz, k, xyz},
			Inputs:   []operand.Op{imxyz, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(imxyz) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(imxyz) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(imxyz) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(imxyz) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imxyz, mxyz, k, xyz},
			Inputs:   []operand.Op{imxyz, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(imxyz) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(imxyz) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imxyz, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(imxyz) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imxyz) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(imxyz) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imxyz) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPERMILPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imxyz, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMILPS_Z: bad operands")
}

// VPERMPD: Permute Double-Precision Floating-Point Elements.
//
// Forms:
//
// 	VPERMPD imm8 m256 ymm
// 	VPERMPD imm8 ymm  ymm
// 	VPERMPD imm8 m512 k zmm
// 	VPERMPD imm8 m512 zmm
// 	VPERMPD imm8 zmm  k zmm
// 	VPERMPD imm8 zmm  zmm
// 	VPERMPD m512 zmm  k zmm
// 	VPERMPD m512 zmm  zmm
// 	VPERMPD zmm  zmm  k zmm
// 	VPERMPD zmm  zmm  zmm
// 	VPERMPD imm8 m256 k ymm
// 	VPERMPD imm8 ymm  k ymm
// 	VPERMPD m256 ymm  k ymm
// 	VPERMPD m256 ymm  ymm
// 	VPERMPD ymm  ymm  k ymm
// 	VPERMPD ymm  ymm  ymm
func VPERMPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMPD: bad operands")
}

// VPERMPD_BCST: Permute Double-Precision Floating-Point Elements (Broadcast).
//
// Forms:
//
// 	VPERMPD.BCST imm8 m64 k zmm
// 	VPERMPD.BCST imm8 m64 zmm
// 	VPERMPD.BCST m64  zmm k zmm
// 	VPERMPD.BCST m64  zmm zmm
// 	VPERMPD.BCST imm8 m64 k ymm
// 	VPERMPD.BCST imm8 m64 ymm
// 	VPERMPD.BCST m64  ymm k ymm
// 	VPERMPD.BCST m64  ymm ymm
func VPERMPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMPD_BCST: bad operands")
}

// VPERMPD_BCST_Z: Permute Double-Precision Floating-Point Elements (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPERMPD.BCST.Z imm8 m64 k zmm
// 	VPERMPD.BCST.Z m64  zmm k zmm
// 	VPERMPD.BCST.Z imm8 m64 k ymm
// 	VPERMPD.BCST.Z m64  ymm k ymm
func VPERMPD_BCST_Z(im, myz, k, yz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(im) && operand.IsZMM(myz) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, myz, k, yz},
			Inputs:   []operand.Op{im, myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(im) && operand.IsYMM(myz) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, myz, k, yz},
			Inputs:   []operand.Op{im, myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(im) && operand.IsM64(myz) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, myz, k, yz},
			Inputs:   []operand.Op{myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(im) && operand.IsM64(myz) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, myz, k, yz},
			Inputs:   []operand.Op{myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMPD_BCST_Z: bad operands")
}

// VPERMPD_Z: Permute Double-Precision Floating-Point Elements (Zeroing Masking).
//
// Forms:
//
// 	VPERMPD.Z imm8 m512 k zmm
// 	VPERMPD.Z imm8 zmm  k zmm
// 	VPERMPD.Z m512 zmm  k zmm
// 	VPERMPD.Z zmm  zmm  k zmm
// 	VPERMPD.Z imm8 m256 k ymm
// 	VPERMPD.Z imm8 ymm  k ymm
// 	VPERMPD.Z m256 ymm  k ymm
// 	VPERMPD.Z ymm  ymm  k ymm
func VPERMPD_Z(imyz, myz, k, yz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(imyz) && operand.IsZMM(myz) && operand.IsK(k) && operand.IsZMM(yz),
		operand.IsZMM(imyz) && operand.IsZMM(myz) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imyz, myz, k, yz},
			Inputs:   []operand.Op{imyz, myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM256(imyz) && operand.IsYMM(myz) && operand.IsK(k) && operand.IsYMM(yz),
		operand.IsYMM(imyz) && operand.IsYMM(myz) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imyz, myz, k, yz},
			Inputs:   []operand.Op{imyz, myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(imyz) && operand.IsM512(myz) && operand.IsK(k) && operand.IsZMM(yz),
		operand.IsIMM8(imyz) && operand.IsZMM(myz) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imyz, myz, k, yz},
			Inputs:   []operand.Op{myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(imyz) && operand.IsM256(myz) && operand.IsK(k) && operand.IsYMM(yz),
		operand.IsIMM8(imyz) && operand.IsYMM(myz) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imyz, myz, k, yz},
			Inputs:   []operand.Op{myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMPD_Z: bad operands")
}

// VPERMPS: Permute Single-Precision Floating-Point Elements.
//
// Forms:
//
// 	VPERMPS m256 ymm ymm
// 	VPERMPS ymm  ymm ymm
// 	VPERMPS m512 zmm k zmm
// 	VPERMPS m512 zmm zmm
// 	VPERMPS zmm  zmm k zmm
// 	VPERMPS zmm  zmm zmm
// 	VPERMPS m256 ymm k ymm
// 	VPERMPS ymm  ymm k ymm
func VPERMPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMPS: bad operands")
}

// VPERMPS_BCST: Permute Single-Precision Floating-Point Elements (Broadcast).
//
// Forms:
//
// 	VPERMPS.BCST m32 zmm k zmm
// 	VPERMPS.BCST m32 zmm zmm
// 	VPERMPS.BCST m32 ymm k ymm
// 	VPERMPS.BCST m32 ymm ymm
func VPERMPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMPS_BCST: bad operands")
}

// VPERMPS_BCST_Z: Permute Single-Precision Floating-Point Elements (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPERMPS.BCST.Z m32 zmm k zmm
// 	VPERMPS.BCST.Z m32 ymm k ymm
func VPERMPS_BCST_Z(m, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VPERMPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, yz, k, yz1},
			Inputs:   []operand.Op{m, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VPERMPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, yz, k, yz1},
			Inputs:   []operand.Op{m, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMPS_BCST_Z: bad operands")
}

// VPERMPS_Z: Permute Single-Precision Floating-Point Elements (Zeroing Masking).
//
// Forms:
//
// 	VPERMPS.Z m512 zmm k zmm
// 	VPERMPS.Z zmm  zmm k zmm
// 	VPERMPS.Z m256 ymm k ymm
// 	VPERMPS.Z ymm  ymm k ymm
func VPERMPS_Z(myz, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(myz) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1),
		operand.IsZMM(myz) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VPERMPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{myz, yz, k, yz1},
			Inputs:   []operand.Op{myz, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM256(myz) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1),
		operand.IsYMM(myz) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VPERMPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{myz, yz, k, yz1},
			Inputs:   []operand.Op{myz, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMPS_Z: bad operands")
}

// VPERMQ: Permute Quadword Integers.
//
// Forms:
//
// 	VPERMQ imm8 m256 ymm
// 	VPERMQ imm8 ymm  ymm
// 	VPERMQ imm8 m512 k zmm
// 	VPERMQ imm8 m512 zmm
// 	VPERMQ imm8 zmm  k zmm
// 	VPERMQ imm8 zmm  zmm
// 	VPERMQ m512 zmm  k zmm
// 	VPERMQ m512 zmm  zmm
// 	VPERMQ zmm  zmm  k zmm
// 	VPERMQ zmm  zmm  zmm
// 	VPERMQ imm8 m256 k ymm
// 	VPERMQ imm8 ymm  k ymm
// 	VPERMQ m256 ymm  k ymm
// 	VPERMQ m256 ymm  ymm
// 	VPERMQ ymm  ymm  k ymm
// 	VPERMQ ymm  ymm  ymm
func VPERMQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMQ: bad operands")
}

// VPERMQ_BCST: Permute Quadword Integers (Broadcast).
//
// Forms:
//
// 	VPERMQ.BCST imm8 m64 k zmm
// 	VPERMQ.BCST imm8 m64 zmm
// 	VPERMQ.BCST m64  zmm k zmm
// 	VPERMQ.BCST m64  zmm zmm
// 	VPERMQ.BCST imm8 m64 k ymm
// 	VPERMQ.BCST imm8 m64 ymm
// 	VPERMQ.BCST m64  ymm k ymm
// 	VPERMQ.BCST m64  ymm ymm
func VPERMQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMQ_BCST: bad operands")
}

// VPERMQ_BCST_Z: Permute Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPERMQ.BCST.Z imm8 m64 k zmm
// 	VPERMQ.BCST.Z m64  zmm k zmm
// 	VPERMQ.BCST.Z imm8 m64 k ymm
// 	VPERMQ.BCST.Z m64  ymm k ymm
func VPERMQ_BCST_Z(im, myz, k, yz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(im) && operand.IsZMM(myz) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, myz, k, yz},
			Inputs:   []operand.Op{im, myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(im) && operand.IsYMM(myz) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, myz, k, yz},
			Inputs:   []operand.Op{im, myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(im) && operand.IsM64(myz) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, myz, k, yz},
			Inputs:   []operand.Op{myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(im) && operand.IsM64(myz) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{im, myz, k, yz},
			Inputs:   []operand.Op{myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMQ_BCST_Z: bad operands")
}

// VPERMQ_Z: Permute Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPERMQ.Z imm8 m512 k zmm
// 	VPERMQ.Z imm8 zmm  k zmm
// 	VPERMQ.Z m512 zmm  k zmm
// 	VPERMQ.Z zmm  zmm  k zmm
// 	VPERMQ.Z imm8 m256 k ymm
// 	VPERMQ.Z imm8 ymm  k ymm
// 	VPERMQ.Z m256 ymm  k ymm
// 	VPERMQ.Z ymm  ymm  k ymm
func VPERMQ_Z(imyz, myz, k, yz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(imyz) && operand.IsZMM(myz) && operand.IsK(k) && operand.IsZMM(yz),
		operand.IsZMM(imyz) && operand.IsZMM(myz) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imyz, myz, k, yz},
			Inputs:   []operand.Op{imyz, myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM256(imyz) && operand.IsYMM(myz) && operand.IsK(k) && operand.IsYMM(yz),
		operand.IsYMM(imyz) && operand.IsYMM(myz) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imyz, myz, k, yz},
			Inputs:   []operand.Op{imyz, myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(imyz) && operand.IsM512(myz) && operand.IsK(k) && operand.IsZMM(yz),
		operand.IsIMM8(imyz) && operand.IsZMM(myz) && operand.IsK(k) && operand.IsZMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imyz, myz, k, yz},
			Inputs:   []operand.Op{myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(imyz) && operand.IsM256(myz) && operand.IsK(k) && operand.IsYMM(yz),
		operand.IsIMM8(imyz) && operand.IsYMM(myz) && operand.IsK(k) && operand.IsYMM(yz):
		return &intrep.Instruction{
			Opcode:   "VPERMQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imyz, myz, k, yz},
			Inputs:   []operand.Op{myz, k},
			Outputs:  []operand.Op{yz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMQ_Z: bad operands")
}

// VPERMT2B: Full Permute of Bytes From Two Tables Overwriting a Table.
//
// Forms:
//
// 	VPERMT2B m512 zmm k zmm
// 	VPERMT2B m512 zmm zmm
// 	VPERMT2B zmm  zmm k zmm
// 	VPERMT2B zmm  zmm zmm
// 	VPERMT2B m128 xmm k xmm
// 	VPERMT2B m128 xmm xmm
// 	VPERMT2B m256 ymm k ymm
// 	VPERMT2B m256 ymm ymm
// 	VPERMT2B xmm  xmm k xmm
// 	VPERMT2B xmm  xmm xmm
// 	VPERMT2B ymm  ymm k ymm
// 	VPERMT2B ymm  ymm ymm
func VPERMT2B(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2B",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2B",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512VBMI"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2B",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2B",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512VBMI"},
		}, nil
	}
	return nil, errors.New("VPERMT2B: bad operands")
}

// VPERMT2B_Z: Full Permute of Bytes From Two Tables Overwriting a Table (Zeroing Masking).
//
// Forms:
//
// 	VPERMT2B.Z m512 zmm k zmm
// 	VPERMT2B.Z zmm  zmm k zmm
// 	VPERMT2B.Z m128 xmm k xmm
// 	VPERMT2B.Z m256 ymm k ymm
// 	VPERMT2B.Z xmm  xmm k xmm
// 	VPERMT2B.Z ymm  ymm k ymm
func VPERMT2B_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2B",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2B",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512VBMI"},
		}, nil
	}
	return nil, errors.New("VPERMT2B_Z: bad operands")
}

// VPERMT2D: Full Permute of Doublewords From Two Tables Overwriting a Table.
//
// Forms:
//
// 	VPERMT2D m512 zmm k zmm
// 	VPERMT2D m512 zmm zmm
// 	VPERMT2D zmm  zmm k zmm
// 	VPERMT2D zmm  zmm zmm
// 	VPERMT2D m128 xmm k xmm
// 	VPERMT2D m128 xmm xmm
// 	VPERMT2D m256 ymm k ymm
// 	VPERMT2D m256 ymm ymm
// 	VPERMT2D xmm  xmm k xmm
// 	VPERMT2D xmm  xmm xmm
// 	VPERMT2D ymm  ymm k ymm
// 	VPERMT2D ymm  ymm ymm
func VPERMT2D(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2D",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2D",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2D",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2D",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2D: bad operands")
}

// VPERMT2D_BCST: Full Permute of Doublewords From Two Tables Overwriting a Table (Broadcast).
//
// Forms:
//
// 	VPERMT2D.BCST m32 zmm k zmm
// 	VPERMT2D.BCST m32 zmm zmm
// 	VPERMT2D.BCST m32 xmm k xmm
// 	VPERMT2D.BCST m32 xmm xmm
// 	VPERMT2D.BCST m32 ymm k ymm
// 	VPERMT2D.BCST m32 ymm ymm
func VPERMT2D_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2D",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2D",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2D",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2D",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2D_BCST: bad operands")
}

// VPERMT2D_BCST_Z: Full Permute of Doublewords From Two Tables Overwriting a Table (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPERMT2D.BCST.Z m32 zmm k zmm
// 	VPERMT2D.BCST.Z m32 xmm k xmm
// 	VPERMT2D.BCST.Z m32 ymm k ymm
func VPERMT2D_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2D",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2D",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2D_BCST_Z: bad operands")
}

// VPERMT2D_Z: Full Permute of Doublewords From Two Tables Overwriting a Table (Zeroing Masking).
//
// Forms:
//
// 	VPERMT2D.Z m512 zmm k zmm
// 	VPERMT2D.Z zmm  zmm k zmm
// 	VPERMT2D.Z m128 xmm k xmm
// 	VPERMT2D.Z m256 ymm k ymm
// 	VPERMT2D.Z xmm  xmm k xmm
// 	VPERMT2D.Z ymm  ymm k ymm
func VPERMT2D_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2D",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2D",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2D_Z: bad operands")
}

// VPERMT2PD: Full Permute of Double-Precision Floating-Point Values From Two Tables Overwriting a Table.
//
// Forms:
//
// 	VPERMT2PD m512 zmm k zmm
// 	VPERMT2PD m512 zmm zmm
// 	VPERMT2PD zmm  zmm k zmm
// 	VPERMT2PD zmm  zmm zmm
// 	VPERMT2PD m128 xmm k xmm
// 	VPERMT2PD m128 xmm xmm
// 	VPERMT2PD m256 ymm k ymm
// 	VPERMT2PD m256 ymm ymm
// 	VPERMT2PD xmm  xmm k xmm
// 	VPERMT2PD xmm  xmm xmm
// 	VPERMT2PD ymm  ymm k ymm
// 	VPERMT2PD ymm  ymm ymm
func VPERMT2PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2PD: bad operands")
}

// VPERMT2PD_BCST: Full Permute of Double-Precision Floating-Point Values From Two Tables Overwriting a Table (Broadcast).
//
// Forms:
//
// 	VPERMT2PD.BCST m64 zmm k zmm
// 	VPERMT2PD.BCST m64 zmm zmm
// 	VPERMT2PD.BCST m64 xmm k xmm
// 	VPERMT2PD.BCST m64 xmm xmm
// 	VPERMT2PD.BCST m64 ymm k ymm
// 	VPERMT2PD.BCST m64 ymm ymm
func VPERMT2PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2PD_BCST: bad operands")
}

// VPERMT2PD_BCST_Z: Full Permute of Double-Precision Floating-Point Values From Two Tables Overwriting a Table (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPERMT2PD.BCST.Z m64 zmm k zmm
// 	VPERMT2PD.BCST.Z m64 xmm k xmm
// 	VPERMT2PD.BCST.Z m64 ymm k ymm
func VPERMT2PD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2PD_BCST_Z: bad operands")
}

// VPERMT2PD_Z: Full Permute of Double-Precision Floating-Point Values From Two Tables Overwriting a Table (Zeroing Masking).
//
// Forms:
//
// 	VPERMT2PD.Z m512 zmm k zmm
// 	VPERMT2PD.Z zmm  zmm k zmm
// 	VPERMT2PD.Z m128 xmm k xmm
// 	VPERMT2PD.Z m256 ymm k ymm
// 	VPERMT2PD.Z xmm  xmm k xmm
// 	VPERMT2PD.Z ymm  ymm k ymm
func VPERMT2PD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2PD_Z: bad operands")
}

// VPERMT2PS: Full Permute of Single-Precision Floating-Point Values From Two Tables Overwriting a Table.
//
// Forms:
//
// 	VPERMT2PS m512 zmm k zmm
// 	VPERMT2PS m512 zmm zmm
// 	VPERMT2PS zmm  zmm k zmm
// 	VPERMT2PS zmm  zmm zmm
// 	VPERMT2PS m128 xmm k xmm
// 	VPERMT2PS m128 xmm xmm
// 	VPERMT2PS m256 ymm k ymm
// 	VPERMT2PS m256 ymm ymm
// 	VPERMT2PS xmm  xmm k xmm
// 	VPERMT2PS xmm  xmm xmm
// 	VPERMT2PS ymm  ymm k ymm
// 	VPERMT2PS ymm  ymm ymm
func VPERMT2PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2PS: bad operands")
}

// VPERMT2PS_BCST: Full Permute of Single-Precision Floating-Point Values From Two Tables Overwriting a Table (Broadcast).
//
// Forms:
//
// 	VPERMT2PS.BCST m32 zmm k zmm
// 	VPERMT2PS.BCST m32 zmm zmm
// 	VPERMT2PS.BCST m32 xmm k xmm
// 	VPERMT2PS.BCST m32 xmm xmm
// 	VPERMT2PS.BCST m32 ymm k ymm
// 	VPERMT2PS.BCST m32 ymm ymm
func VPERMT2PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2PS_BCST: bad operands")
}

// VPERMT2PS_BCST_Z: Full Permute of Single-Precision Floating-Point Values From Two Tables Overwriting a Table (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPERMT2PS.BCST.Z m32 zmm k zmm
// 	VPERMT2PS.BCST.Z m32 xmm k xmm
// 	VPERMT2PS.BCST.Z m32 ymm k ymm
func VPERMT2PS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2PS_BCST_Z: bad operands")
}

// VPERMT2PS_Z: Full Permute of Single-Precision Floating-Point Values From Two Tables Overwriting a Table (Zeroing Masking).
//
// Forms:
//
// 	VPERMT2PS.Z m512 zmm k zmm
// 	VPERMT2PS.Z zmm  zmm k zmm
// 	VPERMT2PS.Z m128 xmm k xmm
// 	VPERMT2PS.Z m256 ymm k ymm
// 	VPERMT2PS.Z xmm  xmm k xmm
// 	VPERMT2PS.Z ymm  ymm k ymm
func VPERMT2PS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2PS_Z: bad operands")
}

// VPERMT2Q: Full Permute of Quadwords From Two Tables Overwriting a Table.
//
// Forms:
//
// 	VPERMT2Q m512 zmm k zmm
// 	VPERMT2Q m512 zmm zmm
// 	VPERMT2Q zmm  zmm k zmm
// 	VPERMT2Q zmm  zmm zmm
// 	VPERMT2Q m128 xmm k xmm
// 	VPERMT2Q m128 xmm xmm
// 	VPERMT2Q m256 ymm k ymm
// 	VPERMT2Q m256 ymm ymm
// 	VPERMT2Q xmm  xmm k xmm
// 	VPERMT2Q xmm  xmm xmm
// 	VPERMT2Q ymm  ymm k ymm
// 	VPERMT2Q ymm  ymm ymm
func VPERMT2Q(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2Q",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2Q",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2Q",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2Q",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2Q: bad operands")
}

// VPERMT2Q_BCST: Full Permute of Quadwords From Two Tables Overwriting a Table (Broadcast).
//
// Forms:
//
// 	VPERMT2Q.BCST m64 zmm k zmm
// 	VPERMT2Q.BCST m64 zmm zmm
// 	VPERMT2Q.BCST m64 xmm k xmm
// 	VPERMT2Q.BCST m64 xmm xmm
// 	VPERMT2Q.BCST m64 ymm k ymm
// 	VPERMT2Q.BCST m64 ymm ymm
func VPERMT2Q_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2Q",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2Q",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2Q",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2Q",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2Q_BCST: bad operands")
}

// VPERMT2Q_BCST_Z: Full Permute of Quadwords From Two Tables Overwriting a Table (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPERMT2Q.BCST.Z m64 zmm k zmm
// 	VPERMT2Q.BCST.Z m64 xmm k xmm
// 	VPERMT2Q.BCST.Z m64 ymm k ymm
func VPERMT2Q_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2Q",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2Q",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2Q_BCST_Z: bad operands")
}

// VPERMT2Q_Z: Full Permute of Quadwords From Two Tables Overwriting a Table (Zeroing Masking).
//
// Forms:
//
// 	VPERMT2Q.Z m512 zmm k zmm
// 	VPERMT2Q.Z zmm  zmm k zmm
// 	VPERMT2Q.Z m128 xmm k xmm
// 	VPERMT2Q.Z m256 ymm k ymm
// 	VPERMT2Q.Z xmm  xmm k xmm
// 	VPERMT2Q.Z ymm  ymm k ymm
func VPERMT2Q_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2Q",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2Q",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPERMT2Q_Z: bad operands")
}

// VPERMT2W: Full Permute of Words From Two Tables Overwriting a Table.
//
// Forms:
//
// 	VPERMT2W m512 zmm k zmm
// 	VPERMT2W m512 zmm zmm
// 	VPERMT2W zmm  zmm k zmm
// 	VPERMT2W zmm  zmm zmm
// 	VPERMT2W m128 xmm k xmm
// 	VPERMT2W m128 xmm xmm
// 	VPERMT2W m256 ymm k ymm
// 	VPERMT2W m256 ymm ymm
// 	VPERMT2W xmm  xmm k xmm
// 	VPERMT2W xmm  xmm xmm
// 	VPERMT2W ymm  ymm k ymm
// 	VPERMT2W ymm  ymm ymm
func VPERMT2W(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2W",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2W",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2W",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMT2W",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPERMT2W: bad operands")
}

// VPERMT2W_Z: Full Permute of Words From Two Tables Overwriting a Table (Zeroing Masking).
//
// Forms:
//
// 	VPERMT2W.Z m512 zmm k zmm
// 	VPERMT2W.Z zmm  zmm k zmm
// 	VPERMT2W.Z m128 xmm k xmm
// 	VPERMT2W.Z m256 ymm k ymm
// 	VPERMT2W.Z xmm  xmm k xmm
// 	VPERMT2W.Z ymm  ymm k ymm
func VPERMT2W_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2W",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMT2W",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPERMT2W_Z: bad operands")
}

// VPERMW: Permute Word Integers.
//
// Forms:
//
// 	VPERMW m512 zmm k zmm
// 	VPERMW m512 zmm zmm
// 	VPERMW zmm  zmm k zmm
// 	VPERMW zmm  zmm zmm
// 	VPERMW m128 xmm k xmm
// 	VPERMW m128 xmm xmm
// 	VPERMW m256 ymm k ymm
// 	VPERMW m256 ymm ymm
// 	VPERMW xmm  xmm k xmm
// 	VPERMW xmm  xmm xmm
// 	VPERMW ymm  ymm k ymm
// 	VPERMW ymm  ymm ymm
func VPERMW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPERMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPERMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPERMW: bad operands")
}

// VPERMW_Z: Permute Word Integers (Zeroing Masking).
//
// Forms:
//
// 	VPERMW.Z m512 zmm k zmm
// 	VPERMW.Z zmm  zmm k zmm
// 	VPERMW.Z m128 xmm k xmm
// 	VPERMW.Z m256 ymm k ymm
// 	VPERMW.Z xmm  xmm k xmm
// 	VPERMW.Z ymm  ymm k ymm
func VPERMW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPERMW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPERMW_Z: bad operands")
}

// VPEXPANDD: Load Sparse Packed Doubleword Integer Values from Dense Memory/Register.
//
// Forms:
//
// 	VPEXPANDD m512 k zmm
// 	VPEXPANDD m512 zmm
// 	VPEXPANDD zmm  k zmm
// 	VPEXPANDD zmm  zmm
// 	VPEXPANDD m128 k xmm
// 	VPEXPANDD m128 xmm
// 	VPEXPANDD m256 k ymm
// 	VPEXPANDD m256 ymm
// 	VPEXPANDD xmm  k xmm
// 	VPEXPANDD xmm  xmm
// 	VPEXPANDD ymm  k ymm
// 	VPEXPANDD ymm  ymm
func VPEXPANDD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPEXPANDD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPEXPANDD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPEXPANDD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPEXPANDD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPEXPANDD: bad operands")
}

// VPEXPANDD_Z: Load Sparse Packed Doubleword Integer Values from Dense Memory/Register (Zeroing Masking).
//
// Forms:
//
// 	VPEXPANDD.Z m512 k zmm
// 	VPEXPANDD.Z zmm  k zmm
// 	VPEXPANDD.Z m128 k xmm
// 	VPEXPANDD.Z m256 k ymm
// 	VPEXPANDD.Z xmm  k xmm
// 	VPEXPANDD.Z ymm  k ymm
func VPEXPANDD_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPEXPANDD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPEXPANDD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPEXPANDD_Z: bad operands")
}

// VPEXPANDQ: Load Sparse Packed Quadword Integer Values from Dense Memory/Register.
//
// Forms:
//
// 	VPEXPANDQ m512 k zmm
// 	VPEXPANDQ m512 zmm
// 	VPEXPANDQ zmm  k zmm
// 	VPEXPANDQ zmm  zmm
// 	VPEXPANDQ m128 k xmm
// 	VPEXPANDQ m128 xmm
// 	VPEXPANDQ m256 k ymm
// 	VPEXPANDQ m256 ymm
// 	VPEXPANDQ xmm  k xmm
// 	VPEXPANDQ xmm  xmm
// 	VPEXPANDQ ymm  k ymm
// 	VPEXPANDQ ymm  ymm
func VPEXPANDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPEXPANDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPEXPANDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPEXPANDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPEXPANDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPEXPANDQ: bad operands")
}

// VPEXPANDQ_Z: Load Sparse Packed Quadword Integer Values from Dense Memory/Register (Zeroing Masking).
//
// Forms:
//
// 	VPEXPANDQ.Z m512 k zmm
// 	VPEXPANDQ.Z zmm  k zmm
// 	VPEXPANDQ.Z m128 k xmm
// 	VPEXPANDQ.Z m256 k ymm
// 	VPEXPANDQ.Z xmm  k xmm
// 	VPEXPANDQ.Z ymm  k ymm
func VPEXPANDQ_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPEXPANDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPEXPANDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPEXPANDQ_Z: bad operands")
}

// VPEXTRB: Extract Byte.
//
// Forms:
//
// 	VPEXTRB imm8 xmm m8
// 	VPEXTRB imm8 xmm r32
func VPEXTRB(i, x, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsM8(mr),
		operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "VPEXTRB",
			Operands: []operand.Op{i, x, mr},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{mr},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPEXTRB: bad operands")
}

// VPEXTRD: Extract Doubleword.
//
// Forms:
//
// 	VPEXTRD imm8 xmm m32
// 	VPEXTRD imm8 xmm r32
func VPEXTRD(i, x, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsM32(mr),
		operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "VPEXTRD",
			Operands: []operand.Op{i, x, mr},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{mr},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPEXTRD: bad operands")
}

// VPEXTRQ: Extract Quadword.
//
// Forms:
//
// 	VPEXTRQ imm8 xmm m64
// 	VPEXTRQ imm8 xmm r64
func VPEXTRQ(i, x, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsM64(mr),
		operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "VPEXTRQ",
			Operands: []operand.Op{i, x, mr},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{mr},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPEXTRQ: bad operands")
}

// VPEXTRW: Extract Word.
//
// Forms:
//
// 	VPEXTRW imm8 xmm m16
// 	VPEXTRW imm8 xmm r32
func VPEXTRW(i, x, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsM16(mr),
		operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "VPEXTRW",
			Operands: []operand.Op{i, x, mr},
			Inputs:   []operand.Op{x},
			Outputs:  []operand.Op{mr},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPEXTRW: bad operands")
}

// VPGATHERDD: Gather Packed Doubleword Values Using Signed Doubleword Indices.
//
// Forms:
//
// 	VPGATHERDD xmm   vm32x xmm
// 	VPGATHERDD ymm   vm32y ymm
// 	VPGATHERDD vm32z k     zmm
// 	VPGATHERDD vm32x k     xmm
// 	VPGATHERDD vm32y k     ymm
func VPGATHERDD(vxy, kv, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(vxy) && operand.IsVM32X(kv) && operand.IsXMM(xyz),
		operand.IsYMM(vxy) && operand.IsVM32Y(kv) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPGATHERDD",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{vxy, xyz},
			ISA:      []string{"AVX2"},
		}, nil
	case operand.IsVM32Z(vxy) && operand.IsK(kv) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPGATHERDD",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsVM32X(vxy) && operand.IsK(kv) && operand.IsXMM(xyz),
		operand.IsVM32Y(vxy) && operand.IsK(kv) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPGATHERDD",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPGATHERDD: bad operands")
}

// VPGATHERDQ: Gather Packed Quadword Values Using Signed Doubleword Indices.
//
// Forms:
//
// 	VPGATHERDQ xmm   vm32x xmm
// 	VPGATHERDQ ymm   vm32x ymm
// 	VPGATHERDQ vm32y k     zmm
// 	VPGATHERDQ vm32x k     xmm
// 	VPGATHERDQ vm32x k     ymm
func VPGATHERDQ(vxy, kv, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(vxy) && operand.IsVM32X(kv) && operand.IsXMM(xyz),
		operand.IsYMM(vxy) && operand.IsVM32X(kv) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPGATHERDQ",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{vxy, xyz},
			ISA:      []string{"AVX2"},
		}, nil
	case operand.IsVM32Y(vxy) && operand.IsK(kv) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPGATHERDQ",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsVM32X(vxy) && operand.IsK(kv) && operand.IsXMM(xyz),
		operand.IsVM32X(vxy) && operand.IsK(kv) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPGATHERDQ",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPGATHERDQ: bad operands")
}

// VPGATHERQD: Gather Packed Doubleword Values Using Signed Quadword Indices.
//
// Forms:
//
// 	VPGATHERQD xmm   vm64x xmm
// 	VPGATHERQD xmm   vm64y xmm
// 	VPGATHERQD vm64z k     ymm
// 	VPGATHERQD vm64x k     xmm
// 	VPGATHERQD vm64y k     xmm
func VPGATHERQD(vx, kv, xy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(vx) && operand.IsVM64X(kv) && operand.IsXMM(xy),
		operand.IsXMM(vx) && operand.IsVM64Y(kv) && operand.IsXMM(xy):
		return &intrep.Instruction{
			Opcode:   "VPGATHERQD",
			Operands: []operand.Op{vx, kv, xy},
			Inputs:   []operand.Op{vx, kv, xy},
			Outputs:  []operand.Op{vx, xy},
			ISA:      []string{"AVX2"},
		}, nil
	case operand.IsVM64Z(vx) && operand.IsK(kv) && operand.IsYMM(xy):
		return &intrep.Instruction{
			Opcode:   "VPGATHERQD",
			Operands: []operand.Op{vx, kv, xy},
			Inputs:   []operand.Op{vx, kv, xy},
			Outputs:  []operand.Op{xy},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsVM64X(vx) && operand.IsK(kv) && operand.IsXMM(xy),
		operand.IsVM64Y(vx) && operand.IsK(kv) && operand.IsXMM(xy):
		return &intrep.Instruction{
			Opcode:   "VPGATHERQD",
			Operands: []operand.Op{vx, kv, xy},
			Inputs:   []operand.Op{vx, kv, xy},
			Outputs:  []operand.Op{xy},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPGATHERQD: bad operands")
}

// VPGATHERQQ: Gather Packed Quadword Values Using Signed Quadword Indices.
//
// Forms:
//
// 	VPGATHERQQ xmm   vm64x xmm
// 	VPGATHERQQ ymm   vm64y ymm
// 	VPGATHERQQ vm64z k     zmm
// 	VPGATHERQQ vm64x k     xmm
// 	VPGATHERQQ vm64y k     ymm
func VPGATHERQQ(vxy, kv, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(vxy) && operand.IsVM64X(kv) && operand.IsXMM(xyz),
		operand.IsYMM(vxy) && operand.IsVM64Y(kv) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPGATHERQQ",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{vxy, xyz},
			ISA:      []string{"AVX2"},
		}, nil
	case operand.IsVM64Z(vxy) && operand.IsK(kv) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPGATHERQQ",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsVM64X(vxy) && operand.IsK(kv) && operand.IsXMM(xyz),
		operand.IsVM64Y(vxy) && operand.IsK(kv) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPGATHERQQ",
			Operands: []operand.Op{vxy, kv, xyz},
			Inputs:   []operand.Op{vxy, kv, xyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPGATHERQQ: bad operands")
}

// VPHADDD: Packed Horizontal Add Doubleword Integer.
//
// Forms:
//
// 	VPHADDD m256 ymm ymm
// 	VPHADDD ymm  ymm ymm
// 	VPHADDD m128 xmm xmm
// 	VPHADDD xmm  xmm xmm
func VPHADDD(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPHADDD",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPHADDD",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPHADDD: bad operands")
}

// VPHADDSW: Packed Horizontal Add Signed Word Integers with Signed Saturation.
//
// Forms:
//
// 	VPHADDSW m256 ymm ymm
// 	VPHADDSW ymm  ymm ymm
// 	VPHADDSW m128 xmm xmm
// 	VPHADDSW xmm  xmm xmm
func VPHADDSW(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPHADDSW",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPHADDSW",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPHADDSW: bad operands")
}

// VPHADDW: Packed Horizontal Add Word Integers.
//
// Forms:
//
// 	VPHADDW m256 ymm ymm
// 	VPHADDW ymm  ymm ymm
// 	VPHADDW m128 xmm xmm
// 	VPHADDW xmm  xmm xmm
func VPHADDW(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPHADDW",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPHADDW",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPHADDW: bad operands")
}

// VPHMINPOSUW: Packed Horizontal Minimum of Unsigned Word Integers.
//
// Forms:
//
// 	VPHMINPOSUW m128 xmm
// 	VPHMINPOSUW xmm  xmm
func VPHMINPOSUW(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VPHMINPOSUW",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx},
			Outputs:  []operand.Op{x},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPHMINPOSUW: bad operands")
}

// VPHSUBD: Packed Horizontal Subtract Doubleword Integers.
//
// Forms:
//
// 	VPHSUBD m256 ymm ymm
// 	VPHSUBD ymm  ymm ymm
// 	VPHSUBD m128 xmm xmm
// 	VPHSUBD xmm  xmm xmm
func VPHSUBD(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:           "VPHSUBD",
			Operands:         []operand.Op{mxy, xy, xy1},
			Inputs:           []operand.Op{mxy, xy},
			Outputs:          []operand.Op{xy1},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPHSUBD",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:           "VPHSUBD",
			Operands:         []operand.Op{mxy, xy, xy1},
			Inputs:           []operand.Op{mxy, xy},
			Outputs:          []operand.Op{xy1},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPHSUBD",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPHSUBD: bad operands")
}

// VPHSUBSW: Packed Horizontal Subtract Signed Word Integers with Signed Saturation.
//
// Forms:
//
// 	VPHSUBSW m256 ymm ymm
// 	VPHSUBSW ymm  ymm ymm
// 	VPHSUBSW m128 xmm xmm
// 	VPHSUBSW xmm  xmm xmm
func VPHSUBSW(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:           "VPHSUBSW",
			Operands:         []operand.Op{mxy, xy, xy1},
			Inputs:           []operand.Op{mxy, xy},
			Outputs:          []operand.Op{xy1},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPHSUBSW",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:           "VPHSUBSW",
			Operands:         []operand.Op{mxy, xy, xy1},
			Inputs:           []operand.Op{mxy, xy},
			Outputs:          []operand.Op{xy1},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPHSUBSW",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPHSUBSW: bad operands")
}

// VPHSUBW: Packed Horizontal Subtract Word Integers.
//
// Forms:
//
// 	VPHSUBW m256 ymm ymm
// 	VPHSUBW ymm  ymm ymm
// 	VPHSUBW m128 xmm xmm
// 	VPHSUBW xmm  xmm xmm
func VPHSUBW(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:           "VPHSUBW",
			Operands:         []operand.Op{mxy, xy, xy1},
			Inputs:           []operand.Op{mxy, xy},
			Outputs:          []operand.Op{xy1},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPHSUBW",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:           "VPHSUBW",
			Operands:         []operand.Op{mxy, xy, xy1},
			Inputs:           []operand.Op{mxy, xy},
			Outputs:          []operand.Op{xy1},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPHSUBW",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPHSUBW: bad operands")
}

// VPINSRB: Insert Byte.
//
// Forms:
//
// 	VPINSRB imm8 m8  xmm xmm
// 	VPINSRB imm8 r32 xmm xmm
func VPINSRB(i, mr, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM8(mr) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsR32(mr) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VPINSRB",
			Operands: []operand.Op{i, mr, x, x1},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPINSRB: bad operands")
}

// VPINSRD: Insert Doubleword.
//
// Forms:
//
// 	VPINSRD imm8 m32 xmm xmm
// 	VPINSRD imm8 r32 xmm xmm
func VPINSRD(i, mr, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(mr) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsR32(mr) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VPINSRD",
			Operands: []operand.Op{i, mr, x, x1},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPINSRD: bad operands")
}

// VPINSRQ: Insert Quadword.
//
// Forms:
//
// 	VPINSRQ imm8 m64 xmm xmm
// 	VPINSRQ imm8 r64 xmm xmm
func VPINSRQ(i, mr, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(mr) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsR64(mr) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VPINSRQ",
			Operands: []operand.Op{i, mr, x, x1},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPINSRQ: bad operands")
}

// VPINSRW: Insert Word.
//
// Forms:
//
// 	VPINSRW imm8 m16 xmm xmm
// 	VPINSRW imm8 r32 xmm xmm
func VPINSRW(i, mr, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM16(mr) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsR32(mr) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VPINSRW",
			Operands: []operand.Op{i, mr, x, x1},
			Inputs:   []operand.Op{mr, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPINSRW: bad operands")
}

// VPLZCNTD: Count the Number of Leading Zero Bits for Packed Doubleword Values.
//
// Forms:
//
// 	VPLZCNTD m512 k zmm
// 	VPLZCNTD m512 zmm
// 	VPLZCNTD zmm  k zmm
// 	VPLZCNTD zmm  zmm
// 	VPLZCNTD m128 k xmm
// 	VPLZCNTD m128 xmm
// 	VPLZCNTD m256 k ymm
// 	VPLZCNTD m256 ymm
// 	VPLZCNTD xmm  k xmm
// 	VPLZCNTD xmm  xmm
// 	VPLZCNTD ymm  k ymm
// 	VPLZCNTD ymm  ymm
func VPLZCNTD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPLZCNTD: bad operands")
}

// VPLZCNTD_BCST: Count the Number of Leading Zero Bits for Packed Doubleword Values (Broadcast).
//
// Forms:
//
// 	VPLZCNTD.BCST m32 k zmm
// 	VPLZCNTD.BCST m32 zmm
// 	VPLZCNTD.BCST m32 k xmm
// 	VPLZCNTD.BCST m32 k ymm
// 	VPLZCNTD.BCST m32 xmm
// 	VPLZCNTD.BCST m32 ymm
func VPLZCNTD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPLZCNTD_BCST: bad operands")
}

// VPLZCNTD_BCST_Z: Count the Number of Leading Zero Bits for Packed Doubleword Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPLZCNTD.BCST.Z m32 k zmm
// 	VPLZCNTD.BCST.Z m32 k xmm
// 	VPLZCNTD.BCST.Z m32 k ymm
func VPLZCNTD_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512CD"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPLZCNTD_BCST_Z: bad operands")
}

// VPLZCNTD_Z: Count the Number of Leading Zero Bits for Packed Doubleword Values (Zeroing Masking).
//
// Forms:
//
// 	VPLZCNTD.Z m512 k zmm
// 	VPLZCNTD.Z zmm  k zmm
// 	VPLZCNTD.Z m128 k xmm
// 	VPLZCNTD.Z m256 k ymm
// 	VPLZCNTD.Z xmm  k xmm
// 	VPLZCNTD.Z ymm  k ymm
func VPLZCNTD_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512CD"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPLZCNTD_Z: bad operands")
}

// VPLZCNTQ: Count the Number of Leading Zero Bits for Packed Quadword Values.
//
// Forms:
//
// 	VPLZCNTQ m512 k zmm
// 	VPLZCNTQ m512 zmm
// 	VPLZCNTQ zmm  k zmm
// 	VPLZCNTQ zmm  zmm
// 	VPLZCNTQ m128 k xmm
// 	VPLZCNTQ m128 xmm
// 	VPLZCNTQ m256 k ymm
// 	VPLZCNTQ m256 ymm
// 	VPLZCNTQ xmm  k xmm
// 	VPLZCNTQ xmm  xmm
// 	VPLZCNTQ ymm  k ymm
// 	VPLZCNTQ ymm  ymm
func VPLZCNTQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPLZCNTQ: bad operands")
}

// VPLZCNTQ_BCST: Count the Number of Leading Zero Bits for Packed Quadword Values (Broadcast).
//
// Forms:
//
// 	VPLZCNTQ.BCST m64 k zmm
// 	VPLZCNTQ.BCST m64 zmm
// 	VPLZCNTQ.BCST m64 k xmm
// 	VPLZCNTQ.BCST m64 k ymm
// 	VPLZCNTQ.BCST m64 xmm
// 	VPLZCNTQ.BCST m64 ymm
func VPLZCNTQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512CD"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPLZCNTQ_BCST: bad operands")
}

// VPLZCNTQ_BCST_Z: Count the Number of Leading Zero Bits for Packed Quadword Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPLZCNTQ.BCST.Z m64 k zmm
// 	VPLZCNTQ.BCST.Z m64 k xmm
// 	VPLZCNTQ.BCST.Z m64 k ymm
func VPLZCNTQ_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512CD"},
		}, nil
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPLZCNTQ_BCST_Z: bad operands")
}

// VPLZCNTQ_Z: Count the Number of Leading Zero Bits for Packed Quadword Values (Zeroing Masking).
//
// Forms:
//
// 	VPLZCNTQ.Z m512 k zmm
// 	VPLZCNTQ.Z zmm  k zmm
// 	VPLZCNTQ.Z m128 k xmm
// 	VPLZCNTQ.Z m256 k ymm
// 	VPLZCNTQ.Z xmm  k xmm
// 	VPLZCNTQ.Z ymm  k ymm
func VPLZCNTQ_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512CD"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPLZCNTQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512CD"},
		}, nil
	}
	return nil, errors.New("VPLZCNTQ_Z: bad operands")
}

// VPMADD52HUQ: Packed Multiply of Unsigned 52-bit Unsigned Integers and Add High 52-bit Products to Quadword Accumulators.
//
// Forms:
//
// 	VPMADD52HUQ m128 xmm k xmm
// 	VPMADD52HUQ m128 xmm xmm
// 	VPMADD52HUQ m256 ymm k ymm
// 	VPMADD52HUQ m256 ymm ymm
// 	VPMADD52HUQ xmm  xmm k xmm
// 	VPMADD52HUQ xmm  xmm xmm
// 	VPMADD52HUQ ymm  ymm k ymm
// 	VPMADD52HUQ ymm  ymm ymm
// 	VPMADD52HUQ m512 zmm k zmm
// 	VPMADD52HUQ m512 zmm zmm
// 	VPMADD52HUQ zmm  zmm k zmm
// 	VPMADD52HUQ zmm  zmm zmm
func VPMADD52HUQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52HUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512IFMA", "AVX512VL"},
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52HUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512IFMA"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52HUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512IFMA", "AVX512VL"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52HUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512IFMA"},
		}, nil
	}
	return nil, errors.New("VPMADD52HUQ: bad operands")
}

// VPMADD52HUQ_BCST: Packed Multiply of Unsigned 52-bit Unsigned Integers and Add High 52-bit Products to Quadword Accumulators (Broadcast).
//
// Forms:
//
// 	VPMADD52HUQ.BCST m64 xmm k xmm
// 	VPMADD52HUQ.BCST m64 xmm xmm
// 	VPMADD52HUQ.BCST m64 ymm k ymm
// 	VPMADD52HUQ.BCST m64 ymm ymm
// 	VPMADD52HUQ.BCST m64 zmm k zmm
// 	VPMADD52HUQ.BCST m64 zmm zmm
func VPMADD52HUQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52HUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512IFMA", "AVX512VL"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52HUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512IFMA"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52HUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512IFMA", "AVX512VL"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52HUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512IFMA"},
		}, nil
	}
	return nil, errors.New("VPMADD52HUQ_BCST: bad operands")
}

// VPMADD52HUQ_BCST_Z: Packed Multiply of Unsigned 52-bit Unsigned Integers and Add High 52-bit Products to Quadword Accumulators (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMADD52HUQ.BCST.Z m64 xmm k xmm
// 	VPMADD52HUQ.BCST.Z m64 ymm k ymm
// 	VPMADD52HUQ.BCST.Z m64 zmm k zmm
func VPMADD52HUQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMADD52HUQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512IFMA", "AVX512VL"},
		}, nil
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMADD52HUQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512IFMA"},
		}, nil
	}
	return nil, errors.New("VPMADD52HUQ_BCST_Z: bad operands")
}

// VPMADD52HUQ_Z: Packed Multiply of Unsigned 52-bit Unsigned Integers and Add High 52-bit Products to Quadword Accumulators (Zeroing Masking).
//
// Forms:
//
// 	VPMADD52HUQ.Z m128 xmm k xmm
// 	VPMADD52HUQ.Z m256 ymm k ymm
// 	VPMADD52HUQ.Z xmm  xmm k xmm
// 	VPMADD52HUQ.Z ymm  ymm k ymm
// 	VPMADD52HUQ.Z m512 zmm k zmm
// 	VPMADD52HUQ.Z zmm  zmm k zmm
func VPMADD52HUQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMADD52HUQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512IFMA", "AVX512VL"},
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMADD52HUQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512IFMA"},
		}, nil
	}
	return nil, errors.New("VPMADD52HUQ_Z: bad operands")
}

// VPMADD52LUQ: Packed Multiply of Unsigned 52-bit Integers and Add the Low 52-bit Products to Quadword Accumulators.
//
// Forms:
//
// 	VPMADD52LUQ m128 xmm k xmm
// 	VPMADD52LUQ m128 xmm xmm
// 	VPMADD52LUQ m256 ymm k ymm
// 	VPMADD52LUQ m256 ymm ymm
// 	VPMADD52LUQ xmm  xmm k xmm
// 	VPMADD52LUQ xmm  xmm xmm
// 	VPMADD52LUQ ymm  ymm k ymm
// 	VPMADD52LUQ ymm  ymm ymm
// 	VPMADD52LUQ m512 zmm k zmm
// 	VPMADD52LUQ m512 zmm zmm
// 	VPMADD52LUQ zmm  zmm k zmm
// 	VPMADD52LUQ zmm  zmm zmm
func VPMADD52LUQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52LUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512IFMA", "AVX512VL"},
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52LUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512IFMA"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52LUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512IFMA", "AVX512VL"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52LUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512IFMA"},
		}, nil
	}
	return nil, errors.New("VPMADD52LUQ: bad operands")
}

// VPMADD52LUQ_BCST: Packed Multiply of Unsigned 52-bit Integers and Add the Low 52-bit Products to Quadword Accumulators (Broadcast).
//
// Forms:
//
// 	VPMADD52LUQ.BCST m64 xmm k xmm
// 	VPMADD52LUQ.BCST m64 xmm xmm
// 	VPMADD52LUQ.BCST m64 ymm k ymm
// 	VPMADD52LUQ.BCST m64 ymm ymm
// 	VPMADD52LUQ.BCST m64 zmm k zmm
// 	VPMADD52LUQ.BCST m64 zmm zmm
func VPMADD52LUQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52LUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512IFMA", "AVX512VL"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52LUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512IFMA"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52LUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512IFMA", "AVX512VL"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMADD52LUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512IFMA"},
		}, nil
	}
	return nil, errors.New("VPMADD52LUQ_BCST: bad operands")
}

// VPMADD52LUQ_BCST_Z: Packed Multiply of Unsigned 52-bit Integers and Add the Low 52-bit Products to Quadword Accumulators (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMADD52LUQ.BCST.Z m64 xmm k xmm
// 	VPMADD52LUQ.BCST.Z m64 ymm k ymm
// 	VPMADD52LUQ.BCST.Z m64 zmm k zmm
func VPMADD52LUQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMADD52LUQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512IFMA", "AVX512VL"},
		}, nil
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMADD52LUQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512IFMA"},
		}, nil
	}
	return nil, errors.New("VPMADD52LUQ_BCST_Z: bad operands")
}

// VPMADD52LUQ_Z: Packed Multiply of Unsigned 52-bit Integers and Add the Low 52-bit Products to Quadword Accumulators (Zeroing Masking).
//
// Forms:
//
// 	VPMADD52LUQ.Z m128 xmm k xmm
// 	VPMADD52LUQ.Z m256 ymm k ymm
// 	VPMADD52LUQ.Z xmm  xmm k xmm
// 	VPMADD52LUQ.Z ymm  ymm k ymm
// 	VPMADD52LUQ.Z m512 zmm k zmm
// 	VPMADD52LUQ.Z zmm  zmm k zmm
func VPMADD52LUQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMADD52LUQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512IFMA", "AVX512VL"},
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMADD52LUQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512IFMA"},
		}, nil
	}
	return nil, errors.New("VPMADD52LUQ_Z: bad operands")
}

// VPMADDUBSW: Multiply and Add Packed Signed and Unsigned Byte Integers.
//
// Forms:
//
// 	VPMADDUBSW m256 ymm ymm
// 	VPMADDUBSW ymm  ymm ymm
// 	VPMADDUBSW m128 xmm xmm
// 	VPMADDUBSW xmm  xmm xmm
// 	VPMADDUBSW m512 zmm k zmm
// 	VPMADDUBSW m512 zmm zmm
// 	VPMADDUBSW zmm  zmm k zmm
// 	VPMADDUBSW zmm  zmm zmm
// 	VPMADDUBSW m128 xmm k xmm
// 	VPMADDUBSW m256 ymm k ymm
// 	VPMADDUBSW xmm  xmm k xmm
// 	VPMADDUBSW ymm  ymm k ymm
func VPMADDUBSW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMADDUBSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMADDUBSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMADDUBSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMADDUBSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMADDUBSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMADDUBSW: bad operands")
}

// VPMADDUBSW_Z: Multiply and Add Packed Signed and Unsigned Byte Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMADDUBSW.Z m512 zmm k zmm
// 	VPMADDUBSW.Z zmm  zmm k zmm
// 	VPMADDUBSW.Z m128 xmm k xmm
// 	VPMADDUBSW.Z m256 ymm k ymm
// 	VPMADDUBSW.Z xmm  xmm k xmm
// 	VPMADDUBSW.Z ymm  ymm k ymm
func VPMADDUBSW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMADDUBSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMADDUBSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMADDUBSW_Z: bad operands")
}

// VPMADDWD: Multiply and Add Packed Signed Word Integers.
//
// Forms:
//
// 	VPMADDWD m256 ymm ymm
// 	VPMADDWD ymm  ymm ymm
// 	VPMADDWD m128 xmm xmm
// 	VPMADDWD xmm  xmm xmm
// 	VPMADDWD m512 zmm k zmm
// 	VPMADDWD m512 zmm zmm
// 	VPMADDWD zmm  zmm k zmm
// 	VPMADDWD zmm  zmm zmm
// 	VPMADDWD m128 xmm k xmm
// 	VPMADDWD m256 ymm k ymm
// 	VPMADDWD xmm  xmm k xmm
// 	VPMADDWD ymm  ymm k ymm
func VPMADDWD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMADDWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMADDWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMADDWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMADDWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMADDWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMADDWD: bad operands")
}

// VPMADDWD_Z: Multiply and Add Packed Signed Word Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMADDWD.Z m512 zmm k zmm
// 	VPMADDWD.Z zmm  zmm k zmm
// 	VPMADDWD.Z m128 xmm k xmm
// 	VPMADDWD.Z m256 ymm k ymm
// 	VPMADDWD.Z xmm  xmm k xmm
// 	VPMADDWD.Z ymm  ymm k ymm
func VPMADDWD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMADDWD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMADDWD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMADDWD_Z: bad operands")
}

// VPMASKMOVD: Conditional Move Packed Doubleword Integers.
//
// Forms:
//
// 	VPMASKMOVD m128 xmm xmm
// 	VPMASKMOVD m256 ymm ymm
// 	VPMASKMOVD xmm  xmm m128
// 	VPMASKMOVD ymm  ymm m256
func VPMASKMOVD(mxy, xy, mxy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(mxy1),
		operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(mxy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsM128(mxy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsM256(mxy1):
		return &intrep.Instruction{
			Opcode:   "VPMASKMOVD",
			Operands: []operand.Op{mxy, xy, mxy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{mxy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPMASKMOVD: bad operands")
}

// VPMASKMOVQ: Conditional Move Packed Quadword Integers.
//
// Forms:
//
// 	VPMASKMOVQ m128 xmm xmm
// 	VPMASKMOVQ m256 ymm ymm
// 	VPMASKMOVQ xmm  xmm m128
// 	VPMASKMOVQ ymm  ymm m256
func VPMASKMOVQ(mxy, xy, mxy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(mxy1),
		operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(mxy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsM128(mxy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsM256(mxy1):
		return &intrep.Instruction{
			Opcode:   "VPMASKMOVQ",
			Operands: []operand.Op{mxy, xy, mxy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{mxy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPMASKMOVQ: bad operands")
}

// VPMAXSB: Maximum of Packed Signed Byte Integers.
//
// Forms:
//
// 	VPMAXSB m256 ymm ymm
// 	VPMAXSB ymm  ymm ymm
// 	VPMAXSB m128 xmm xmm
// 	VPMAXSB xmm  xmm xmm
// 	VPMAXSB m512 zmm k zmm
// 	VPMAXSB m512 zmm zmm
// 	VPMAXSB zmm  zmm k zmm
// 	VPMAXSB zmm  zmm zmm
// 	VPMAXSB m128 xmm k xmm
// 	VPMAXSB m256 ymm k ymm
// 	VPMAXSB xmm  xmm k xmm
// 	VPMAXSB ymm  ymm k ymm
func VPMAXSB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMAXSB: bad operands")
}

// VPMAXSB_Z: Maximum of Packed Signed Byte Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMAXSB.Z m512 zmm k zmm
// 	VPMAXSB.Z zmm  zmm k zmm
// 	VPMAXSB.Z m128 xmm k xmm
// 	VPMAXSB.Z m256 ymm k ymm
// 	VPMAXSB.Z xmm  xmm k xmm
// 	VPMAXSB.Z ymm  ymm k ymm
func VPMAXSB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXSB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXSB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMAXSB_Z: bad operands")
}

// VPMAXSD: Maximum of Packed Signed Doubleword Integers.
//
// Forms:
//
// 	VPMAXSD m256 ymm ymm
// 	VPMAXSD ymm  ymm ymm
// 	VPMAXSD m128 xmm xmm
// 	VPMAXSD xmm  xmm xmm
// 	VPMAXSD m512 zmm k zmm
// 	VPMAXSD m512 zmm zmm
// 	VPMAXSD zmm  zmm k zmm
// 	VPMAXSD zmm  zmm zmm
// 	VPMAXSD m128 xmm k xmm
// 	VPMAXSD m256 ymm k ymm
// 	VPMAXSD xmm  xmm k xmm
// 	VPMAXSD ymm  ymm k ymm
func VPMAXSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXSD: bad operands")
}

// VPMAXSD_BCST: Maximum of Packed Signed Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VPMAXSD.BCST m32 zmm k zmm
// 	VPMAXSD.BCST m32 zmm zmm
// 	VPMAXSD.BCST m32 xmm k xmm
// 	VPMAXSD.BCST m32 xmm xmm
// 	VPMAXSD.BCST m32 ymm k ymm
// 	VPMAXSD.BCST m32 ymm ymm
func VPMAXSD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXSD_BCST: bad operands")
}

// VPMAXSD_BCST_Z: Maximum of Packed Signed Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMAXSD.BCST.Z m32 zmm k zmm
// 	VPMAXSD.BCST.Z m32 xmm k xmm
// 	VPMAXSD.BCST.Z m32 ymm k ymm
func VPMAXSD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXSD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXSD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXSD_BCST_Z: bad operands")
}

// VPMAXSD_Z: Maximum of Packed Signed Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMAXSD.Z m512 zmm k zmm
// 	VPMAXSD.Z zmm  zmm k zmm
// 	VPMAXSD.Z m128 xmm k xmm
// 	VPMAXSD.Z m256 ymm k ymm
// 	VPMAXSD.Z xmm  xmm k xmm
// 	VPMAXSD.Z ymm  ymm k ymm
func VPMAXSD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXSD_Z: bad operands")
}

// VPMAXSQ: Maximum of Packed Signed Quadword Integers.
//
// Forms:
//
// 	VPMAXSQ m512 zmm k zmm
// 	VPMAXSQ m512 zmm zmm
// 	VPMAXSQ zmm  zmm k zmm
// 	VPMAXSQ zmm  zmm zmm
// 	VPMAXSQ m128 xmm k xmm
// 	VPMAXSQ m128 xmm xmm
// 	VPMAXSQ m256 ymm k ymm
// 	VPMAXSQ m256 ymm ymm
// 	VPMAXSQ xmm  xmm k xmm
// 	VPMAXSQ xmm  xmm xmm
// 	VPMAXSQ ymm  ymm k ymm
// 	VPMAXSQ ymm  ymm ymm
func VPMAXSQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXSQ: bad operands")
}

// VPMAXSQ_BCST: Maximum of Packed Signed Quadword Integers (Broadcast).
//
// Forms:
//
// 	VPMAXSQ.BCST m64 zmm k zmm
// 	VPMAXSQ.BCST m64 zmm zmm
// 	VPMAXSQ.BCST m64 xmm k xmm
// 	VPMAXSQ.BCST m64 xmm xmm
// 	VPMAXSQ.BCST m64 ymm k ymm
// 	VPMAXSQ.BCST m64 ymm ymm
func VPMAXSQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXSQ_BCST: bad operands")
}

// VPMAXSQ_BCST_Z: Maximum of Packed Signed Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMAXSQ.BCST.Z m64 zmm k zmm
// 	VPMAXSQ.BCST.Z m64 xmm k xmm
// 	VPMAXSQ.BCST.Z m64 ymm k ymm
func VPMAXSQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXSQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXSQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXSQ_BCST_Z: bad operands")
}

// VPMAXSQ_Z: Maximum of Packed Signed Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMAXSQ.Z m512 zmm k zmm
// 	VPMAXSQ.Z zmm  zmm k zmm
// 	VPMAXSQ.Z m128 xmm k xmm
// 	VPMAXSQ.Z m256 ymm k ymm
// 	VPMAXSQ.Z xmm  xmm k xmm
// 	VPMAXSQ.Z ymm  ymm k ymm
func VPMAXSQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXSQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXSQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXSQ_Z: bad operands")
}

// VPMAXSW: Maximum of Packed Signed Word Integers.
//
// Forms:
//
// 	VPMAXSW m256 ymm ymm
// 	VPMAXSW ymm  ymm ymm
// 	VPMAXSW m128 xmm xmm
// 	VPMAXSW xmm  xmm xmm
// 	VPMAXSW m512 zmm k zmm
// 	VPMAXSW m512 zmm zmm
// 	VPMAXSW zmm  zmm k zmm
// 	VPMAXSW zmm  zmm zmm
// 	VPMAXSW m128 xmm k xmm
// 	VPMAXSW m256 ymm k ymm
// 	VPMAXSW xmm  xmm k xmm
// 	VPMAXSW ymm  ymm k ymm
func VPMAXSW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMAXSW: bad operands")
}

// VPMAXSW_Z: Maximum of Packed Signed Word Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMAXSW.Z m512 zmm k zmm
// 	VPMAXSW.Z zmm  zmm k zmm
// 	VPMAXSW.Z m128 xmm k xmm
// 	VPMAXSW.Z m256 ymm k ymm
// 	VPMAXSW.Z xmm  xmm k xmm
// 	VPMAXSW.Z ymm  ymm k ymm
func VPMAXSW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMAXSW_Z: bad operands")
}

// VPMAXUB: Maximum of Packed Unsigned Byte Integers.
//
// Forms:
//
// 	VPMAXUB m256 ymm ymm
// 	VPMAXUB ymm  ymm ymm
// 	VPMAXUB m128 xmm xmm
// 	VPMAXUB xmm  xmm xmm
// 	VPMAXUB m512 zmm k zmm
// 	VPMAXUB m512 zmm zmm
// 	VPMAXUB zmm  zmm k zmm
// 	VPMAXUB zmm  zmm zmm
// 	VPMAXUB m128 xmm k xmm
// 	VPMAXUB m256 ymm k ymm
// 	VPMAXUB xmm  xmm k xmm
// 	VPMAXUB ymm  ymm k ymm
func VPMAXUB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMAXUB: bad operands")
}

// VPMAXUB_Z: Maximum of Packed Unsigned Byte Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMAXUB.Z m512 zmm k zmm
// 	VPMAXUB.Z zmm  zmm k zmm
// 	VPMAXUB.Z m128 xmm k xmm
// 	VPMAXUB.Z m256 ymm k ymm
// 	VPMAXUB.Z xmm  xmm k xmm
// 	VPMAXUB.Z ymm  ymm k ymm
func VPMAXUB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXUB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXUB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMAXUB_Z: bad operands")
}

// VPMAXUD: Maximum of Packed Unsigned Doubleword Integers.
//
// Forms:
//
// 	VPMAXUD m256 ymm ymm
// 	VPMAXUD ymm  ymm ymm
// 	VPMAXUD m128 xmm xmm
// 	VPMAXUD xmm  xmm xmm
// 	VPMAXUD m512 zmm k zmm
// 	VPMAXUD m512 zmm zmm
// 	VPMAXUD zmm  zmm k zmm
// 	VPMAXUD zmm  zmm zmm
// 	VPMAXUD m128 xmm k xmm
// 	VPMAXUD m256 ymm k ymm
// 	VPMAXUD xmm  xmm k xmm
// 	VPMAXUD ymm  ymm k ymm
func VPMAXUD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXUD: bad operands")
}

// VPMAXUD_BCST: Maximum of Packed Unsigned Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VPMAXUD.BCST m32 zmm k zmm
// 	VPMAXUD.BCST m32 zmm zmm
// 	VPMAXUD.BCST m32 xmm k xmm
// 	VPMAXUD.BCST m32 xmm xmm
// 	VPMAXUD.BCST m32 ymm k ymm
// 	VPMAXUD.BCST m32 ymm ymm
func VPMAXUD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXUD_BCST: bad operands")
}

// VPMAXUD_BCST_Z: Maximum of Packed Unsigned Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMAXUD.BCST.Z m32 zmm k zmm
// 	VPMAXUD.BCST.Z m32 xmm k xmm
// 	VPMAXUD.BCST.Z m32 ymm k ymm
func VPMAXUD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXUD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXUD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXUD_BCST_Z: bad operands")
}

// VPMAXUD_Z: Maximum of Packed Unsigned Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMAXUD.Z m512 zmm k zmm
// 	VPMAXUD.Z zmm  zmm k zmm
// 	VPMAXUD.Z m128 xmm k xmm
// 	VPMAXUD.Z m256 ymm k ymm
// 	VPMAXUD.Z xmm  xmm k xmm
// 	VPMAXUD.Z ymm  ymm k ymm
func VPMAXUD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXUD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXUD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXUD_Z: bad operands")
}

// VPMAXUQ: Maximum of Packed Unsigned Quadword Integers.
//
// Forms:
//
// 	VPMAXUQ m512 zmm k zmm
// 	VPMAXUQ m512 zmm zmm
// 	VPMAXUQ zmm  zmm k zmm
// 	VPMAXUQ zmm  zmm zmm
// 	VPMAXUQ m128 xmm k xmm
// 	VPMAXUQ m128 xmm xmm
// 	VPMAXUQ m256 ymm k ymm
// 	VPMAXUQ m256 ymm ymm
// 	VPMAXUQ xmm  xmm k xmm
// 	VPMAXUQ xmm  xmm xmm
// 	VPMAXUQ ymm  ymm k ymm
// 	VPMAXUQ ymm  ymm ymm
func VPMAXUQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXUQ: bad operands")
}

// VPMAXUQ_BCST: Maximum of Packed Unsigned Quadword Integers (Broadcast).
//
// Forms:
//
// 	VPMAXUQ.BCST m64 zmm k zmm
// 	VPMAXUQ.BCST m64 zmm zmm
// 	VPMAXUQ.BCST m64 xmm k xmm
// 	VPMAXUQ.BCST m64 xmm xmm
// 	VPMAXUQ.BCST m64 ymm k ymm
// 	VPMAXUQ.BCST m64 ymm ymm
func VPMAXUQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXUQ_BCST: bad operands")
}

// VPMAXUQ_BCST_Z: Maximum of Packed Unsigned Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMAXUQ.BCST.Z m64 zmm k zmm
// 	VPMAXUQ.BCST.Z m64 xmm k xmm
// 	VPMAXUQ.BCST.Z m64 ymm k ymm
func VPMAXUQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXUQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXUQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXUQ_BCST_Z: bad operands")
}

// VPMAXUQ_Z: Maximum of Packed Unsigned Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMAXUQ.Z m512 zmm k zmm
// 	VPMAXUQ.Z zmm  zmm k zmm
// 	VPMAXUQ.Z m128 xmm k xmm
// 	VPMAXUQ.Z m256 ymm k ymm
// 	VPMAXUQ.Z xmm  xmm k xmm
// 	VPMAXUQ.Z ymm  ymm k ymm
func VPMAXUQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXUQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXUQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMAXUQ_Z: bad operands")
}

// VPMAXUW: Maximum of Packed Unsigned Word Integers.
//
// Forms:
//
// 	VPMAXUW m256 ymm ymm
// 	VPMAXUW ymm  ymm ymm
// 	VPMAXUW m128 xmm xmm
// 	VPMAXUW xmm  xmm xmm
// 	VPMAXUW m512 zmm k zmm
// 	VPMAXUW m512 zmm zmm
// 	VPMAXUW zmm  zmm k zmm
// 	VPMAXUW zmm  zmm zmm
// 	VPMAXUW m128 xmm k xmm
// 	VPMAXUW m256 ymm k ymm
// 	VPMAXUW xmm  xmm k xmm
// 	VPMAXUW ymm  ymm k ymm
func VPMAXUW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMAXUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMAXUW: bad operands")
}

// VPMAXUW_Z: Maximum of Packed Unsigned Word Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMAXUW.Z m512 zmm k zmm
// 	VPMAXUW.Z zmm  zmm k zmm
// 	VPMAXUW.Z m128 xmm k xmm
// 	VPMAXUW.Z m256 ymm k ymm
// 	VPMAXUW.Z xmm  xmm k xmm
// 	VPMAXUW.Z ymm  ymm k ymm
func VPMAXUW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXUW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMAXUW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMAXUW_Z: bad operands")
}

// VPMINSB: Minimum of Packed Signed Byte Integers.
//
// Forms:
//
// 	VPMINSB m256 ymm ymm
// 	VPMINSB ymm  ymm ymm
// 	VPMINSB m128 xmm xmm
// 	VPMINSB xmm  xmm xmm
// 	VPMINSB m512 zmm k zmm
// 	VPMINSB m512 zmm zmm
// 	VPMINSB zmm  zmm k zmm
// 	VPMINSB zmm  zmm zmm
// 	VPMINSB m128 xmm k xmm
// 	VPMINSB m256 ymm k ymm
// 	VPMINSB xmm  xmm k xmm
// 	VPMINSB ymm  ymm k ymm
func VPMINSB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMINSB: bad operands")
}

// VPMINSB_Z: Minimum of Packed Signed Byte Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMINSB.Z m512 zmm k zmm
// 	VPMINSB.Z zmm  zmm k zmm
// 	VPMINSB.Z m128 xmm k xmm
// 	VPMINSB.Z m256 ymm k ymm
// 	VPMINSB.Z xmm  xmm k xmm
// 	VPMINSB.Z ymm  ymm k ymm
func VPMINSB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINSB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINSB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMINSB_Z: bad operands")
}

// VPMINSD: Minimum of Packed Signed Doubleword Integers.
//
// Forms:
//
// 	VPMINSD m256 ymm ymm
// 	VPMINSD ymm  ymm ymm
// 	VPMINSD m128 xmm xmm
// 	VPMINSD xmm  xmm xmm
// 	VPMINSD m512 zmm k zmm
// 	VPMINSD m512 zmm zmm
// 	VPMINSD zmm  zmm k zmm
// 	VPMINSD zmm  zmm zmm
// 	VPMINSD m128 xmm k xmm
// 	VPMINSD m256 ymm k ymm
// 	VPMINSD xmm  xmm k xmm
// 	VPMINSD ymm  ymm k ymm
func VPMINSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINSD: bad operands")
}

// VPMINSD_BCST: Minimum of Packed Signed Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VPMINSD.BCST m32 zmm k zmm
// 	VPMINSD.BCST m32 zmm zmm
// 	VPMINSD.BCST m32 xmm k xmm
// 	VPMINSD.BCST m32 xmm xmm
// 	VPMINSD.BCST m32 ymm k ymm
// 	VPMINSD.BCST m32 ymm ymm
func VPMINSD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINSD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINSD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINSD_BCST: bad operands")
}

// VPMINSD_BCST_Z: Minimum of Packed Signed Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMINSD.BCST.Z m32 zmm k zmm
// 	VPMINSD.BCST.Z m32 xmm k xmm
// 	VPMINSD.BCST.Z m32 ymm k ymm
func VPMINSD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINSD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINSD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINSD_BCST_Z: bad operands")
}

// VPMINSD_Z: Minimum of Packed Signed Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMINSD.Z m512 zmm k zmm
// 	VPMINSD.Z zmm  zmm k zmm
// 	VPMINSD.Z m128 xmm k xmm
// 	VPMINSD.Z m256 ymm k ymm
// 	VPMINSD.Z xmm  xmm k xmm
// 	VPMINSD.Z ymm  ymm k ymm
func VPMINSD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINSD_Z: bad operands")
}

// VPMINSQ: Minimum of Packed Signed Quadword Integers.
//
// Forms:
//
// 	VPMINSQ m512 zmm k zmm
// 	VPMINSQ m512 zmm zmm
// 	VPMINSQ zmm  zmm k zmm
// 	VPMINSQ zmm  zmm zmm
// 	VPMINSQ m128 xmm k xmm
// 	VPMINSQ m128 xmm xmm
// 	VPMINSQ m256 ymm k ymm
// 	VPMINSQ m256 ymm ymm
// 	VPMINSQ xmm  xmm k xmm
// 	VPMINSQ xmm  xmm xmm
// 	VPMINSQ ymm  ymm k ymm
// 	VPMINSQ ymm  ymm ymm
func VPMINSQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINSQ: bad operands")
}

// VPMINSQ_BCST: Minimum of Packed Signed Quadword Integers (Broadcast).
//
// Forms:
//
// 	VPMINSQ.BCST m64 zmm k zmm
// 	VPMINSQ.BCST m64 zmm zmm
// 	VPMINSQ.BCST m64 xmm k xmm
// 	VPMINSQ.BCST m64 xmm xmm
// 	VPMINSQ.BCST m64 ymm k ymm
// 	VPMINSQ.BCST m64 ymm ymm
func VPMINSQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINSQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINSQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINSQ_BCST: bad operands")
}

// VPMINSQ_BCST_Z: Minimum of Packed Signed Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMINSQ.BCST.Z m64 zmm k zmm
// 	VPMINSQ.BCST.Z m64 xmm k xmm
// 	VPMINSQ.BCST.Z m64 ymm k ymm
func VPMINSQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINSQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINSQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINSQ_BCST_Z: bad operands")
}

// VPMINSQ_Z: Minimum of Packed Signed Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMINSQ.Z m512 zmm k zmm
// 	VPMINSQ.Z zmm  zmm k zmm
// 	VPMINSQ.Z m128 xmm k xmm
// 	VPMINSQ.Z m256 ymm k ymm
// 	VPMINSQ.Z xmm  xmm k xmm
// 	VPMINSQ.Z ymm  ymm k ymm
func VPMINSQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINSQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINSQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINSQ_Z: bad operands")
}

// VPMINSW: Minimum of Packed Signed Word Integers.
//
// Forms:
//
// 	VPMINSW m256 ymm ymm
// 	VPMINSW ymm  ymm ymm
// 	VPMINSW m128 xmm xmm
// 	VPMINSW xmm  xmm xmm
// 	VPMINSW m512 zmm k zmm
// 	VPMINSW m512 zmm zmm
// 	VPMINSW zmm  zmm k zmm
// 	VPMINSW zmm  zmm zmm
// 	VPMINSW m128 xmm k xmm
// 	VPMINSW m256 ymm k ymm
// 	VPMINSW xmm  xmm k xmm
// 	VPMINSW ymm  ymm k ymm
func VPMINSW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMINSW: bad operands")
}

// VPMINSW_Z: Minimum of Packed Signed Word Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMINSW.Z m512 zmm k zmm
// 	VPMINSW.Z zmm  zmm k zmm
// 	VPMINSW.Z m128 xmm k xmm
// 	VPMINSW.Z m256 ymm k ymm
// 	VPMINSW.Z xmm  xmm k xmm
// 	VPMINSW.Z ymm  ymm k ymm
func VPMINSW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMINSW_Z: bad operands")
}

// VPMINUB: Minimum of Packed Unsigned Byte Integers.
//
// Forms:
//
// 	VPMINUB m256 ymm ymm
// 	VPMINUB ymm  ymm ymm
// 	VPMINUB m128 xmm xmm
// 	VPMINUB xmm  xmm xmm
// 	VPMINUB m512 zmm k zmm
// 	VPMINUB m512 zmm zmm
// 	VPMINUB zmm  zmm k zmm
// 	VPMINUB zmm  zmm zmm
// 	VPMINUB m128 xmm k xmm
// 	VPMINUB m256 ymm k ymm
// 	VPMINUB xmm  xmm k xmm
// 	VPMINUB ymm  ymm k ymm
func VPMINUB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINUB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINUB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMINUB: bad operands")
}

// VPMINUB_Z: Minimum of Packed Unsigned Byte Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMINUB.Z m512 zmm k zmm
// 	VPMINUB.Z zmm  zmm k zmm
// 	VPMINUB.Z m128 xmm k xmm
// 	VPMINUB.Z m256 ymm k ymm
// 	VPMINUB.Z xmm  xmm k xmm
// 	VPMINUB.Z ymm  ymm k ymm
func VPMINUB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINUB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINUB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMINUB_Z: bad operands")
}

// VPMINUD: Minimum of Packed Unsigned Doubleword Integers.
//
// Forms:
//
// 	VPMINUD m256 ymm ymm
// 	VPMINUD ymm  ymm ymm
// 	VPMINUD m128 xmm xmm
// 	VPMINUD xmm  xmm xmm
// 	VPMINUD m512 zmm k zmm
// 	VPMINUD m512 zmm zmm
// 	VPMINUD zmm  zmm k zmm
// 	VPMINUD zmm  zmm zmm
// 	VPMINUD m128 xmm k xmm
// 	VPMINUD m256 ymm k ymm
// 	VPMINUD xmm  xmm k xmm
// 	VPMINUD ymm  ymm k ymm
func VPMINUD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINUD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINUD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINUD: bad operands")
}

// VPMINUD_BCST: Minimum of Packed Unsigned Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VPMINUD.BCST m32 zmm k zmm
// 	VPMINUD.BCST m32 zmm zmm
// 	VPMINUD.BCST m32 xmm k xmm
// 	VPMINUD.BCST m32 xmm xmm
// 	VPMINUD.BCST m32 ymm k ymm
// 	VPMINUD.BCST m32 ymm ymm
func VPMINUD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINUD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINUD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINUD_BCST: bad operands")
}

// VPMINUD_BCST_Z: Minimum of Packed Unsigned Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMINUD.BCST.Z m32 zmm k zmm
// 	VPMINUD.BCST.Z m32 xmm k xmm
// 	VPMINUD.BCST.Z m32 ymm k ymm
func VPMINUD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINUD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINUD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINUD_BCST_Z: bad operands")
}

// VPMINUD_Z: Minimum of Packed Unsigned Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMINUD.Z m512 zmm k zmm
// 	VPMINUD.Z zmm  zmm k zmm
// 	VPMINUD.Z m128 xmm k xmm
// 	VPMINUD.Z m256 ymm k ymm
// 	VPMINUD.Z xmm  xmm k xmm
// 	VPMINUD.Z ymm  ymm k ymm
func VPMINUD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINUD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINUD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINUD_Z: bad operands")
}

// VPMINUQ: Minimum of Packed Unsigned Quadword Integers.
//
// Forms:
//
// 	VPMINUQ m512 zmm k zmm
// 	VPMINUQ m512 zmm zmm
// 	VPMINUQ zmm  zmm k zmm
// 	VPMINUQ zmm  zmm zmm
// 	VPMINUQ m128 xmm k xmm
// 	VPMINUQ m128 xmm xmm
// 	VPMINUQ m256 ymm k ymm
// 	VPMINUQ m256 ymm ymm
// 	VPMINUQ xmm  xmm k xmm
// 	VPMINUQ xmm  xmm xmm
// 	VPMINUQ ymm  ymm k ymm
// 	VPMINUQ ymm  ymm ymm
func VPMINUQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINUQ: bad operands")
}

// VPMINUQ_BCST: Minimum of Packed Unsigned Quadword Integers (Broadcast).
//
// Forms:
//
// 	VPMINUQ.BCST m64 zmm k zmm
// 	VPMINUQ.BCST m64 zmm zmm
// 	VPMINUQ.BCST m64 xmm k xmm
// 	VPMINUQ.BCST m64 xmm xmm
// 	VPMINUQ.BCST m64 ymm k ymm
// 	VPMINUQ.BCST m64 ymm ymm
func VPMINUQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINUQ_BCST: bad operands")
}

// VPMINUQ_BCST_Z: Minimum of Packed Unsigned Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMINUQ.BCST.Z m64 zmm k zmm
// 	VPMINUQ.BCST.Z m64 xmm k xmm
// 	VPMINUQ.BCST.Z m64 ymm k ymm
func VPMINUQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINUQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINUQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINUQ_BCST_Z: bad operands")
}

// VPMINUQ_Z: Minimum of Packed Unsigned Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMINUQ.Z m512 zmm k zmm
// 	VPMINUQ.Z zmm  zmm k zmm
// 	VPMINUQ.Z m128 xmm k xmm
// 	VPMINUQ.Z m256 ymm k ymm
// 	VPMINUQ.Z xmm  xmm k xmm
// 	VPMINUQ.Z ymm  ymm k ymm
func VPMINUQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINUQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINUQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMINUQ_Z: bad operands")
}

// VPMINUW: Minimum of Packed Unsigned Word Integers.
//
// Forms:
//
// 	VPMINUW m256 ymm ymm
// 	VPMINUW ymm  ymm ymm
// 	VPMINUW m128 xmm xmm
// 	VPMINUW xmm  xmm xmm
// 	VPMINUW m512 zmm k zmm
// 	VPMINUW m512 zmm zmm
// 	VPMINUW zmm  zmm k zmm
// 	VPMINUW zmm  zmm zmm
// 	VPMINUW m128 xmm k xmm
// 	VPMINUW m256 ymm k ymm
// 	VPMINUW xmm  xmm k xmm
// 	VPMINUW ymm  ymm k ymm
func VPMINUW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMINUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMINUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMINUW: bad operands")
}

// VPMINUW_Z: Minimum of Packed Unsigned Word Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMINUW.Z m512 zmm k zmm
// 	VPMINUW.Z zmm  zmm k zmm
// 	VPMINUW.Z m128 xmm k xmm
// 	VPMINUW.Z m256 ymm k ymm
// 	VPMINUW.Z xmm  xmm k xmm
// 	VPMINUW.Z ymm  ymm k ymm
func VPMINUW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINUW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMINUW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMINUW_Z: bad operands")
}

// VPMOVB2M: Move Signs of Packed Byte Integers to Mask Register.
//
// Forms:
//
// 	VPMOVB2M zmm k
// 	VPMOVB2M xmm k
// 	VPMOVB2M ymm k
func VPMOVB2M(xyz, k operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k):
		return &intrep.Instruction{
			Opcode:   "VPMOVB2M",
			Operands: []operand.Op{xyz, k},
			Inputs:   []operand.Op{xyz},
			Outputs:  []operand.Op{k},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k),
		operand.IsYMM(xyz) && operand.IsK(k):
		return &intrep.Instruction{
			Opcode:   "VPMOVB2M",
			Operands: []operand.Op{xyz, k},
			Inputs:   []operand.Op{xyz},
			Outputs:  []operand.Op{k},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMOVB2M: bad operands")
}

// VPMOVD2M: Move Signs of Packed Doubleword Integers to Mask Register.
//
// Forms:
//
// 	VPMOVD2M zmm k
// 	VPMOVD2M xmm k
// 	VPMOVD2M ymm k
func VPMOVD2M(xyz, k operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k):
		return &intrep.Instruction{
			Opcode:   "VPMOVD2M",
			Operands: []operand.Op{xyz, k},
			Inputs:   []operand.Op{xyz},
			Outputs:  []operand.Op{k},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k),
		operand.IsYMM(xyz) && operand.IsK(k):
		return &intrep.Instruction{
			Opcode:   "VPMOVD2M",
			Operands: []operand.Op{xyz, k},
			Inputs:   []operand.Op{xyz},
			Outputs:  []operand.Op{k},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VPMOVD2M: bad operands")
}

// VPMOVDB: Down Convert Packed Doubleword Values to Byte Values with Truncation.
//
// Forms:
//
// 	VPMOVDB zmm k m128
// 	VPMOVDB zmm k xmm
// 	VPMOVDB zmm m128
// 	VPMOVDB zmm xmm
// 	VPMOVDB xmm k m32
// 	VPMOVDB xmm k xmm
// 	VPMOVDB xmm m32
// 	VPMOVDB xmm xmm
// 	VPMOVDB ymm k m64
// 	VPMOVDB ymm k xmm
// 	VPMOVDB ymm m64
// 	VPMOVDB ymm xmm
func VPMOVDB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM32(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVDB: bad operands")
}

// VPMOVDB_Z: Down Convert Packed Doubleword Values to Byte Values with Truncation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVDB.Z zmm k m128
// 	VPMOVDB.Z zmm k xmm
// 	VPMOVDB.Z xmm k m32
// 	VPMOVDB.Z xmm k xmm
// 	VPMOVDB.Z ymm k m64
// 	VPMOVDB.Z ymm k xmm
func VPMOVDB_Z(xyz, k, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM128(mx),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVDB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM32(mx),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM64(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVDB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVDB_Z: bad operands")
}

// VPMOVDW: Down Convert Packed Doubleword Values to Word Values with Truncation.
//
// Forms:
//
// 	VPMOVDW zmm k m256
// 	VPMOVDW zmm k ymm
// 	VPMOVDW zmm m256
// 	VPMOVDW zmm ymm
// 	VPMOVDW xmm k m64
// 	VPMOVDW xmm k xmm
// 	VPMOVDW xmm m64
// 	VPMOVDW xmm xmm
// 	VPMOVDW ymm k m128
// 	VPMOVDW ymm k xmm
// 	VPMOVDW ymm m128
// 	VPMOVDW ymm xmm
func VPMOVDW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVDW: bad operands")
}

// VPMOVDW_Z: Down Convert Packed Doubleword Values to Word Values with Truncation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVDW.Z zmm k m256
// 	VPMOVDW.Z zmm k ymm
// 	VPMOVDW.Z xmm k m64
// 	VPMOVDW.Z xmm k xmm
// 	VPMOVDW.Z ymm k m128
// 	VPMOVDW.Z ymm k xmm
func VPMOVDW_Z(xyz, k, mxy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM256(mxy),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsYMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVDW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM64(mxy),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM128(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVDW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVDW_Z: bad operands")
}

// VPMOVM2B: Expand Bits of Mask Register to Packed Byte Integers.
//
// Forms:
//
// 	VPMOVM2B k zmm
// 	VPMOVM2B k xmm
// 	VPMOVM2B k ymm
func VPMOVM2B(k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVM2B",
			Operands: []operand.Op{k, xyz},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVM2B",
			Operands: []operand.Op{k, xyz},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMOVM2B: bad operands")
}

// VPMOVM2D: Expand Bits of Mask Register to Packed Doubleword Integers.
//
// Forms:
//
// 	VPMOVM2D k zmm
// 	VPMOVM2D k xmm
// 	VPMOVM2D k ymm
func VPMOVM2D(k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVM2D",
			Operands: []operand.Op{k, xyz},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVM2D",
			Operands: []operand.Op{k, xyz},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VPMOVM2D: bad operands")
}

// VPMOVM2Q: Expand Bits of Mask Register to Packed Quadword Integers.
//
// Forms:
//
// 	VPMOVM2Q k zmm
// 	VPMOVM2Q k xmm
// 	VPMOVM2Q k ymm
func VPMOVM2Q(k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVM2Q",
			Operands: []operand.Op{k, xyz},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVM2Q",
			Operands: []operand.Op{k, xyz},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VPMOVM2Q: bad operands")
}

// VPMOVM2W: Expand Bits of Mask Register to Packed Word Integers.
//
// Forms:
//
// 	VPMOVM2W k zmm
// 	VPMOVM2W k xmm
// 	VPMOVM2W k ymm
func VPMOVM2W(k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVM2W",
			Operands: []operand.Op{k, xyz},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVM2W",
			Operands: []operand.Op{k, xyz},
			Inputs:   []operand.Op{k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMOVM2W: bad operands")
}

// VPMOVMSKB: Move Byte Mask.
//
// Forms:
//
// 	VPMOVMSKB ymm r32
// 	VPMOVMSKB xmm r32
func VPMOVMSKB(xy, r operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(xy) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VPMOVMSKB",
			Operands: []operand.Op{xy, r},
			Inputs:   []operand.Op{xy},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsYMM(xy) && operand.IsR32(r):
		return &intrep.Instruction{
			Opcode:   "VPMOVMSKB",
			Operands: []operand.Op{xy, r},
			Inputs:   []operand.Op{xy},
			Outputs:  []operand.Op{r},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPMOVMSKB: bad operands")
}

// VPMOVQ2M: Move Signs of Packed Quadword Integers to Mask Register.
//
// Forms:
//
// 	VPMOVQ2M zmm k
// 	VPMOVQ2M xmm k
// 	VPMOVQ2M ymm k
func VPMOVQ2M(xyz, k operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k):
		return &intrep.Instruction{
			Opcode:   "VPMOVQ2M",
			Operands: []operand.Op{xyz, k},
			Inputs:   []operand.Op{xyz},
			Outputs:  []operand.Op{k},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k),
		operand.IsYMM(xyz) && operand.IsK(k):
		return &intrep.Instruction{
			Opcode:   "VPMOVQ2M",
			Operands: []operand.Op{xyz, k},
			Inputs:   []operand.Op{xyz},
			Outputs:  []operand.Op{k},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VPMOVQ2M: bad operands")
}

// VPMOVQB: Down Convert Packed Quadword Values to Byte Values with Truncation.
//
// Forms:
//
// 	VPMOVQB zmm k m64
// 	VPMOVQB zmm k xmm
// 	VPMOVQB zmm m64
// 	VPMOVQB zmm xmm
// 	VPMOVQB xmm k m16
// 	VPMOVQB xmm k xmm
// 	VPMOVQB xmm m16
// 	VPMOVQB xmm xmm
// 	VPMOVQB ymm k m32
// 	VPMOVQB ymm k xmm
// 	VPMOVQB ymm m32
// 	VPMOVQB ymm xmm
func VPMOVQB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM16(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM32(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM16(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVQB: bad operands")
}

// VPMOVQB_Z: Down Convert Packed Quadword Values to Byte Values with Truncation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVQB.Z zmm k m64
// 	VPMOVQB.Z zmm k xmm
// 	VPMOVQB.Z xmm k m16
// 	VPMOVQB.Z xmm k xmm
// 	VPMOVQB.Z ymm k m32
// 	VPMOVQB.Z ymm k xmm
func VPMOVQB_Z(xyz, k, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM64(mx),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVQB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM16(mx),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM32(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVQB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVQB_Z: bad operands")
}

// VPMOVQD: Down Convert Packed Quadword Values to Doubleword Values with Truncation.
//
// Forms:
//
// 	VPMOVQD zmm k m256
// 	VPMOVQD zmm k ymm
// 	VPMOVQD zmm m256
// 	VPMOVQD zmm ymm
// 	VPMOVQD xmm k m64
// 	VPMOVQD xmm k xmm
// 	VPMOVQD xmm m64
// 	VPMOVQD xmm xmm
// 	VPMOVQD ymm k m128
// 	VPMOVQD ymm k xmm
// 	VPMOVQD ymm m128
// 	VPMOVQD ymm xmm
func VPMOVQD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVQD: bad operands")
}

// VPMOVQD_Z: Down Convert Packed Quadword Values to Doubleword Values with Truncation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVQD.Z zmm k m256
// 	VPMOVQD.Z zmm k ymm
// 	VPMOVQD.Z xmm k m64
// 	VPMOVQD.Z xmm k xmm
// 	VPMOVQD.Z ymm k m128
// 	VPMOVQD.Z ymm k xmm
func VPMOVQD_Z(xyz, k, mxy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM256(mxy),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsYMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVQD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM64(mxy),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM128(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVQD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVQD_Z: bad operands")
}

// VPMOVQW: Down Convert Packed Quadword Values to Word Values with Truncation.
//
// Forms:
//
// 	VPMOVQW zmm k m128
// 	VPMOVQW zmm k xmm
// 	VPMOVQW zmm m128
// 	VPMOVQW zmm xmm
// 	VPMOVQW xmm k m32
// 	VPMOVQW xmm k xmm
// 	VPMOVQW xmm m32
// 	VPMOVQW xmm xmm
// 	VPMOVQW ymm k m64
// 	VPMOVQW ymm k xmm
// 	VPMOVQW ymm m64
// 	VPMOVQW ymm xmm
func VPMOVQW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM32(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVQW: bad operands")
}

// VPMOVQW_Z: Down Convert Packed Quadword Values to Word Values with Truncation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVQW.Z zmm k m128
// 	VPMOVQW.Z zmm k xmm
// 	VPMOVQW.Z xmm k m32
// 	VPMOVQW.Z xmm k xmm
// 	VPMOVQW.Z ymm k m64
// 	VPMOVQW.Z ymm k xmm
func VPMOVQW_Z(xyz, k, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM128(mx),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVQW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM32(mx),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM64(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVQW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVQW_Z: bad operands")
}

// VPMOVSDB: Down Convert Packed Doubleword Values to Byte Values with Signed Saturation.
//
// Forms:
//
// 	VPMOVSDB zmm k m128
// 	VPMOVSDB zmm k xmm
// 	VPMOVSDB zmm m128
// 	VPMOVSDB zmm xmm
// 	VPMOVSDB xmm k m32
// 	VPMOVSDB xmm k xmm
// 	VPMOVSDB xmm m32
// 	VPMOVSDB xmm xmm
// 	VPMOVSDB ymm k m64
// 	VPMOVSDB ymm k xmm
// 	VPMOVSDB ymm m64
// 	VPMOVSDB ymm xmm
func VPMOVSDB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM32(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSDB: bad operands")
}

// VPMOVSDB_Z: Down Convert Packed Doubleword Values to Byte Values with Signed Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVSDB.Z zmm k m128
// 	VPMOVSDB.Z zmm k xmm
// 	VPMOVSDB.Z xmm k m32
// 	VPMOVSDB.Z xmm k xmm
// 	VPMOVSDB.Z ymm k m64
// 	VPMOVSDB.Z ymm k xmm
func VPMOVSDB_Z(xyz, k, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM128(mx),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVSDB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM32(mx),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM64(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVSDB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSDB_Z: bad operands")
}

// VPMOVSDW: Down Convert Packed Doubleword Values to Word Values with Signed Saturation.
//
// Forms:
//
// 	VPMOVSDW zmm k m256
// 	VPMOVSDW zmm k ymm
// 	VPMOVSDW zmm m256
// 	VPMOVSDW zmm ymm
// 	VPMOVSDW xmm k m64
// 	VPMOVSDW xmm k xmm
// 	VPMOVSDW xmm m64
// 	VPMOVSDW xmm xmm
// 	VPMOVSDW ymm k m128
// 	VPMOVSDW ymm k xmm
// 	VPMOVSDW ymm m128
// 	VPMOVSDW ymm xmm
func VPMOVSDW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSDW: bad operands")
}

// VPMOVSDW_Z: Down Convert Packed Doubleword Values to Word Values with Signed Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVSDW.Z zmm k m256
// 	VPMOVSDW.Z zmm k ymm
// 	VPMOVSDW.Z xmm k m64
// 	VPMOVSDW.Z xmm k xmm
// 	VPMOVSDW.Z ymm k m128
// 	VPMOVSDW.Z ymm k xmm
func VPMOVSDW_Z(xyz, k, mxy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM256(mxy),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsYMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVSDW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM64(mxy),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM128(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVSDW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSDW_Z: bad operands")
}

// VPMOVSQB: Down Convert Packed Quadword Values to Byte Values with Signed Saturation.
//
// Forms:
//
// 	VPMOVSQB zmm k m64
// 	VPMOVSQB zmm k xmm
// 	VPMOVSQB zmm m64
// 	VPMOVSQB zmm xmm
// 	VPMOVSQB xmm k m16
// 	VPMOVSQB xmm k xmm
// 	VPMOVSQB xmm m16
// 	VPMOVSQB xmm xmm
// 	VPMOVSQB ymm k m32
// 	VPMOVSQB ymm k xmm
// 	VPMOVSQB ymm m32
// 	VPMOVSQB ymm xmm
func VPMOVSQB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM16(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM32(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM16(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSQB: bad operands")
}

// VPMOVSQB_Z: Down Convert Packed Quadword Values to Byte Values with Signed Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVSQB.Z zmm k m64
// 	VPMOVSQB.Z zmm k xmm
// 	VPMOVSQB.Z xmm k m16
// 	VPMOVSQB.Z xmm k xmm
// 	VPMOVSQB.Z ymm k m32
// 	VPMOVSQB.Z ymm k xmm
func VPMOVSQB_Z(xyz, k, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM64(mx),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM16(mx),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM32(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSQB_Z: bad operands")
}

// VPMOVSQD: Down Convert Packed Quadword Values to Doubleword Values with Signed Saturation.
//
// Forms:
//
// 	VPMOVSQD zmm k m256
// 	VPMOVSQD zmm k ymm
// 	VPMOVSQD zmm m256
// 	VPMOVSQD zmm ymm
// 	VPMOVSQD xmm k m64
// 	VPMOVSQD xmm k xmm
// 	VPMOVSQD xmm m64
// 	VPMOVSQD xmm xmm
// 	VPMOVSQD ymm k m128
// 	VPMOVSQD ymm k xmm
// 	VPMOVSQD ymm m128
// 	VPMOVSQD ymm xmm
func VPMOVSQD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSQD: bad operands")
}

// VPMOVSQD_Z: Down Convert Packed Quadword Values to Doubleword Values with Signed Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVSQD.Z zmm k m256
// 	VPMOVSQD.Z zmm k ymm
// 	VPMOVSQD.Z xmm k m64
// 	VPMOVSQD.Z xmm k xmm
// 	VPMOVSQD.Z ymm k m128
// 	VPMOVSQD.Z ymm k xmm
func VPMOVSQD_Z(xyz, k, mxy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM256(mxy),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsYMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM64(mxy),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM128(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSQD_Z: bad operands")
}

// VPMOVSQW: Down Convert Packed Quadword Values to Word Values with Signed Saturation.
//
// Forms:
//
// 	VPMOVSQW zmm k m128
// 	VPMOVSQW zmm k xmm
// 	VPMOVSQW zmm m128
// 	VPMOVSQW zmm xmm
// 	VPMOVSQW xmm k m32
// 	VPMOVSQW xmm k xmm
// 	VPMOVSQW xmm m32
// 	VPMOVSQW xmm xmm
// 	VPMOVSQW ymm k m64
// 	VPMOVSQW ymm k xmm
// 	VPMOVSQW ymm m64
// 	VPMOVSQW ymm xmm
func VPMOVSQW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM32(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSQW: bad operands")
}

// VPMOVSQW_Z: Down Convert Packed Quadword Values to Word Values with Signed Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVSQW.Z zmm k m128
// 	VPMOVSQW.Z zmm k xmm
// 	VPMOVSQW.Z xmm k m32
// 	VPMOVSQW.Z xmm k xmm
// 	VPMOVSQW.Z ymm k m64
// 	VPMOVSQW.Z ymm k xmm
func VPMOVSQW_Z(xyz, k, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM128(mx),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM32(mx),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM64(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVSQW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSQW_Z: bad operands")
}

// VPMOVSWB: Down Convert Packed Word Values to Byte Values with Signed Saturation.
//
// Forms:
//
// 	VPMOVSWB zmm k m256
// 	VPMOVSWB zmm k ymm
// 	VPMOVSWB zmm m256
// 	VPMOVSWB zmm ymm
// 	VPMOVSWB xmm k m64
// 	VPMOVSWB xmm k xmm
// 	VPMOVSWB xmm m64
// 	VPMOVSWB xmm xmm
// 	VPMOVSWB ymm k m128
// 	VPMOVSWB ymm k xmm
// 	VPMOVSWB ymm m128
// 	VPMOVSWB ymm xmm
func VPMOVSWB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMOVSWB: bad operands")
}

// VPMOVSWB_Z: Down Convert Packed Word Values to Byte Values with Signed Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVSWB.Z zmm k m256
// 	VPMOVSWB.Z zmm k ymm
// 	VPMOVSWB.Z xmm k m64
// 	VPMOVSWB.Z xmm k xmm
// 	VPMOVSWB.Z ymm k m128
// 	VPMOVSWB.Z ymm k xmm
func VPMOVSWB_Z(xyz, k, mxy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM256(mxy),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsYMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVSWB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM64(mxy),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM128(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVSWB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMOVSWB_Z: bad operands")
}

// VPMOVSXBD: Move Packed Byte Integers to Doubleword Integers with Sign Extension.
//
// Forms:
//
// 	VPMOVSXBD m64  ymm
// 	VPMOVSXBD xmm  ymm
// 	VPMOVSXBD m32  xmm
// 	VPMOVSXBD xmm  xmm
// 	VPMOVSXBD m128 k zmm
// 	VPMOVSXBD m128 zmm
// 	VPMOVSXBD xmm  k zmm
// 	VPMOVSXBD xmm  zmm
// 	VPMOVSXBD m32  k xmm
// 	VPMOVSXBD m64  k ymm
// 	VPMOVSXBD xmm  k xmm
// 	VPMOVSXBD xmm  k ymm
func VPMOVSXBD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSXBD: bad operands")
}

// VPMOVSXBD_Z: Move Packed Byte Integers to Doubleword Integers with Sign Extension (Zeroing Masking).
//
// Forms:
//
// 	VPMOVSXBD.Z m128 k zmm
// 	VPMOVSXBD.Z xmm  k zmm
// 	VPMOVSXBD.Z m32  k xmm
// 	VPMOVSXBD.Z m64  k ymm
// 	VPMOVSXBD.Z xmm  k xmm
// 	VPMOVSXBD.Z xmm  k ymm
func VPMOVSXBD_Z(mx, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, xyz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(mx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(mx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, xyz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSXBD_Z: bad operands")
}

// VPMOVSXBQ: Move Packed Byte Integers to Quadword Integers with Sign Extension.
//
// Forms:
//
// 	VPMOVSXBQ m32 ymm
// 	VPMOVSXBQ xmm ymm
// 	VPMOVSXBQ m16 xmm
// 	VPMOVSXBQ xmm xmm
// 	VPMOVSXBQ m64 k zmm
// 	VPMOVSXBQ m64 zmm
// 	VPMOVSXBQ xmm k zmm
// 	VPMOVSXBQ xmm zmm
// 	VPMOVSXBQ m16 k xmm
// 	VPMOVSXBQ m32 k ymm
// 	VPMOVSXBQ xmm k xmm
// 	VPMOVSXBQ xmm k ymm
func VPMOVSXBQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM16(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM16(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSXBQ: bad operands")
}

// VPMOVSXBQ_Z: Move Packed Byte Integers to Quadword Integers with Sign Extension (Zeroing Masking).
//
// Forms:
//
// 	VPMOVSXBQ.Z m64 k zmm
// 	VPMOVSXBQ.Z xmm k zmm
// 	VPMOVSXBQ.Z m16 k xmm
// 	VPMOVSXBQ.Z m32 k ymm
// 	VPMOVSXBQ.Z xmm k xmm
// 	VPMOVSXBQ.Z xmm k ymm
func VPMOVSXBQ_Z(mx, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, xyz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM16(mx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(mx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, xyz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSXBQ_Z: bad operands")
}

// VPMOVSXBW: Move Packed Byte Integers to Word Integers with Sign Extension.
//
// Forms:
//
// 	VPMOVSXBW m128 ymm
// 	VPMOVSXBW xmm  ymm
// 	VPMOVSXBW m64  xmm
// 	VPMOVSXBW xmm  xmm
// 	VPMOVSXBW m256 k zmm
// 	VPMOVSXBW m256 zmm
// 	VPMOVSXBW ymm  k zmm
// 	VPMOVSXBW ymm  zmm
// 	VPMOVSXBW m128 k ymm
// 	VPMOVSXBW m64  k xmm
// 	VPMOVSXBW xmm  k xmm
// 	VPMOVSXBW xmm  k ymm
func VPMOVSXBW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMOVSXBW: bad operands")
}

// VPMOVSXBW_Z: Move Packed Byte Integers to Word Integers with Sign Extension (Zeroing Masking).
//
// Forms:
//
// 	VPMOVSXBW.Z m256 k zmm
// 	VPMOVSXBW.Z ymm  k zmm
// 	VPMOVSXBW.Z m128 k ymm
// 	VPMOVSXBW.Z m64  k xmm
// 	VPMOVSXBW.Z xmm  k xmm
// 	VPMOVSXBW.Z xmm  k ymm
func VPMOVSXBW_Z(mxy, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(mxy) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsYMM(mxy) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxy) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsM64(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXBW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMOVSXBW_Z: bad operands")
}

// VPMOVSXDQ: Move Packed Doubleword Integers to Quadword Integers with Sign Extension.
//
// Forms:
//
// 	VPMOVSXDQ m128 ymm
// 	VPMOVSXDQ xmm  ymm
// 	VPMOVSXDQ m64  xmm
// 	VPMOVSXDQ xmm  xmm
// 	VPMOVSXDQ m256 k zmm
// 	VPMOVSXDQ m256 zmm
// 	VPMOVSXDQ ymm  k zmm
// 	VPMOVSXDQ ymm  zmm
// 	VPMOVSXDQ m128 k ymm
// 	VPMOVSXDQ m64  k xmm
// 	VPMOVSXDQ xmm  k xmm
// 	VPMOVSXDQ xmm  k ymm
func VPMOVSXDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSXDQ: bad operands")
}

// VPMOVSXDQ_Z: Move Packed Doubleword Integers to Quadword Integers with Sign Extension (Zeroing Masking).
//
// Forms:
//
// 	VPMOVSXDQ.Z m256 k zmm
// 	VPMOVSXDQ.Z ymm  k zmm
// 	VPMOVSXDQ.Z m128 k ymm
// 	VPMOVSXDQ.Z m64  k xmm
// 	VPMOVSXDQ.Z xmm  k xmm
// 	VPMOVSXDQ.Z xmm  k ymm
func VPMOVSXDQ_Z(mxy, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(mxy) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsYMM(mxy) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxy) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsM64(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSXDQ_Z: bad operands")
}

// VPMOVSXWD: Move Packed Word Integers to Doubleword Integers with Sign Extension.
//
// Forms:
//
// 	VPMOVSXWD m128 ymm
// 	VPMOVSXWD xmm  ymm
// 	VPMOVSXWD m64  xmm
// 	VPMOVSXWD xmm  xmm
// 	VPMOVSXWD m256 k zmm
// 	VPMOVSXWD m256 zmm
// 	VPMOVSXWD ymm  k zmm
// 	VPMOVSXWD ymm  zmm
// 	VPMOVSXWD m128 k ymm
// 	VPMOVSXWD m64  k xmm
// 	VPMOVSXWD xmm  k xmm
// 	VPMOVSXWD xmm  k ymm
func VPMOVSXWD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSXWD: bad operands")
}

// VPMOVSXWD_Z: Move Packed Word Integers to Doubleword Integers with Sign Extension (Zeroing Masking).
//
// Forms:
//
// 	VPMOVSXWD.Z m256 k zmm
// 	VPMOVSXWD.Z ymm  k zmm
// 	VPMOVSXWD.Z m128 k ymm
// 	VPMOVSXWD.Z m64  k xmm
// 	VPMOVSXWD.Z xmm  k xmm
// 	VPMOVSXWD.Z xmm  k ymm
func VPMOVSXWD_Z(mxy, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(mxy) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsYMM(mxy) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXWD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxy) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsM64(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXWD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSXWD_Z: bad operands")
}

// VPMOVSXWQ: Move Packed Word Integers to Quadword Integers with Sign Extension.
//
// Forms:
//
// 	VPMOVSXWQ m64  ymm
// 	VPMOVSXWQ xmm  ymm
// 	VPMOVSXWQ m32  xmm
// 	VPMOVSXWQ xmm  xmm
// 	VPMOVSXWQ m128 k zmm
// 	VPMOVSXWQ m128 zmm
// 	VPMOVSXWQ xmm  k zmm
// 	VPMOVSXWQ xmm  zmm
// 	VPMOVSXWQ m32  k xmm
// 	VPMOVSXWQ m64  k ymm
// 	VPMOVSXWQ xmm  k xmm
// 	VPMOVSXWQ xmm  k ymm
func VPMOVSXWQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXWQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXWQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXWQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXWQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXWQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSXWQ: bad operands")
}

// VPMOVSXWQ_Z: Move Packed Word Integers to Quadword Integers with Sign Extension (Zeroing Masking).
//
// Forms:
//
// 	VPMOVSXWQ.Z m128 k zmm
// 	VPMOVSXWQ.Z xmm  k zmm
// 	VPMOVSXWQ.Z m32  k xmm
// 	VPMOVSXWQ.Z m64  k ymm
// 	VPMOVSXWQ.Z xmm  k xmm
// 	VPMOVSXWQ.Z xmm  k ymm
func VPMOVSXWQ_Z(mx, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXWQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, xyz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(mx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(mx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVSXWQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, xyz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVSXWQ_Z: bad operands")
}

// VPMOVUSDB: Down Convert Packed Doubleword Values to Byte Values with Unsigned Saturation.
//
// Forms:
//
// 	VPMOVUSDB zmm k m128
// 	VPMOVUSDB zmm k xmm
// 	VPMOVUSDB zmm m128
// 	VPMOVUSDB zmm xmm
// 	VPMOVUSDB xmm k m32
// 	VPMOVUSDB xmm k xmm
// 	VPMOVUSDB xmm m32
// 	VPMOVUSDB xmm xmm
// 	VPMOVUSDB ymm k m64
// 	VPMOVUSDB ymm k xmm
// 	VPMOVUSDB ymm m64
// 	VPMOVUSDB ymm xmm
func VPMOVUSDB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM32(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSDB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVUSDB: bad operands")
}

// VPMOVUSDB_Z: Down Convert Packed Doubleword Values to Byte Values with Unsigned Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVUSDB.Z zmm k m128
// 	VPMOVUSDB.Z zmm k xmm
// 	VPMOVUSDB.Z xmm k m32
// 	VPMOVUSDB.Z xmm k xmm
// 	VPMOVUSDB.Z ymm k m64
// 	VPMOVUSDB.Z ymm k xmm
func VPMOVUSDB_Z(xyz, k, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM128(mx),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSDB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM32(mx),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM64(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSDB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVUSDB_Z: bad operands")
}

// VPMOVUSDW: Down Convert Packed Doubleword Values to Word Values with Unsigned Saturation.
//
// Forms:
//
// 	VPMOVUSDW zmm k m256
// 	VPMOVUSDW zmm k ymm
// 	VPMOVUSDW zmm m256
// 	VPMOVUSDW zmm ymm
// 	VPMOVUSDW xmm k m64
// 	VPMOVUSDW xmm k xmm
// 	VPMOVUSDW xmm m64
// 	VPMOVUSDW xmm xmm
// 	VPMOVUSDW ymm k m128
// 	VPMOVUSDW ymm k xmm
// 	VPMOVUSDW ymm m128
// 	VPMOVUSDW ymm xmm
func VPMOVUSDW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSDW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVUSDW: bad operands")
}

// VPMOVUSDW_Z: Down Convert Packed Doubleword Values to Word Values with Unsigned Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVUSDW.Z zmm k m256
// 	VPMOVUSDW.Z zmm k ymm
// 	VPMOVUSDW.Z xmm k m64
// 	VPMOVUSDW.Z xmm k xmm
// 	VPMOVUSDW.Z ymm k m128
// 	VPMOVUSDW.Z ymm k xmm
func VPMOVUSDW_Z(xyz, k, mxy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM256(mxy),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsYMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSDW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM64(mxy),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM128(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSDW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVUSDW_Z: bad operands")
}

// VPMOVUSQB: Down Convert Packed Quadword Values to Byte Values with Unsigned Saturation.
//
// Forms:
//
// 	VPMOVUSQB zmm k m64
// 	VPMOVUSQB zmm k xmm
// 	VPMOVUSQB zmm m64
// 	VPMOVUSQB zmm xmm
// 	VPMOVUSQB xmm k m16
// 	VPMOVUSQB xmm k xmm
// 	VPMOVUSQB xmm m16
// 	VPMOVUSQB xmm xmm
// 	VPMOVUSQB ymm k m32
// 	VPMOVUSQB ymm k xmm
// 	VPMOVUSQB ymm m32
// 	VPMOVUSQB ymm xmm
func VPMOVUSQB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM16(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM32(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM16(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVUSQB: bad operands")
}

// VPMOVUSQB_Z: Down Convert Packed Quadword Values to Byte Values with Unsigned Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVUSQB.Z zmm k m64
// 	VPMOVUSQB.Z zmm k xmm
// 	VPMOVUSQB.Z xmm k m16
// 	VPMOVUSQB.Z xmm k xmm
// 	VPMOVUSQB.Z ymm k m32
// 	VPMOVUSQB.Z ymm k xmm
func VPMOVUSQB_Z(xyz, k, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM64(mx),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM16(mx),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM32(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVUSQB_Z: bad operands")
}

// VPMOVUSQD: Down Convert Packed Quadword Values to Doubleword Values with Unsigned Saturation.
//
// Forms:
//
// 	VPMOVUSQD zmm k m256
// 	VPMOVUSQD zmm k ymm
// 	VPMOVUSQD zmm m256
// 	VPMOVUSQD zmm ymm
// 	VPMOVUSQD xmm k m64
// 	VPMOVUSQD xmm k xmm
// 	VPMOVUSQD xmm m64
// 	VPMOVUSQD xmm xmm
// 	VPMOVUSQD ymm k m128
// 	VPMOVUSQD ymm k xmm
// 	VPMOVUSQD ymm m128
// 	VPMOVUSQD ymm xmm
func VPMOVUSQD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVUSQD: bad operands")
}

// VPMOVUSQD_Z: Down Convert Packed Quadword Values to Doubleword Values with Unsigned Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVUSQD.Z zmm k m256
// 	VPMOVUSQD.Z zmm k ymm
// 	VPMOVUSQD.Z xmm k m64
// 	VPMOVUSQD.Z xmm k xmm
// 	VPMOVUSQD.Z ymm k m128
// 	VPMOVUSQD.Z ymm k xmm
func VPMOVUSQD_Z(xyz, k, mxy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM256(mxy),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsYMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM64(mxy),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM128(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVUSQD_Z: bad operands")
}

// VPMOVUSQW: Down Convert Packed Quadword Values to Word Values with Unsigned Saturation.
//
// Forms:
//
// 	VPMOVUSQW zmm k m128
// 	VPMOVUSQW zmm k xmm
// 	VPMOVUSQW zmm m128
// 	VPMOVUSQW zmm xmm
// 	VPMOVUSQW xmm k m32
// 	VPMOVUSQW xmm k xmm
// 	VPMOVUSQW xmm m32
// 	VPMOVUSQW xmm xmm
// 	VPMOVUSQW ymm k m64
// 	VPMOVUSQW ymm k xmm
// 	VPMOVUSQW ymm m64
// 	VPMOVUSQW ymm xmm
func VPMOVUSQW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM32(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM32(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVUSQW: bad operands")
}

// VPMOVUSQW_Z: Down Convert Packed Quadword Values to Word Values with Unsigned Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVUSQW.Z zmm k m128
// 	VPMOVUSQW.Z zmm k xmm
// 	VPMOVUSQW.Z xmm k m32
// 	VPMOVUSQW.Z xmm k xmm
// 	VPMOVUSQW.Z ymm k m64
// 	VPMOVUSQW.Z ymm k xmm
func VPMOVUSQW_Z(xyz, k, mx operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM128(mx),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM32(mx),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM64(mx),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mx):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSQW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mx},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mx},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVUSQW_Z: bad operands")
}

// VPMOVUSWB: Down Convert Packed Word Values to Byte Values with Unsigned Saturation.
//
// Forms:
//
// 	VPMOVUSWB zmm k m256
// 	VPMOVUSWB zmm k ymm
// 	VPMOVUSWB zmm m256
// 	VPMOVUSWB zmm ymm
// 	VPMOVUSWB xmm k m64
// 	VPMOVUSWB xmm k xmm
// 	VPMOVUSWB xmm m64
// 	VPMOVUSWB xmm xmm
// 	VPMOVUSWB ymm k m128
// 	VPMOVUSWB ymm k xmm
// 	VPMOVUSWB ymm m128
// 	VPMOVUSWB ymm xmm
func VPMOVUSWB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMOVUSWB: bad operands")
}

// VPMOVUSWB_Z: Down Convert Packed Word Values to Byte Values with Unsigned Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVUSWB.Z zmm k m256
// 	VPMOVUSWB.Z zmm k ymm
// 	VPMOVUSWB.Z xmm k m64
// 	VPMOVUSWB.Z xmm k xmm
// 	VPMOVUSWB.Z ymm k m128
// 	VPMOVUSWB.Z ymm k xmm
func VPMOVUSWB_Z(xyz, k, mxy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM256(mxy),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsYMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSWB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM64(mxy),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM128(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVUSWB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMOVUSWB_Z: bad operands")
}

// VPMOVW2M: Move Signs of Packed Word Integers to Mask Register.
//
// Forms:
//
// 	VPMOVW2M zmm k
// 	VPMOVW2M xmm k
// 	VPMOVW2M ymm k
func VPMOVW2M(xyz, k operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k):
		return &intrep.Instruction{
			Opcode:   "VPMOVW2M",
			Operands: []operand.Op{xyz, k},
			Inputs:   []operand.Op{xyz},
			Outputs:  []operand.Op{k},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k),
		operand.IsYMM(xyz) && operand.IsK(k):
		return &intrep.Instruction{
			Opcode:   "VPMOVW2M",
			Operands: []operand.Op{xyz, k},
			Inputs:   []operand.Op{xyz},
			Outputs:  []operand.Op{k},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMOVW2M: bad operands")
}

// VPMOVWB: Down Convert Packed Word Values to Byte Values with Truncation.
//
// Forms:
//
// 	VPMOVWB zmm k m256
// 	VPMOVWB zmm k ymm
// 	VPMOVWB zmm m256
// 	VPMOVWB zmm ymm
// 	VPMOVWB xmm k m64
// 	VPMOVWB xmm k xmm
// 	VPMOVWB xmm m64
// 	VPMOVWB xmm xmm
// 	VPMOVWB ymm k m128
// 	VPMOVWB ymm k xmm
// 	VPMOVWB ymm m128
// 	VPMOVWB ymm xmm
func VPMOVWB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM256(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM64(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsM128(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsM256(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsM64(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsM128(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVWB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMOVWB: bad operands")
}

// VPMOVWB_Z: Down Convert Packed Word Values to Byte Values with Truncation (Zeroing Masking).
//
// Forms:
//
// 	VPMOVWB.Z zmm k m256
// 	VPMOVWB.Z zmm k ymm
// 	VPMOVWB.Z xmm k m64
// 	VPMOVWB.Z xmm k xmm
// 	VPMOVWB.Z ymm k m128
// 	VPMOVWB.Z ymm k xmm
func VPMOVWB_Z(xyz, k, mxy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsM256(mxy),
		operand.IsZMM(xyz) && operand.IsK(k) && operand.IsYMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVWB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsM64(mxy),
		operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsM128(mxy),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsXMM(mxy):
		return &intrep.Instruction{
			Opcode:   "VPMOVWB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{xyz, k, mxy},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{mxy},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMOVWB_Z: bad operands")
}

// VPMOVZXBD: Move Packed Byte Integers to Doubleword Integers with Zero Extension.
//
// Forms:
//
// 	VPMOVZXBD m64  ymm
// 	VPMOVZXBD xmm  ymm
// 	VPMOVZXBD m32  xmm
// 	VPMOVZXBD xmm  xmm
// 	VPMOVZXBD m128 k zmm
// 	VPMOVZXBD m128 zmm
// 	VPMOVZXBD xmm  k zmm
// 	VPMOVZXBD xmm  zmm
// 	VPMOVZXBD m32  k xmm
// 	VPMOVZXBD m64  k ymm
// 	VPMOVZXBD xmm  k xmm
// 	VPMOVZXBD xmm  k ymm
func VPMOVZXBD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVZXBD: bad operands")
}

// VPMOVZXBD_Z: Move Packed Byte Integers to Doubleword Integers with Zero Extension (Zeroing Masking).
//
// Forms:
//
// 	VPMOVZXBD.Z m128 k zmm
// 	VPMOVZXBD.Z xmm  k zmm
// 	VPMOVZXBD.Z m32  k xmm
// 	VPMOVZXBD.Z m64  k ymm
// 	VPMOVZXBD.Z xmm  k xmm
// 	VPMOVZXBD.Z xmm  k ymm
func VPMOVZXBD_Z(mx, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, xyz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(mx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(mx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, xyz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVZXBD_Z: bad operands")
}

// VPMOVZXBQ: Move Packed Byte Integers to Quadword Integers with Zero Extension.
//
// Forms:
//
// 	VPMOVZXBQ m32 ymm
// 	VPMOVZXBQ xmm ymm
// 	VPMOVZXBQ m16 xmm
// 	VPMOVZXBQ xmm xmm
// 	VPMOVZXBQ m64 k zmm
// 	VPMOVZXBQ m64 zmm
// 	VPMOVZXBQ xmm k zmm
// 	VPMOVZXBQ xmm zmm
// 	VPMOVZXBQ m16 k xmm
// 	VPMOVZXBQ m32 k ymm
// 	VPMOVZXBQ xmm k xmm
// 	VPMOVZXBQ xmm k ymm
func VPMOVZXBQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM16(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM16(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVZXBQ: bad operands")
}

// VPMOVZXBQ_Z: Move Packed Byte Integers to Quadword Integers with Zero Extension (Zeroing Masking).
//
// Forms:
//
// 	VPMOVZXBQ.Z m64 k zmm
// 	VPMOVZXBQ.Z xmm k zmm
// 	VPMOVZXBQ.Z m16 k xmm
// 	VPMOVZXBQ.Z m32 k ymm
// 	VPMOVZXBQ.Z xmm k xmm
// 	VPMOVZXBQ.Z xmm k ymm
func VPMOVZXBQ_Z(mx, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, xyz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM16(mx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(mx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, xyz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVZXBQ_Z: bad operands")
}

// VPMOVZXBW: Move Packed Byte Integers to Word Integers with Zero Extension.
//
// Forms:
//
// 	VPMOVZXBW m128 ymm
// 	VPMOVZXBW xmm  ymm
// 	VPMOVZXBW m64  xmm
// 	VPMOVZXBW xmm  xmm
// 	VPMOVZXBW m256 k zmm
// 	VPMOVZXBW m256 zmm
// 	VPMOVZXBW ymm  k zmm
// 	VPMOVZXBW ymm  zmm
// 	VPMOVZXBW m128 k ymm
// 	VPMOVZXBW m64  k xmm
// 	VPMOVZXBW xmm  k xmm
// 	VPMOVZXBW xmm  k ymm
func VPMOVZXBW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMOVZXBW: bad operands")
}

// VPMOVZXBW_Z: Move Packed Byte Integers to Word Integers with Zero Extension (Zeroing Masking).
//
// Forms:
//
// 	VPMOVZXBW.Z m256 k zmm
// 	VPMOVZXBW.Z ymm  k zmm
// 	VPMOVZXBW.Z m128 k ymm
// 	VPMOVZXBW.Z m64  k xmm
// 	VPMOVZXBW.Z xmm  k xmm
// 	VPMOVZXBW.Z xmm  k ymm
func VPMOVZXBW_Z(mxy, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(mxy) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsYMM(mxy) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxy) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsM64(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXBW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMOVZXBW_Z: bad operands")
}

// VPMOVZXDQ: Move Packed Doubleword Integers to Quadword Integers with Zero Extension.
//
// Forms:
//
// 	VPMOVZXDQ m128 ymm
// 	VPMOVZXDQ xmm  ymm
// 	VPMOVZXDQ m64  xmm
// 	VPMOVZXDQ xmm  xmm
// 	VPMOVZXDQ m256 k zmm
// 	VPMOVZXDQ m256 zmm
// 	VPMOVZXDQ ymm  k zmm
// 	VPMOVZXDQ ymm  zmm
// 	VPMOVZXDQ m128 k ymm
// 	VPMOVZXDQ m64  k xmm
// 	VPMOVZXDQ xmm  k xmm
// 	VPMOVZXDQ xmm  k ymm
func VPMOVZXDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVZXDQ: bad operands")
}

// VPMOVZXDQ_Z: Move Packed Doubleword Integers to Quadword Integers with Zero Extension (Zeroing Masking).
//
// Forms:
//
// 	VPMOVZXDQ.Z m256 k zmm
// 	VPMOVZXDQ.Z ymm  k zmm
// 	VPMOVZXDQ.Z m128 k ymm
// 	VPMOVZXDQ.Z m64  k xmm
// 	VPMOVZXDQ.Z xmm  k xmm
// 	VPMOVZXDQ.Z xmm  k ymm
func VPMOVZXDQ_Z(mxy, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(mxy) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsYMM(mxy) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxy) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsM64(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVZXDQ_Z: bad operands")
}

// VPMOVZXWD: Move Packed Word Integers to Doubleword Integers with Zero Extension.
//
// Forms:
//
// 	VPMOVZXWD m128 ymm
// 	VPMOVZXWD xmm  ymm
// 	VPMOVZXWD m64  xmm
// 	VPMOVZXWD xmm  xmm
// 	VPMOVZXWD m256 k zmm
// 	VPMOVZXWD m256 zmm
// 	VPMOVZXWD ymm  k zmm
// 	VPMOVZXWD ymm  zmm
// 	VPMOVZXWD m128 k ymm
// 	VPMOVZXWD m64  k xmm
// 	VPMOVZXWD xmm  k xmm
// 	VPMOVZXWD xmm  k ymm
func VPMOVZXWD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVZXWD: bad operands")
}

// VPMOVZXWD_Z: Move Packed Word Integers to Doubleword Integers with Zero Extension (Zeroing Masking).
//
// Forms:
//
// 	VPMOVZXWD.Z m256 k zmm
// 	VPMOVZXWD.Z ymm  k zmm
// 	VPMOVZXWD.Z m128 k ymm
// 	VPMOVZXWD.Z m64  k xmm
// 	VPMOVZXWD.Z xmm  k xmm
// 	VPMOVZXWD.Z xmm  k ymm
func VPMOVZXWD_Z(mxy, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM256(mxy) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsYMM(mxy) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXWD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxy) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsM64(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mxy) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXWD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxy, k, xyz},
			Inputs:   []operand.Op{mxy, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVZXWD_Z: bad operands")
}

// VPMOVZXWQ: Move Packed Word Integers to Quadword Integers with Zero Extension.
//
// Forms:
//
// 	VPMOVZXWQ m64  ymm
// 	VPMOVZXWQ xmm  ymm
// 	VPMOVZXWQ m32  xmm
// 	VPMOVZXWQ xmm  xmm
// 	VPMOVZXWQ m128 k zmm
// 	VPMOVZXWQ m128 zmm
// 	VPMOVZXWQ xmm  k zmm
// 	VPMOVZXWQ xmm  zmm
// 	VPMOVZXWQ m32  k xmm
// 	VPMOVZXWQ m64  k ymm
// 	VPMOVZXWQ xmm  k xmm
// 	VPMOVZXWQ xmm  k ymm
func VPMOVZXWQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXWQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXWQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXWQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXWQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXWQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVZXWQ: bad operands")
}

// VPMOVZXWQ_Z: Move Packed Word Integers to Quadword Integers with Zero Extension (Zeroing Masking).
//
// Forms:
//
// 	VPMOVZXWQ.Z m128 k zmm
// 	VPMOVZXWQ.Z xmm  k zmm
// 	VPMOVZXWQ.Z m32  k xmm
// 	VPMOVZXWQ.Z m64  k ymm
// 	VPMOVZXWQ.Z xmm  k xmm
// 	VPMOVZXWQ.Z xmm  k ymm
func VPMOVZXWQ_Z(mx, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mx) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXWQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, xyz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(mx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(mx) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(mx) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPMOVZXWQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, k, xyz},
			Inputs:   []operand.Op{mx, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMOVZXWQ_Z: bad operands")
}

// VPMULDQ: Multiply Packed Signed Doubleword Integers and Store Quadword Result.
//
// Forms:
//
// 	VPMULDQ m256 ymm ymm
// 	VPMULDQ ymm  ymm ymm
// 	VPMULDQ m128 xmm xmm
// 	VPMULDQ xmm  xmm xmm
// 	VPMULDQ m512 zmm k zmm
// 	VPMULDQ m512 zmm zmm
// 	VPMULDQ zmm  zmm k zmm
// 	VPMULDQ zmm  zmm zmm
// 	VPMULDQ m128 xmm k xmm
// 	VPMULDQ m256 ymm k ymm
// 	VPMULDQ xmm  xmm k xmm
// 	VPMULDQ ymm  ymm k ymm
func VPMULDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMULDQ: bad operands")
}

// VPMULDQ_BCST: Multiply Packed Signed Doubleword Integers and Store Quadword Result (Broadcast).
//
// Forms:
//
// 	VPMULDQ.BCST m64 zmm k zmm
// 	VPMULDQ.BCST m64 zmm zmm
// 	VPMULDQ.BCST m64 xmm k xmm
// 	VPMULDQ.BCST m64 xmm xmm
// 	VPMULDQ.BCST m64 ymm k ymm
// 	VPMULDQ.BCST m64 ymm ymm
func VPMULDQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMULDQ_BCST: bad operands")
}

// VPMULDQ_BCST_Z: Multiply Packed Signed Doubleword Integers and Store Quadword Result (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMULDQ.BCST.Z m64 zmm k zmm
// 	VPMULDQ.BCST.Z m64 xmm k xmm
// 	VPMULDQ.BCST.Z m64 ymm k ymm
func VPMULDQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMULDQ_BCST_Z: bad operands")
}

// VPMULDQ_Z: Multiply Packed Signed Doubleword Integers and Store Quadword Result (Zeroing Masking).
//
// Forms:
//
// 	VPMULDQ.Z m512 zmm k zmm
// 	VPMULDQ.Z zmm  zmm k zmm
// 	VPMULDQ.Z m128 xmm k xmm
// 	VPMULDQ.Z m256 ymm k ymm
// 	VPMULDQ.Z xmm  xmm k xmm
// 	VPMULDQ.Z ymm  ymm k ymm
func VPMULDQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMULDQ_Z: bad operands")
}

// VPMULHRSW: Packed Multiply Signed Word Integers and Store High Result with Round and Scale.
//
// Forms:
//
// 	VPMULHRSW m256 ymm ymm
// 	VPMULHRSW ymm  ymm ymm
// 	VPMULHRSW m128 xmm xmm
// 	VPMULHRSW xmm  xmm xmm
// 	VPMULHRSW m512 zmm k zmm
// 	VPMULHRSW m512 zmm zmm
// 	VPMULHRSW zmm  zmm k zmm
// 	VPMULHRSW zmm  zmm zmm
// 	VPMULHRSW m128 xmm k xmm
// 	VPMULHRSW m256 ymm k ymm
// 	VPMULHRSW xmm  xmm k xmm
// 	VPMULHRSW ymm  ymm k ymm
func VPMULHRSW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULHRSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULHRSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULHRSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULHRSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULHRSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMULHRSW: bad operands")
}

// VPMULHRSW_Z: Packed Multiply Signed Word Integers and Store High Result with Round and Scale (Zeroing Masking).
//
// Forms:
//
// 	VPMULHRSW.Z m512 zmm k zmm
// 	VPMULHRSW.Z zmm  zmm k zmm
// 	VPMULHRSW.Z m128 xmm k xmm
// 	VPMULHRSW.Z m256 ymm k ymm
// 	VPMULHRSW.Z xmm  xmm k xmm
// 	VPMULHRSW.Z ymm  ymm k ymm
func VPMULHRSW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULHRSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULHRSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMULHRSW_Z: bad operands")
}

// VPMULHUW: Multiply Packed Unsigned Word Integers and Store High Result.
//
// Forms:
//
// 	VPMULHUW m256 ymm ymm
// 	VPMULHUW ymm  ymm ymm
// 	VPMULHUW m128 xmm xmm
// 	VPMULHUW xmm  xmm xmm
// 	VPMULHUW m512 zmm k zmm
// 	VPMULHUW m512 zmm zmm
// 	VPMULHUW zmm  zmm k zmm
// 	VPMULHUW zmm  zmm zmm
// 	VPMULHUW m128 xmm k xmm
// 	VPMULHUW m256 ymm k ymm
// 	VPMULHUW xmm  xmm k xmm
// 	VPMULHUW ymm  ymm k ymm
func VPMULHUW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULHUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULHUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULHUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULHUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULHUW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMULHUW: bad operands")
}

// VPMULHUW_Z: Multiply Packed Unsigned Word Integers and Store High Result (Zeroing Masking).
//
// Forms:
//
// 	VPMULHUW.Z m512 zmm k zmm
// 	VPMULHUW.Z zmm  zmm k zmm
// 	VPMULHUW.Z m128 xmm k xmm
// 	VPMULHUW.Z m256 ymm k ymm
// 	VPMULHUW.Z xmm  xmm k xmm
// 	VPMULHUW.Z ymm  ymm k ymm
func VPMULHUW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULHUW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULHUW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMULHUW_Z: bad operands")
}

// VPMULHW: Multiply Packed Signed Word Integers and Store High Result.
//
// Forms:
//
// 	VPMULHW m256 ymm ymm
// 	VPMULHW ymm  ymm ymm
// 	VPMULHW m128 xmm xmm
// 	VPMULHW xmm  xmm xmm
// 	VPMULHW m512 zmm k zmm
// 	VPMULHW m512 zmm zmm
// 	VPMULHW zmm  zmm k zmm
// 	VPMULHW zmm  zmm zmm
// 	VPMULHW m128 xmm k xmm
// 	VPMULHW m256 ymm k ymm
// 	VPMULHW xmm  xmm k xmm
// 	VPMULHW ymm  ymm k ymm
func VPMULHW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULHW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULHW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULHW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULHW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULHW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMULHW: bad operands")
}

// VPMULHW_Z: Multiply Packed Signed Word Integers and Store High Result (Zeroing Masking).
//
// Forms:
//
// 	VPMULHW.Z m512 zmm k zmm
// 	VPMULHW.Z zmm  zmm k zmm
// 	VPMULHW.Z m128 xmm k xmm
// 	VPMULHW.Z m256 ymm k ymm
// 	VPMULHW.Z xmm  xmm k xmm
// 	VPMULHW.Z ymm  ymm k ymm
func VPMULHW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULHW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULHW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMULHW_Z: bad operands")
}

// VPMULLD: Multiply Packed Signed Doubleword Integers and Store Low Result.
//
// Forms:
//
// 	VPMULLD m256 ymm ymm
// 	VPMULLD ymm  ymm ymm
// 	VPMULLD m128 xmm xmm
// 	VPMULLD xmm  xmm xmm
// 	VPMULLD m512 zmm k zmm
// 	VPMULLD m512 zmm zmm
// 	VPMULLD zmm  zmm k zmm
// 	VPMULLD zmm  zmm zmm
// 	VPMULLD m128 xmm k xmm
// 	VPMULLD m256 ymm k ymm
// 	VPMULLD xmm  xmm k xmm
// 	VPMULLD ymm  ymm k ymm
func VPMULLD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMULLD: bad operands")
}

// VPMULLD_BCST: Multiply Packed Signed Doubleword Integers and Store Low Result (Broadcast).
//
// Forms:
//
// 	VPMULLD.BCST m32 zmm k zmm
// 	VPMULLD.BCST m32 zmm zmm
// 	VPMULLD.BCST m32 xmm k xmm
// 	VPMULLD.BCST m32 xmm xmm
// 	VPMULLD.BCST m32 ymm k ymm
// 	VPMULLD.BCST m32 ymm ymm
func VPMULLD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMULLD_BCST: bad operands")
}

// VPMULLD_BCST_Z: Multiply Packed Signed Doubleword Integers and Store Low Result (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMULLD.BCST.Z m32 zmm k zmm
// 	VPMULLD.BCST.Z m32 xmm k xmm
// 	VPMULLD.BCST.Z m32 ymm k ymm
func VPMULLD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULLD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULLD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMULLD_BCST_Z: bad operands")
}

// VPMULLD_Z: Multiply Packed Signed Doubleword Integers and Store Low Result (Zeroing Masking).
//
// Forms:
//
// 	VPMULLD.Z m512 zmm k zmm
// 	VPMULLD.Z zmm  zmm k zmm
// 	VPMULLD.Z m128 xmm k xmm
// 	VPMULLD.Z m256 ymm k ymm
// 	VPMULLD.Z xmm  xmm k xmm
// 	VPMULLD.Z ymm  ymm k ymm
func VPMULLD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULLD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULLD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMULLD_Z: bad operands")
}

// VPMULLQ: Multiply Packed Signed Quadword Integers and Store Low Result.
//
// Forms:
//
// 	VPMULLQ m512 zmm k zmm
// 	VPMULLQ m512 zmm zmm
// 	VPMULLQ zmm  zmm k zmm
// 	VPMULLQ zmm  zmm zmm
// 	VPMULLQ m128 xmm k xmm
// 	VPMULLQ m128 xmm xmm
// 	VPMULLQ m256 ymm k ymm
// 	VPMULLQ m256 ymm ymm
// 	VPMULLQ xmm  xmm k xmm
// 	VPMULLQ xmm  xmm xmm
// 	VPMULLQ ymm  ymm k ymm
// 	VPMULLQ ymm  ymm ymm
func VPMULLQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VPMULLQ: bad operands")
}

// VPMULLQ_BCST: Multiply Packed Signed Quadword Integers and Store Low Result (Broadcast).
//
// Forms:
//
// 	VPMULLQ.BCST m64 zmm k zmm
// 	VPMULLQ.BCST m64 zmm zmm
// 	VPMULLQ.BCST m64 xmm k xmm
// 	VPMULLQ.BCST m64 xmm xmm
// 	VPMULLQ.BCST m64 ymm k ymm
// 	VPMULLQ.BCST m64 ymm ymm
func VPMULLQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VPMULLQ_BCST: bad operands")
}

// VPMULLQ_BCST_Z: Multiply Packed Signed Quadword Integers and Store Low Result (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMULLQ.BCST.Z m64 zmm k zmm
// 	VPMULLQ.BCST.Z m64 xmm k xmm
// 	VPMULLQ.BCST.Z m64 ymm k ymm
func VPMULLQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULLQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULLQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VPMULLQ_BCST_Z: bad operands")
}

// VPMULLQ_Z: Multiply Packed Signed Quadword Integers and Store Low Result (Zeroing Masking).
//
// Forms:
//
// 	VPMULLQ.Z m512 zmm k zmm
// 	VPMULLQ.Z zmm  zmm k zmm
// 	VPMULLQ.Z m128 xmm k xmm
// 	VPMULLQ.Z m256 ymm k ymm
// 	VPMULLQ.Z xmm  xmm k xmm
// 	VPMULLQ.Z ymm  ymm k ymm
func VPMULLQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULLQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULLQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VPMULLQ_Z: bad operands")
}

// VPMULLW: Multiply Packed Signed Word Integers and Store Low Result.
//
// Forms:
//
// 	VPMULLW m256 ymm ymm
// 	VPMULLW ymm  ymm ymm
// 	VPMULLW m128 xmm xmm
// 	VPMULLW xmm  xmm xmm
// 	VPMULLW m512 zmm k zmm
// 	VPMULLW m512 zmm zmm
// 	VPMULLW zmm  zmm k zmm
// 	VPMULLW zmm  zmm zmm
// 	VPMULLW m128 xmm k xmm
// 	VPMULLW m256 ymm k ymm
// 	VPMULLW xmm  xmm k xmm
// 	VPMULLW ymm  ymm k ymm
func VPMULLW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMULLW: bad operands")
}

// VPMULLW_Z: Multiply Packed Signed Word Integers and Store Low Result (Zeroing Masking).
//
// Forms:
//
// 	VPMULLW.Z m512 zmm k zmm
// 	VPMULLW.Z zmm  zmm k zmm
// 	VPMULLW.Z m128 xmm k xmm
// 	VPMULLW.Z m256 ymm k ymm
// 	VPMULLW.Z xmm  xmm k xmm
// 	VPMULLW.Z ymm  ymm k ymm
func VPMULLW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULLW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULLW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPMULLW_Z: bad operands")
}

// VPMULTISHIFTQB: Select Packed Unaligned Bytes from Quadword Sources.
//
// Forms:
//
// 	VPMULTISHIFTQB m128 xmm k xmm
// 	VPMULTISHIFTQB m128 xmm xmm
// 	VPMULTISHIFTQB m256 ymm k ymm
// 	VPMULTISHIFTQB m256 ymm ymm
// 	VPMULTISHIFTQB xmm  xmm k xmm
// 	VPMULTISHIFTQB xmm  xmm xmm
// 	VPMULTISHIFTQB ymm  ymm k ymm
// 	VPMULTISHIFTQB ymm  ymm ymm
// 	VPMULTISHIFTQB m512 zmm k zmm
// 	VPMULTISHIFTQB m512 zmm zmm
// 	VPMULTISHIFTQB zmm  zmm k zmm
// 	VPMULTISHIFTQB zmm  zmm zmm
func VPMULTISHIFTQB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULTISHIFTQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VBMI", "AVX512VL"},
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULTISHIFTQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULTISHIFTQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VBMI", "AVX512VL"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULTISHIFTQB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	}
	return nil, errors.New("VPMULTISHIFTQB: bad operands")
}

// VPMULTISHIFTQB_BCST: Select Packed Unaligned Bytes from Quadword Sources (Broadcast).
//
// Forms:
//
// 	VPMULTISHIFTQB.BCST m64 xmm k xmm
// 	VPMULTISHIFTQB.BCST m64 xmm xmm
// 	VPMULTISHIFTQB.BCST m64 ymm k ymm
// 	VPMULTISHIFTQB.BCST m64 ymm ymm
// 	VPMULTISHIFTQB.BCST m64 zmm k zmm
// 	VPMULTISHIFTQB.BCST m64 zmm zmm
func VPMULTISHIFTQB_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULTISHIFTQB",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VBMI", "AVX512VL"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULTISHIFTQB",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULTISHIFTQB",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VBMI", "AVX512VL"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULTISHIFTQB",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	}
	return nil, errors.New("VPMULTISHIFTQB_BCST: bad operands")
}

// VPMULTISHIFTQB_BCST_Z: Select Packed Unaligned Bytes from Quadword Sources (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMULTISHIFTQB.BCST.Z m64 xmm k xmm
// 	VPMULTISHIFTQB.BCST.Z m64 ymm k ymm
// 	VPMULTISHIFTQB.BCST.Z m64 zmm k zmm
func VPMULTISHIFTQB_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULTISHIFTQB",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VBMI", "AVX512VL"},
		}, nil
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULTISHIFTQB",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	}
	return nil, errors.New("VPMULTISHIFTQB_BCST_Z: bad operands")
}

// VPMULTISHIFTQB_Z: Select Packed Unaligned Bytes from Quadword Sources (Zeroing Masking).
//
// Forms:
//
// 	VPMULTISHIFTQB.Z m128 xmm k xmm
// 	VPMULTISHIFTQB.Z m256 ymm k ymm
// 	VPMULTISHIFTQB.Z xmm  xmm k xmm
// 	VPMULTISHIFTQB.Z ymm  ymm k ymm
// 	VPMULTISHIFTQB.Z m512 zmm k zmm
// 	VPMULTISHIFTQB.Z zmm  zmm k zmm
func VPMULTISHIFTQB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULTISHIFTQB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VBMI", "AVX512VL"},
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULTISHIFTQB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VBMI"},
		}, nil
	}
	return nil, errors.New("VPMULTISHIFTQB_Z: bad operands")
}

// VPMULUDQ: Multiply Packed Unsigned Doubleword Integers.
//
// Forms:
//
// 	VPMULUDQ m256 ymm ymm
// 	VPMULUDQ ymm  ymm ymm
// 	VPMULUDQ m128 xmm xmm
// 	VPMULUDQ xmm  xmm xmm
// 	VPMULUDQ m512 zmm k zmm
// 	VPMULUDQ m512 zmm zmm
// 	VPMULUDQ zmm  zmm k zmm
// 	VPMULUDQ zmm  zmm zmm
// 	VPMULUDQ m128 xmm k xmm
// 	VPMULUDQ m256 ymm k ymm
// 	VPMULUDQ xmm  xmm k xmm
// 	VPMULUDQ ymm  ymm k ymm
func VPMULUDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULUDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULUDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULUDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULUDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULUDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMULUDQ: bad operands")
}

// VPMULUDQ_BCST: Multiply Packed Unsigned Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VPMULUDQ.BCST m64 zmm k zmm
// 	VPMULUDQ.BCST m64 zmm zmm
// 	VPMULUDQ.BCST m64 xmm k xmm
// 	VPMULUDQ.BCST m64 xmm xmm
// 	VPMULUDQ.BCST m64 ymm k ymm
// 	VPMULUDQ.BCST m64 ymm ymm
func VPMULUDQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULUDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPMULUDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULUDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPMULUDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMULUDQ_BCST: bad operands")
}

// VPMULUDQ_BCST_Z: Multiply Packed Unsigned Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPMULUDQ.BCST.Z m64 zmm k zmm
// 	VPMULUDQ.BCST.Z m64 xmm k xmm
// 	VPMULUDQ.BCST.Z m64 ymm k ymm
func VPMULUDQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULUDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULUDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMULUDQ_BCST_Z: bad operands")
}

// VPMULUDQ_Z: Multiply Packed Unsigned Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPMULUDQ.Z m512 zmm k zmm
// 	VPMULUDQ.Z zmm  zmm k zmm
// 	VPMULUDQ.Z m128 xmm k xmm
// 	VPMULUDQ.Z m256 ymm k ymm
// 	VPMULUDQ.Z xmm  xmm k xmm
// 	VPMULUDQ.Z ymm  ymm k ymm
func VPMULUDQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULUDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPMULUDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPMULUDQ_Z: bad operands")
}

// VPOPCNTD: Packed Population Count for Doubleword Integers.
//
// Forms:
//
// 	VPOPCNTD m512 k zmm
// 	VPOPCNTD m512 zmm
// 	VPOPCNTD zmm  k zmm
// 	VPOPCNTD zmm  zmm
func VPOPCNTD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPOPCNTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VPOPCNTDQ"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPOPCNTD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VPOPCNTDQ"},
		}, nil
	}
	return nil, errors.New("VPOPCNTD: bad operands")
}

// VPOPCNTD_BCST: Packed Population Count for Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VPOPCNTD.BCST m32 k zmm
// 	VPOPCNTD.BCST m32 zmm
func VPOPCNTD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPOPCNTD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VPOPCNTDQ"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPOPCNTD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VPOPCNTDQ"},
		}, nil
	}
	return nil, errors.New("VPOPCNTD_BCST: bad operands")
}

// VPOPCNTD_BCST_Z: Packed Population Count for Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPOPCNTD.BCST.Z m32 k zmm
func VPOPCNTD_BCST_Z(m, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VPOPCNTD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, z},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512VPOPCNTDQ"},
		}, nil
	}
	return nil, errors.New("VPOPCNTD_BCST_Z: bad operands")
}

// VPOPCNTD_Z: Packed Population Count for Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPOPCNTD.Z m512 k zmm
// 	VPOPCNTD.Z zmm  k zmm
func VPOPCNTD_Z(mz, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsZMM(z),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VPOPCNTD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, z},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512VPOPCNTDQ"},
		}, nil
	}
	return nil, errors.New("VPOPCNTD_Z: bad operands")
}

// VPOPCNTQ: Packed Population Count for Quadword Integers.
//
// Forms:
//
// 	VPOPCNTQ m512 k zmm
// 	VPOPCNTQ m512 zmm
// 	VPOPCNTQ zmm  k zmm
// 	VPOPCNTQ zmm  zmm
func VPOPCNTQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPOPCNTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VPOPCNTDQ"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPOPCNTQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VPOPCNTDQ"},
		}, nil
	}
	return nil, errors.New("VPOPCNTQ: bad operands")
}

// VPOPCNTQ_BCST: Packed Population Count for Quadword Integers (Broadcast).
//
// Forms:
//
// 	VPOPCNTQ.BCST m64 k zmm
// 	VPOPCNTQ.BCST m64 zmm
func VPOPCNTQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPOPCNTQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VPOPCNTDQ"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VPOPCNTQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VPOPCNTDQ"},
		}, nil
	}
	return nil, errors.New("VPOPCNTQ_BCST: bad operands")
}

// VPOPCNTQ_BCST_Z: Packed Population Count for Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPOPCNTQ.BCST.Z m64 k zmm
func VPOPCNTQ_BCST_Z(m, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VPOPCNTQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, z},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512VPOPCNTDQ"},
		}, nil
	}
	return nil, errors.New("VPOPCNTQ_BCST_Z: bad operands")
}

// VPOPCNTQ_Z: Packed Population Count for Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPOPCNTQ.Z m512 k zmm
// 	VPOPCNTQ.Z zmm  k zmm
func VPOPCNTQ_Z(mz, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsZMM(z),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VPOPCNTQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, z},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512VPOPCNTDQ"},
		}, nil
	}
	return nil, errors.New("VPOPCNTQ_Z: bad operands")
}

// VPOR: Packed Bitwise Logical OR.
//
// Forms:
//
// 	VPOR m256 ymm ymm
// 	VPOR ymm  ymm ymm
// 	VPOR m128 xmm xmm
// 	VPOR xmm  xmm xmm
func VPOR(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPOR",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPOR",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPOR: bad operands")
}

// VPORD: Bitwise Logical OR of Packed Doubleword Integers.
//
// Forms:
//
// 	VPORD m512 zmm k zmm
// 	VPORD m512 zmm zmm
// 	VPORD zmm  zmm k zmm
// 	VPORD zmm  zmm zmm
// 	VPORD m128 xmm k xmm
// 	VPORD m128 xmm xmm
// 	VPORD m256 ymm k ymm
// 	VPORD m256 ymm ymm
// 	VPORD xmm  xmm k xmm
// 	VPORD xmm  xmm xmm
// 	VPORD ymm  ymm k ymm
// 	VPORD ymm  ymm ymm
func VPORD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPORD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPORD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPORD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPORD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPORD: bad operands")
}

// VPORD_BCST: Bitwise Logical OR of Packed Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VPORD.BCST m32 zmm k zmm
// 	VPORD.BCST m32 zmm zmm
// 	VPORD.BCST m32 xmm k xmm
// 	VPORD.BCST m32 xmm xmm
// 	VPORD.BCST m32 ymm k ymm
// 	VPORD.BCST m32 ymm ymm
func VPORD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPORD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPORD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPORD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPORD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPORD_BCST: bad operands")
}

// VPORD_BCST_Z: Bitwise Logical OR of Packed Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPORD.BCST.Z m32 zmm k zmm
// 	VPORD.BCST.Z m32 xmm k xmm
// 	VPORD.BCST.Z m32 ymm k ymm
func VPORD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPORD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPORD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPORD_BCST_Z: bad operands")
}

// VPORD_Z: Bitwise Logical OR of Packed Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPORD.Z m512 zmm k zmm
// 	VPORD.Z zmm  zmm k zmm
// 	VPORD.Z m128 xmm k xmm
// 	VPORD.Z m256 ymm k ymm
// 	VPORD.Z xmm  xmm k xmm
// 	VPORD.Z ymm  ymm k ymm
func VPORD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPORD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPORD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPORD_Z: bad operands")
}

// VPORQ: Bitwise Logical OR of Packed Quadword Integers.
//
// Forms:
//
// 	VPORQ m512 zmm k zmm
// 	VPORQ m512 zmm zmm
// 	VPORQ zmm  zmm k zmm
// 	VPORQ zmm  zmm zmm
// 	VPORQ m128 xmm k xmm
// 	VPORQ m128 xmm xmm
// 	VPORQ m256 ymm k ymm
// 	VPORQ m256 ymm ymm
// 	VPORQ xmm  xmm k xmm
// 	VPORQ xmm  xmm xmm
// 	VPORQ ymm  ymm k ymm
// 	VPORQ ymm  ymm ymm
func VPORQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPORQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPORQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPORQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPORQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPORQ: bad operands")
}

// VPORQ_BCST: Bitwise Logical OR of Packed Quadword Integers (Broadcast).
//
// Forms:
//
// 	VPORQ.BCST m64 zmm k zmm
// 	VPORQ.BCST m64 zmm zmm
// 	VPORQ.BCST m64 xmm k xmm
// 	VPORQ.BCST m64 xmm xmm
// 	VPORQ.BCST m64 ymm k ymm
// 	VPORQ.BCST m64 ymm ymm
func VPORQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPORQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPORQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPORQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPORQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPORQ_BCST: bad operands")
}

// VPORQ_BCST_Z: Bitwise Logical OR of Packed Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPORQ.BCST.Z m64 zmm k zmm
// 	VPORQ.BCST.Z m64 xmm k xmm
// 	VPORQ.BCST.Z m64 ymm k ymm
func VPORQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPORQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPORQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPORQ_BCST_Z: bad operands")
}

// VPORQ_Z: Bitwise Logical OR of Packed Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPORQ.Z m512 zmm k zmm
// 	VPORQ.Z zmm  zmm k zmm
// 	VPORQ.Z m128 xmm k xmm
// 	VPORQ.Z m256 ymm k ymm
// 	VPORQ.Z xmm  xmm k xmm
// 	VPORQ.Z ymm  ymm k ymm
func VPORQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPORQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPORQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPORQ_Z: bad operands")
}

// VPROLD: Rotate Packed Doubleword Left.
//
// Forms:
//
// 	VPROLD imm8 m512 k zmm
// 	VPROLD imm8 m512 zmm
// 	VPROLD imm8 zmm  k zmm
// 	VPROLD imm8 zmm  zmm
// 	VPROLD imm8 m128 k xmm
// 	VPROLD imm8 m128 xmm
// 	VPROLD imm8 m256 k ymm
// 	VPROLD imm8 m256 ymm
// 	VPROLD imm8 xmm  k xmm
// 	VPROLD imm8 xmm  xmm
// 	VPROLD imm8 ymm  k ymm
// 	VPROLD imm8 ymm  ymm
func VPROLD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLD: bad operands")
}

// VPROLD_BCST: Rotate Packed Doubleword Left (Broadcast).
//
// Forms:
//
// 	VPROLD.BCST imm8 m32 k zmm
// 	VPROLD.BCST imm8 m32 zmm
// 	VPROLD.BCST imm8 m32 k xmm
// 	VPROLD.BCST imm8 m32 k ymm
// 	VPROLD.BCST imm8 m32 xmm
// 	VPROLD.BCST imm8 m32 ymm
func VPROLD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLD_BCST: bad operands")
}

// VPROLD_BCST_Z: Rotate Packed Doubleword Left (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPROLD.BCST.Z imm8 m32 k zmm
// 	VPROLD.BCST.Z imm8 m32 k xmm
// 	VPROLD.BCST.Z imm8 m32 k ymm
func VPROLD_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPROLD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPROLD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLD_BCST_Z: bad operands")
}

// VPROLD_Z: Rotate Packed Doubleword Left (Zeroing Masking).
//
// Forms:
//
// 	VPROLD.Z imm8 m512 k zmm
// 	VPROLD.Z imm8 zmm  k zmm
// 	VPROLD.Z imm8 m128 k xmm
// 	VPROLD.Z imm8 m256 k ymm
// 	VPROLD.Z imm8 xmm  k xmm
// 	VPROLD.Z imm8 ymm  k ymm
func VPROLD_Z(i, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPROLD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPROLD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLD_Z: bad operands")
}

// VPROLQ: Rotate Packed Quadword Left.
//
// Forms:
//
// 	VPROLQ imm8 m512 k zmm
// 	VPROLQ imm8 m512 zmm
// 	VPROLQ imm8 zmm  k zmm
// 	VPROLQ imm8 zmm  zmm
// 	VPROLQ imm8 m128 k xmm
// 	VPROLQ imm8 m128 xmm
// 	VPROLQ imm8 m256 k ymm
// 	VPROLQ imm8 m256 ymm
// 	VPROLQ imm8 xmm  k xmm
// 	VPROLQ imm8 xmm  xmm
// 	VPROLQ imm8 ymm  k ymm
// 	VPROLQ imm8 ymm  ymm
func VPROLQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLQ: bad operands")
}

// VPROLQ_BCST: Rotate Packed Quadword Left (Broadcast).
//
// Forms:
//
// 	VPROLQ.BCST imm8 m64 k zmm
// 	VPROLQ.BCST imm8 m64 zmm
// 	VPROLQ.BCST imm8 m64 k xmm
// 	VPROLQ.BCST imm8 m64 k ymm
// 	VPROLQ.BCST imm8 m64 xmm
// 	VPROLQ.BCST imm8 m64 ymm
func VPROLQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLQ_BCST: bad operands")
}

// VPROLQ_BCST_Z: Rotate Packed Quadword Left (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPROLQ.BCST.Z imm8 m64 k zmm
// 	VPROLQ.BCST.Z imm8 m64 k xmm
// 	VPROLQ.BCST.Z imm8 m64 k ymm
func VPROLQ_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPROLQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPROLQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLQ_BCST_Z: bad operands")
}

// VPROLQ_Z: Rotate Packed Quadword Left (Zeroing Masking).
//
// Forms:
//
// 	VPROLQ.Z imm8 m512 k zmm
// 	VPROLQ.Z imm8 zmm  k zmm
// 	VPROLQ.Z imm8 m128 k xmm
// 	VPROLQ.Z imm8 m256 k ymm
// 	VPROLQ.Z imm8 xmm  k xmm
// 	VPROLQ.Z imm8 ymm  k ymm
func VPROLQ_Z(i, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPROLQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPROLQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLQ_Z: bad operands")
}

// VPROLVD: Variable Rotate Packed Doubleword Left.
//
// Forms:
//
// 	VPROLVD m512 zmm k zmm
// 	VPROLVD m512 zmm zmm
// 	VPROLVD zmm  zmm k zmm
// 	VPROLVD zmm  zmm zmm
// 	VPROLVD m128 xmm k xmm
// 	VPROLVD m128 xmm xmm
// 	VPROLVD m256 ymm k ymm
// 	VPROLVD m256 ymm ymm
// 	VPROLVD xmm  xmm k xmm
// 	VPROLVD xmm  xmm xmm
// 	VPROLVD ymm  ymm k ymm
// 	VPROLVD ymm  ymm ymm
func VPROLVD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLVD: bad operands")
}

// VPROLVD_BCST: Variable Rotate Packed Doubleword Left (Broadcast).
//
// Forms:
//
// 	VPROLVD.BCST m32 zmm k zmm
// 	VPROLVD.BCST m32 zmm zmm
// 	VPROLVD.BCST m32 xmm k xmm
// 	VPROLVD.BCST m32 xmm xmm
// 	VPROLVD.BCST m32 ymm k ymm
// 	VPROLVD.BCST m32 ymm ymm
func VPROLVD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLVD_BCST: bad operands")
}

// VPROLVD_BCST_Z: Variable Rotate Packed Doubleword Left (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPROLVD.BCST.Z m32 zmm k zmm
// 	VPROLVD.BCST.Z m32 xmm k xmm
// 	VPROLVD.BCST.Z m32 ymm k ymm
func VPROLVD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPROLVD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPROLVD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLVD_BCST_Z: bad operands")
}

// VPROLVD_Z: Variable Rotate Packed Doubleword Left (Zeroing Masking).
//
// Forms:
//
// 	VPROLVD.Z m512 zmm k zmm
// 	VPROLVD.Z zmm  zmm k zmm
// 	VPROLVD.Z m128 xmm k xmm
// 	VPROLVD.Z m256 ymm k ymm
// 	VPROLVD.Z xmm  xmm k xmm
// 	VPROLVD.Z ymm  ymm k ymm
func VPROLVD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPROLVD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPROLVD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLVD_Z: bad operands")
}

// VPROLVQ: Variable Rotate Packed Quadword Left.
//
// Forms:
//
// 	VPROLVQ m512 zmm k zmm
// 	VPROLVQ m512 zmm zmm
// 	VPROLVQ zmm  zmm k zmm
// 	VPROLVQ zmm  zmm zmm
// 	VPROLVQ m128 xmm k xmm
// 	VPROLVQ m128 xmm xmm
// 	VPROLVQ m256 ymm k ymm
// 	VPROLVQ m256 ymm ymm
// 	VPROLVQ xmm  xmm k xmm
// 	VPROLVQ xmm  xmm xmm
// 	VPROLVQ ymm  ymm k ymm
// 	VPROLVQ ymm  ymm ymm
func VPROLVQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLVQ: bad operands")
}

// VPROLVQ_BCST: Variable Rotate Packed Quadword Left (Broadcast).
//
// Forms:
//
// 	VPROLVQ.BCST m64 zmm k zmm
// 	VPROLVQ.BCST m64 zmm zmm
// 	VPROLVQ.BCST m64 xmm k xmm
// 	VPROLVQ.BCST m64 xmm xmm
// 	VPROLVQ.BCST m64 ymm k ymm
// 	VPROLVQ.BCST m64 ymm ymm
func VPROLVQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPROLVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPROLVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLVQ_BCST: bad operands")
}

// VPROLVQ_BCST_Z: Variable Rotate Packed Quadword Left (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPROLVQ.BCST.Z m64 zmm k zmm
// 	VPROLVQ.BCST.Z m64 xmm k xmm
// 	VPROLVQ.BCST.Z m64 ymm k ymm
func VPROLVQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPROLVQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPROLVQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLVQ_BCST_Z: bad operands")
}

// VPROLVQ_Z: Variable Rotate Packed Quadword Left (Zeroing Masking).
//
// Forms:
//
// 	VPROLVQ.Z m512 zmm k zmm
// 	VPROLVQ.Z zmm  zmm k zmm
// 	VPROLVQ.Z m128 xmm k xmm
// 	VPROLVQ.Z m256 ymm k ymm
// 	VPROLVQ.Z xmm  xmm k xmm
// 	VPROLVQ.Z ymm  ymm k ymm
func VPROLVQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPROLVQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPROLVQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPROLVQ_Z: bad operands")
}

// VPRORD: Rotate Packed Doubleword Right.
//
// Forms:
//
// 	VPRORD imm8 m512 k zmm
// 	VPRORD imm8 m512 zmm
// 	VPRORD imm8 zmm  k zmm
// 	VPRORD imm8 zmm  zmm
// 	VPRORD imm8 m128 k xmm
// 	VPRORD imm8 m128 xmm
// 	VPRORD imm8 m256 k ymm
// 	VPRORD imm8 m256 ymm
// 	VPRORD imm8 xmm  k xmm
// 	VPRORD imm8 xmm  xmm
// 	VPRORD imm8 ymm  k ymm
// 	VPRORD imm8 ymm  ymm
func VPRORD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORD: bad operands")
}

// VPRORD_BCST: Rotate Packed Doubleword Right (Broadcast).
//
// Forms:
//
// 	VPRORD.BCST imm8 m32 k zmm
// 	VPRORD.BCST imm8 m32 zmm
// 	VPRORD.BCST imm8 m32 k xmm
// 	VPRORD.BCST imm8 m32 k ymm
// 	VPRORD.BCST imm8 m32 xmm
// 	VPRORD.BCST imm8 m32 ymm
func VPRORD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORD_BCST: bad operands")
}

// VPRORD_BCST_Z: Rotate Packed Doubleword Right (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPRORD.BCST.Z imm8 m32 k zmm
// 	VPRORD.BCST.Z imm8 m32 k xmm
// 	VPRORD.BCST.Z imm8 m32 k ymm
func VPRORD_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPRORD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPRORD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORD_BCST_Z: bad operands")
}

// VPRORD_Z: Rotate Packed Doubleword Right (Zeroing Masking).
//
// Forms:
//
// 	VPRORD.Z imm8 m512 k zmm
// 	VPRORD.Z imm8 zmm  k zmm
// 	VPRORD.Z imm8 m128 k xmm
// 	VPRORD.Z imm8 m256 k ymm
// 	VPRORD.Z imm8 xmm  k xmm
// 	VPRORD.Z imm8 ymm  k ymm
func VPRORD_Z(i, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPRORD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPRORD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORD_Z: bad operands")
}

// VPRORQ: Rotate Packed Quadword Right.
//
// Forms:
//
// 	VPRORQ imm8 m512 k zmm
// 	VPRORQ imm8 m512 zmm
// 	VPRORQ imm8 zmm  k zmm
// 	VPRORQ imm8 zmm  zmm
// 	VPRORQ imm8 m128 k xmm
// 	VPRORQ imm8 m128 xmm
// 	VPRORQ imm8 m256 k ymm
// 	VPRORQ imm8 m256 ymm
// 	VPRORQ imm8 xmm  k xmm
// 	VPRORQ imm8 xmm  xmm
// 	VPRORQ imm8 ymm  k ymm
// 	VPRORQ imm8 ymm  ymm
func VPRORQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORQ: bad operands")
}

// VPRORQ_BCST: Rotate Packed Quadword Right (Broadcast).
//
// Forms:
//
// 	VPRORQ.BCST imm8 m64 k zmm
// 	VPRORQ.BCST imm8 m64 zmm
// 	VPRORQ.BCST imm8 m64 k xmm
// 	VPRORQ.BCST imm8 m64 k ymm
// 	VPRORQ.BCST imm8 m64 xmm
// 	VPRORQ.BCST imm8 m64 ymm
func VPRORQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORQ_BCST: bad operands")
}

// VPRORQ_BCST_Z: Rotate Packed Quadword Right (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPRORQ.BCST.Z imm8 m64 k zmm
// 	VPRORQ.BCST.Z imm8 m64 k xmm
// 	VPRORQ.BCST.Z imm8 m64 k ymm
func VPRORQ_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPRORQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPRORQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORQ_BCST_Z: bad operands")
}

// VPRORQ_Z: Rotate Packed Quadword Right (Zeroing Masking).
//
// Forms:
//
// 	VPRORQ.Z imm8 m512 k zmm
// 	VPRORQ.Z imm8 zmm  k zmm
// 	VPRORQ.Z imm8 m128 k xmm
// 	VPRORQ.Z imm8 m256 k ymm
// 	VPRORQ.Z imm8 xmm  k xmm
// 	VPRORQ.Z imm8 ymm  k ymm
func VPRORQ_Z(i, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPRORQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPRORQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORQ_Z: bad operands")
}

// VPRORVD: Variable Rotate Packed Doubleword Right.
//
// Forms:
//
// 	VPRORVD m512 zmm k zmm
// 	VPRORVD m512 zmm zmm
// 	VPRORVD zmm  zmm k zmm
// 	VPRORVD zmm  zmm zmm
// 	VPRORVD m128 xmm k xmm
// 	VPRORVD m128 xmm xmm
// 	VPRORVD m256 ymm k ymm
// 	VPRORVD m256 ymm ymm
// 	VPRORVD xmm  xmm k xmm
// 	VPRORVD xmm  xmm xmm
// 	VPRORVD ymm  ymm k ymm
// 	VPRORVD ymm  ymm ymm
func VPRORVD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORVD: bad operands")
}

// VPRORVD_BCST: Variable Rotate Packed Doubleword Right (Broadcast).
//
// Forms:
//
// 	VPRORVD.BCST m32 zmm k zmm
// 	VPRORVD.BCST m32 zmm zmm
// 	VPRORVD.BCST m32 xmm k xmm
// 	VPRORVD.BCST m32 xmm xmm
// 	VPRORVD.BCST m32 ymm k ymm
// 	VPRORVD.BCST m32 ymm ymm
func VPRORVD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORVD_BCST: bad operands")
}

// VPRORVD_BCST_Z: Variable Rotate Packed Doubleword Right (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPRORVD.BCST.Z m32 zmm k zmm
// 	VPRORVD.BCST.Z m32 xmm k xmm
// 	VPRORVD.BCST.Z m32 ymm k ymm
func VPRORVD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPRORVD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPRORVD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORVD_BCST_Z: bad operands")
}

// VPRORVD_Z: Variable Rotate Packed Doubleword Right (Zeroing Masking).
//
// Forms:
//
// 	VPRORVD.Z m512 zmm k zmm
// 	VPRORVD.Z zmm  zmm k zmm
// 	VPRORVD.Z m128 xmm k xmm
// 	VPRORVD.Z m256 ymm k ymm
// 	VPRORVD.Z xmm  xmm k xmm
// 	VPRORVD.Z ymm  ymm k ymm
func VPRORVD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPRORVD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPRORVD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORVD_Z: bad operands")
}

// VPRORVQ: Variable Rotate Packed Quadword Right.
//
// Forms:
//
// 	VPRORVQ m512 zmm k zmm
// 	VPRORVQ m512 zmm zmm
// 	VPRORVQ zmm  zmm k zmm
// 	VPRORVQ zmm  zmm zmm
// 	VPRORVQ m128 xmm k xmm
// 	VPRORVQ m128 xmm xmm
// 	VPRORVQ m256 ymm k ymm
// 	VPRORVQ m256 ymm ymm
// 	VPRORVQ xmm  xmm k xmm
// 	VPRORVQ xmm  xmm xmm
// 	VPRORVQ ymm  ymm k ymm
// 	VPRORVQ ymm  ymm ymm
func VPRORVQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORVQ: bad operands")
}

// VPRORVQ_BCST: Variable Rotate Packed Quadword Right (Broadcast).
//
// Forms:
//
// 	VPRORVQ.BCST m64 zmm k zmm
// 	VPRORVQ.BCST m64 zmm zmm
// 	VPRORVQ.BCST m64 xmm k xmm
// 	VPRORVQ.BCST m64 xmm xmm
// 	VPRORVQ.BCST m64 ymm k ymm
// 	VPRORVQ.BCST m64 ymm ymm
func VPRORVQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPRORVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPRORVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORVQ_BCST: bad operands")
}

// VPRORVQ_BCST_Z: Variable Rotate Packed Quadword Right (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPRORVQ.BCST.Z m64 zmm k zmm
// 	VPRORVQ.BCST.Z m64 xmm k xmm
// 	VPRORVQ.BCST.Z m64 ymm k ymm
func VPRORVQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPRORVQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPRORVQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORVQ_BCST_Z: bad operands")
}

// VPRORVQ_Z: Variable Rotate Packed Quadword Right (Zeroing Masking).
//
// Forms:
//
// 	VPRORVQ.Z m512 zmm k zmm
// 	VPRORVQ.Z zmm  zmm k zmm
// 	VPRORVQ.Z m128 xmm k xmm
// 	VPRORVQ.Z m256 ymm k ymm
// 	VPRORVQ.Z xmm  xmm k xmm
// 	VPRORVQ.Z ymm  ymm k ymm
func VPRORVQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPRORVQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPRORVQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPRORVQ_Z: bad operands")
}

// VPSADBW: Compute Sum of Absolute Differences.
//
// Forms:
//
// 	VPSADBW m256 ymm ymm
// 	VPSADBW ymm  ymm ymm
// 	VPSADBW m128 xmm xmm
// 	VPSADBW xmm  xmm xmm
// 	VPSADBW m512 zmm zmm
// 	VPSADBW zmm  zmm zmm
func VPSADBW(mxyz, xyz, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsXMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSADBW",
			Operands:         []operand.Op{mxyz, xyz, xyz1},
			Inputs:           []operand.Op{mxyz, xyz},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsXMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSADBW",
			Operands: []operand.Op{mxyz, xyz, xyz1},
			Inputs:   []operand.Op{mxyz, xyz},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSADBW",
			Operands:         []operand.Op{mxyz, xyz, xyz1},
			Inputs:           []operand.Op{mxyz, xyz},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSADBW",
			Operands: []operand.Op{mxyz, xyz, xyz1},
			Inputs:   []operand.Op{mxyz, xyz},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX2"},
		}, nil
	case operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSADBW",
			Operands:         []operand.Op{mxyz, xyz, xyz1},
			Inputs:           []operand.Op{mxyz, xyz},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSADBW",
			Operands: []operand.Op{mxyz, xyz, xyz1},
			Inputs:   []operand.Op{mxyz, xyz},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSADBW: bad operands")
}

// VPSCATTERDD: Scatter Packed Doubleword Values with Signed Doubleword Indices.
//
// Forms:
//
// 	VPSCATTERDD zmm k vm32z
// 	VPSCATTERDD xmm k vm32x
// 	VPSCATTERDD ymm k vm32y
func VPSCATTERDD(xyz, k, v operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsVM32Z(v):
		return &intrep.Instruction{
			Opcode:   "VPSCATTERDD",
			Operands: []operand.Op{xyz, k, v},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsVM32X(v),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsVM32Y(v):
		return &intrep.Instruction{
			Opcode:   "VPSCATTERDD",
			Operands: []operand.Op{xyz, k, v},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSCATTERDD: bad operands")
}

// VPSCATTERDQ: Scatter Packed Quadword Values with Signed Doubleword Indices.
//
// Forms:
//
// 	VPSCATTERDQ zmm k vm32y
// 	VPSCATTERDQ xmm k vm32x
// 	VPSCATTERDQ ymm k vm32x
func VPSCATTERDQ(xyz, k, v operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsVM32Y(v):
		return &intrep.Instruction{
			Opcode:   "VPSCATTERDQ",
			Operands: []operand.Op{xyz, k, v},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsVM32X(v),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsVM32X(v):
		return &intrep.Instruction{
			Opcode:   "VPSCATTERDQ",
			Operands: []operand.Op{xyz, k, v},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSCATTERDQ: bad operands")
}

// VPSCATTERQD: Scatter Packed Doubleword Values with Signed Quadword Indices.
//
// Forms:
//
// 	VPSCATTERQD ymm k vm64z
// 	VPSCATTERQD xmm k vm64x
// 	VPSCATTERQD xmm k vm64y
func VPSCATTERQD(xy, k, v operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsYMM(xy) && operand.IsK(k) && operand.IsVM64Z(v):
		return &intrep.Instruction{
			Opcode:   "VPSCATTERQD",
			Operands: []operand.Op{xy, k, v},
			Inputs:   []operand.Op{xy, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xy) && operand.IsK(k) && operand.IsVM64X(v),
		operand.IsXMM(xy) && operand.IsK(k) && operand.IsVM64Y(v):
		return &intrep.Instruction{
			Opcode:   "VPSCATTERQD",
			Operands: []operand.Op{xy, k, v},
			Inputs:   []operand.Op{xy, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSCATTERQD: bad operands")
}

// VPSCATTERQQ: Scatter Packed Quadword Values with Signed Quadword Indices.
//
// Forms:
//
// 	VPSCATTERQQ zmm k vm64z
// 	VPSCATTERQQ xmm k vm64x
// 	VPSCATTERQQ ymm k vm64y
func VPSCATTERQQ(xyz, k, v operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsVM64Z(v):
		return &intrep.Instruction{
			Opcode:   "VPSCATTERQQ",
			Operands: []operand.Op{xyz, k, v},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsVM64X(v),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsVM64Y(v):
		return &intrep.Instruction{
			Opcode:   "VPSCATTERQQ",
			Operands: []operand.Op{xyz, k, v},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSCATTERQQ: bad operands")
}

// VPSHUFB: Packed Shuffle Bytes.
//
// Forms:
//
// 	VPSHUFB m256 ymm ymm
// 	VPSHUFB ymm  ymm ymm
// 	VPSHUFB m128 xmm xmm
// 	VPSHUFB xmm  xmm xmm
// 	VPSHUFB m512 zmm k zmm
// 	VPSHUFB m512 zmm zmm
// 	VPSHUFB zmm  zmm k zmm
// 	VPSHUFB zmm  zmm zmm
// 	VPSHUFB m128 xmm k xmm
// 	VPSHUFB m256 ymm k ymm
// 	VPSHUFB xmm  xmm k xmm
// 	VPSHUFB ymm  ymm k ymm
func VPSHUFB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSHUFB: bad operands")
}

// VPSHUFB_Z: Packed Shuffle Bytes (Zeroing Masking).
//
// Forms:
//
// 	VPSHUFB.Z m512 zmm k zmm
// 	VPSHUFB.Z zmm  zmm k zmm
// 	VPSHUFB.Z m128 xmm k xmm
// 	VPSHUFB.Z m256 ymm k ymm
// 	VPSHUFB.Z xmm  xmm k xmm
// 	VPSHUFB.Z ymm  ymm k ymm
func VPSHUFB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSHUFB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSHUFB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSHUFB_Z: bad operands")
}

// VPSHUFD: Shuffle Packed Doublewords.
//
// Forms:
//
// 	VPSHUFD imm8 m256 ymm
// 	VPSHUFD imm8 ymm  ymm
// 	VPSHUFD imm8 m128 xmm
// 	VPSHUFD imm8 xmm  xmm
// 	VPSHUFD imm8 m512 k zmm
// 	VPSHUFD imm8 m512 zmm
// 	VPSHUFD imm8 zmm  k zmm
// 	VPSHUFD imm8 zmm  zmm
// 	VPSHUFD imm8 m128 k xmm
// 	VPSHUFD imm8 m256 k ymm
// 	VPSHUFD imm8 xmm  k xmm
// 	VPSHUFD imm8 ymm  k ymm
func VPSHUFD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSHUFD: bad operands")
}

// VPSHUFD_BCST: Shuffle Packed Doublewords (Broadcast).
//
// Forms:
//
// 	VPSHUFD.BCST imm8 m32 k zmm
// 	VPSHUFD.BCST imm8 m32 zmm
// 	VPSHUFD.BCST imm8 m32 k xmm
// 	VPSHUFD.BCST imm8 m32 k ymm
// 	VPSHUFD.BCST imm8 m32 xmm
// 	VPSHUFD.BCST imm8 m32 ymm
func VPSHUFD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSHUFD_BCST: bad operands")
}

// VPSHUFD_BCST_Z: Shuffle Packed Doublewords (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSHUFD.BCST.Z imm8 m32 k zmm
// 	VPSHUFD.BCST.Z imm8 m32 k xmm
// 	VPSHUFD.BCST.Z imm8 m32 k ymm
func VPSHUFD_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSHUFD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSHUFD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSHUFD_BCST_Z: bad operands")
}

// VPSHUFD_Z: Shuffle Packed Doublewords (Zeroing Masking).
//
// Forms:
//
// 	VPSHUFD.Z imm8 m512 k zmm
// 	VPSHUFD.Z imm8 zmm  k zmm
// 	VPSHUFD.Z imm8 m128 k xmm
// 	VPSHUFD.Z imm8 m256 k ymm
// 	VPSHUFD.Z imm8 xmm  k xmm
// 	VPSHUFD.Z imm8 ymm  k ymm
func VPSHUFD_Z(i, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSHUFD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSHUFD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSHUFD_Z: bad operands")
}

// VPSHUFHW: Shuffle Packed High Words.
//
// Forms:
//
// 	VPSHUFHW imm8 m256 ymm
// 	VPSHUFHW imm8 ymm  ymm
// 	VPSHUFHW imm8 m128 xmm
// 	VPSHUFHW imm8 xmm  xmm
// 	VPSHUFHW imm8 m512 k zmm
// 	VPSHUFHW imm8 m512 zmm
// 	VPSHUFHW imm8 zmm  k zmm
// 	VPSHUFHW imm8 zmm  zmm
// 	VPSHUFHW imm8 m128 k xmm
// 	VPSHUFHW imm8 m256 k ymm
// 	VPSHUFHW imm8 xmm  k xmm
// 	VPSHUFHW imm8 ymm  k ymm
func VPSHUFHW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFHW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFHW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFHW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFHW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFHW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSHUFHW: bad operands")
}

// VPSHUFHW_Z: Shuffle Packed High Words (Zeroing Masking).
//
// Forms:
//
// 	VPSHUFHW.Z imm8 m512 k zmm
// 	VPSHUFHW.Z imm8 zmm  k zmm
// 	VPSHUFHW.Z imm8 m128 k xmm
// 	VPSHUFHW.Z imm8 m256 k ymm
// 	VPSHUFHW.Z imm8 xmm  k xmm
// 	VPSHUFHW.Z imm8 ymm  k ymm
func VPSHUFHW_Z(i, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSHUFHW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSHUFHW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSHUFHW_Z: bad operands")
}

// VPSHUFLW: Shuffle Packed Low Words.
//
// Forms:
//
// 	VPSHUFLW imm8 m256 ymm
// 	VPSHUFLW imm8 ymm  ymm
// 	VPSHUFLW imm8 m128 xmm
// 	VPSHUFLW imm8 xmm  xmm
// 	VPSHUFLW imm8 m512 k zmm
// 	VPSHUFLW imm8 m512 zmm
// 	VPSHUFLW imm8 zmm  k zmm
// 	VPSHUFLW imm8 zmm  zmm
// 	VPSHUFLW imm8 m128 k xmm
// 	VPSHUFLW imm8 m256 k ymm
// 	VPSHUFLW imm8 xmm  k xmm
// 	VPSHUFLW imm8 ymm  k ymm
func VPSHUFLW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSHUFLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSHUFLW: bad operands")
}

// VPSHUFLW_Z: Shuffle Packed Low Words (Zeroing Masking).
//
// Forms:
//
// 	VPSHUFLW.Z imm8 m512 k zmm
// 	VPSHUFLW.Z imm8 zmm  k zmm
// 	VPSHUFLW.Z imm8 m128 k xmm
// 	VPSHUFLW.Z imm8 m256 k ymm
// 	VPSHUFLW.Z imm8 xmm  k xmm
// 	VPSHUFLW.Z imm8 ymm  k ymm
func VPSHUFLW_Z(i, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSHUFLW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSHUFLW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSHUFLW_Z: bad operands")
}

// VPSIGNB: Packed Sign of Byte Integers.
//
// Forms:
//
// 	VPSIGNB m256 ymm ymm
// 	VPSIGNB ymm  ymm ymm
// 	VPSIGNB m128 xmm xmm
// 	VPSIGNB xmm  xmm xmm
func VPSIGNB(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPSIGNB",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPSIGNB",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPSIGNB: bad operands")
}

// VPSIGND: Packed Sign of Doubleword Integers.
//
// Forms:
//
// 	VPSIGND m256 ymm ymm
// 	VPSIGND ymm  ymm ymm
// 	VPSIGND m128 xmm xmm
// 	VPSIGND xmm  xmm xmm
func VPSIGND(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPSIGND",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPSIGND",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPSIGND: bad operands")
}

// VPSIGNW: Packed Sign of Word Integers.
//
// Forms:
//
// 	VPSIGNW m256 ymm ymm
// 	VPSIGNW ymm  ymm ymm
// 	VPSIGNW m128 xmm xmm
// 	VPSIGNW xmm  xmm xmm
func VPSIGNW(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1),
		operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPSIGNW",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1),
		operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPSIGNW",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPSIGNW: bad operands")
}

// VPSLLD: Shift Packed Doubleword Data Left Logical.
//
// Forms:
//
// 	VPSLLD imm8 ymm  ymm
// 	VPSLLD m128 ymm  ymm
// 	VPSLLD xmm  ymm  ymm
// 	VPSLLD imm8 xmm  xmm
// 	VPSLLD m128 xmm  xmm
// 	VPSLLD xmm  xmm  xmm
// 	VPSLLD imm8 m512 k zmm
// 	VPSLLD imm8 m512 zmm
// 	VPSLLD imm8 zmm  k zmm
// 	VPSLLD imm8 zmm  zmm
// 	VPSLLD m128 zmm  k zmm
// 	VPSLLD m128 zmm  zmm
// 	VPSLLD xmm  zmm  k zmm
// 	VPSLLD xmm  zmm  zmm
// 	VPSLLD imm8 m128 k xmm
// 	VPSLLD imm8 m128 xmm
// 	VPSLLD imm8 m256 k ymm
// 	VPSLLD imm8 m256 ymm
// 	VPSLLD imm8 xmm  k xmm
// 	VPSLLD imm8 ymm  k ymm
// 	VPSLLD m128 xmm  k xmm
// 	VPSLLD m128 ymm  k ymm
// 	VPSLLD xmm  xmm  k xmm
// 	VPSLLD xmm  ymm  k ymm
func VPSLLD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLD: bad operands")
}

// VPSLLDQ: Shift Packed Double Quadword Left Logical.
//
// Forms:
//
// 	VPSLLDQ imm8 ymm  ymm
// 	VPSLLDQ imm8 xmm  xmm
// 	VPSLLDQ imm8 m512 zmm
// 	VPSLLDQ imm8 zmm  zmm
// 	VPSLLDQ imm8 m128 xmm
// 	VPSLLDQ imm8 m256 ymm
func VPSLLDQ(i, mxyz, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsXMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLDQ",
			Operands: []operand.Op{i, mxyz, xyz},
			Inputs:   []operand.Op{mxyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLDQ",
			Operands: []operand.Op{i, mxyz, xyz},
			Inputs:   []operand.Op{mxyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX2"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLDQ",
			Operands: []operand.Op{i, mxyz, xyz},
			Inputs:   []operand.Op{mxyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLDQ",
			Operands: []operand.Op{i, mxyz, xyz},
			Inputs:   []operand.Op{mxyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSLLDQ: bad operands")
}

// VPSLLD_BCST: Shift Packed Doubleword Data Left Logical (Broadcast).
//
// Forms:
//
// 	VPSLLD.BCST imm8 m32 k zmm
// 	VPSLLD.BCST imm8 m32 zmm
// 	VPSLLD.BCST imm8 m32 k xmm
// 	VPSLLD.BCST imm8 m32 k ymm
// 	VPSLLD.BCST imm8 m32 xmm
// 	VPSLLD.BCST imm8 m32 ymm
func VPSLLD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLD_BCST: bad operands")
}

// VPSLLD_BCST_Z: Shift Packed Doubleword Data Left Logical (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSLLD.BCST.Z imm8 m32 k zmm
// 	VPSLLD.BCST.Z imm8 m32 k xmm
// 	VPSLLD.BCST.Z imm8 m32 k ymm
func VPSLLD_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLD_BCST_Z: bad operands")
}

// VPSLLD_Z: Shift Packed Doubleword Data Left Logical (Zeroing Masking).
//
// Forms:
//
// 	VPSLLD.Z imm8 m512 k zmm
// 	VPSLLD.Z imm8 zmm  k zmm
// 	VPSLLD.Z m128 zmm  k zmm
// 	VPSLLD.Z xmm  zmm  k zmm
// 	VPSLLD.Z imm8 m128 k xmm
// 	VPSLLD.Z imm8 m256 k ymm
// 	VPSLLD.Z imm8 xmm  k xmm
// 	VPSLLD.Z imm8 ymm  k ymm
// 	VPSLLD.Z m128 xmm  k xmm
// 	VPSLLD.Z m128 ymm  k ymm
// 	VPSLLD.Z xmm  xmm  k xmm
// 	VPSLLD.Z xmm  ymm  k ymm
func VPSLLD_Z(imx, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM128(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLD_Z: bad operands")
}

// VPSLLQ: Shift Packed Quadword Data Left Logical.
//
// Forms:
//
// 	VPSLLQ imm8 ymm  ymm
// 	VPSLLQ m128 ymm  ymm
// 	VPSLLQ xmm  ymm  ymm
// 	VPSLLQ imm8 xmm  xmm
// 	VPSLLQ m128 xmm  xmm
// 	VPSLLQ xmm  xmm  xmm
// 	VPSLLQ imm8 m512 k zmm
// 	VPSLLQ imm8 m512 zmm
// 	VPSLLQ imm8 zmm  k zmm
// 	VPSLLQ imm8 zmm  zmm
// 	VPSLLQ m128 zmm  k zmm
// 	VPSLLQ m128 zmm  zmm
// 	VPSLLQ xmm  zmm  k zmm
// 	VPSLLQ xmm  zmm  zmm
// 	VPSLLQ imm8 m128 k xmm
// 	VPSLLQ imm8 m128 xmm
// 	VPSLLQ imm8 m256 k ymm
// 	VPSLLQ imm8 m256 ymm
// 	VPSLLQ imm8 xmm  k xmm
// 	VPSLLQ imm8 ymm  k ymm
// 	VPSLLQ m128 xmm  k xmm
// 	VPSLLQ m128 ymm  k ymm
// 	VPSLLQ xmm  xmm  k xmm
// 	VPSLLQ xmm  ymm  k ymm
func VPSLLQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLQ: bad operands")
}

// VPSLLQ_BCST: Shift Packed Quadword Data Left Logical (Broadcast).
//
// Forms:
//
// 	VPSLLQ.BCST imm8 m64 k zmm
// 	VPSLLQ.BCST imm8 m64 zmm
// 	VPSLLQ.BCST imm8 m64 k xmm
// 	VPSLLQ.BCST imm8 m64 k ymm
// 	VPSLLQ.BCST imm8 m64 xmm
// 	VPSLLQ.BCST imm8 m64 ymm
func VPSLLQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLQ_BCST: bad operands")
}

// VPSLLQ_BCST_Z: Shift Packed Quadword Data Left Logical (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSLLQ.BCST.Z imm8 m64 k zmm
// 	VPSLLQ.BCST.Z imm8 m64 k xmm
// 	VPSLLQ.BCST.Z imm8 m64 k ymm
func VPSLLQ_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLQ_BCST_Z: bad operands")
}

// VPSLLQ_Z: Shift Packed Quadword Data Left Logical (Zeroing Masking).
//
// Forms:
//
// 	VPSLLQ.Z imm8 m512 k zmm
// 	VPSLLQ.Z imm8 zmm  k zmm
// 	VPSLLQ.Z m128 zmm  k zmm
// 	VPSLLQ.Z xmm  zmm  k zmm
// 	VPSLLQ.Z imm8 m128 k xmm
// 	VPSLLQ.Z imm8 m256 k ymm
// 	VPSLLQ.Z imm8 xmm  k xmm
// 	VPSLLQ.Z imm8 ymm  k ymm
// 	VPSLLQ.Z m128 xmm  k xmm
// 	VPSLLQ.Z m128 ymm  k ymm
// 	VPSLLQ.Z xmm  xmm  k xmm
// 	VPSLLQ.Z xmm  ymm  k ymm
func VPSLLQ_Z(imx, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM128(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLQ_Z: bad operands")
}

// VPSLLVD: Variable Shift Packed Doubleword Data Left Logical.
//
// Forms:
//
// 	VPSLLVD m128 xmm xmm
// 	VPSLLVD m256 ymm ymm
// 	VPSLLVD xmm  xmm xmm
// 	VPSLLVD ymm  ymm ymm
// 	VPSLLVD m512 zmm k zmm
// 	VPSLLVD m512 zmm zmm
// 	VPSLLVD zmm  zmm k zmm
// 	VPSLLVD zmm  zmm zmm
// 	VPSLLVD m128 xmm k xmm
// 	VPSLLVD m256 ymm k ymm
// 	VPSLLVD xmm  xmm k xmm
// 	VPSLLVD ymm  ymm k ymm
func VPSLLVD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLVD: bad operands")
}

// VPSLLVD_BCST: Variable Shift Packed Doubleword Data Left Logical (Broadcast).
//
// Forms:
//
// 	VPSLLVD.BCST m32 zmm k zmm
// 	VPSLLVD.BCST m32 zmm zmm
// 	VPSLLVD.BCST m32 xmm k xmm
// 	VPSLLVD.BCST m32 xmm xmm
// 	VPSLLVD.BCST m32 ymm k ymm
// 	VPSLLVD.BCST m32 ymm ymm
func VPSLLVD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLVD_BCST: bad operands")
}

// VPSLLVD_BCST_Z: Variable Shift Packed Doubleword Data Left Logical (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSLLVD.BCST.Z m32 zmm k zmm
// 	VPSLLVD.BCST.Z m32 xmm k xmm
// 	VPSLLVD.BCST.Z m32 ymm k ymm
func VPSLLVD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSLLVD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSLLVD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLVD_BCST_Z: bad operands")
}

// VPSLLVD_Z: Variable Shift Packed Doubleword Data Left Logical (Zeroing Masking).
//
// Forms:
//
// 	VPSLLVD.Z m512 zmm k zmm
// 	VPSLLVD.Z zmm  zmm k zmm
// 	VPSLLVD.Z m128 xmm k xmm
// 	VPSLLVD.Z m256 ymm k ymm
// 	VPSLLVD.Z xmm  xmm k xmm
// 	VPSLLVD.Z ymm  ymm k ymm
func VPSLLVD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSLLVD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSLLVD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLVD_Z: bad operands")
}

// VPSLLVQ: Variable Shift Packed Quadword Data Left Logical.
//
// Forms:
//
// 	VPSLLVQ m128 xmm xmm
// 	VPSLLVQ m256 ymm ymm
// 	VPSLLVQ xmm  xmm xmm
// 	VPSLLVQ ymm  ymm ymm
// 	VPSLLVQ m512 zmm k zmm
// 	VPSLLVQ m512 zmm zmm
// 	VPSLLVQ zmm  zmm k zmm
// 	VPSLLVQ zmm  zmm zmm
// 	VPSLLVQ m128 xmm k xmm
// 	VPSLLVQ m256 ymm k ymm
// 	VPSLLVQ xmm  xmm k xmm
// 	VPSLLVQ ymm  ymm k ymm
func VPSLLVQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLVQ: bad operands")
}

// VPSLLVQ_BCST: Variable Shift Packed Quadword Data Left Logical (Broadcast).
//
// Forms:
//
// 	VPSLLVQ.BCST m64 zmm k zmm
// 	VPSLLVQ.BCST m64 zmm zmm
// 	VPSLLVQ.BCST m64 xmm k xmm
// 	VPSLLVQ.BCST m64 xmm xmm
// 	VPSLLVQ.BCST m64 ymm k ymm
// 	VPSLLVQ.BCST m64 ymm ymm
func VPSLLVQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLVQ_BCST: bad operands")
}

// VPSLLVQ_BCST_Z: Variable Shift Packed Quadword Data Left Logical (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSLLVQ.BCST.Z m64 zmm k zmm
// 	VPSLLVQ.BCST.Z m64 xmm k xmm
// 	VPSLLVQ.BCST.Z m64 ymm k ymm
func VPSLLVQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSLLVQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSLLVQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLVQ_BCST_Z: bad operands")
}

// VPSLLVQ_Z: Variable Shift Packed Quadword Data Left Logical (Zeroing Masking).
//
// Forms:
//
// 	VPSLLVQ.Z m512 zmm k zmm
// 	VPSLLVQ.Z zmm  zmm k zmm
// 	VPSLLVQ.Z m128 xmm k xmm
// 	VPSLLVQ.Z m256 ymm k ymm
// 	VPSLLVQ.Z xmm  xmm k xmm
// 	VPSLLVQ.Z ymm  ymm k ymm
func VPSLLVQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSLLVQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSLLVQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSLLVQ_Z: bad operands")
}

// VPSLLVW: Variable Shift Packed Word Data Left Logical.
//
// Forms:
//
// 	VPSLLVW m512 zmm k zmm
// 	VPSLLVW m512 zmm zmm
// 	VPSLLVW zmm  zmm k zmm
// 	VPSLLVW zmm  zmm zmm
// 	VPSLLVW m128 xmm k xmm
// 	VPSLLVW m128 xmm xmm
// 	VPSLLVW m256 ymm k ymm
// 	VPSLLVW m256 ymm ymm
// 	VPSLLVW xmm  xmm k xmm
// 	VPSLLVW xmm  xmm xmm
// 	VPSLLVW ymm  ymm k ymm
// 	VPSLLVW ymm  ymm ymm
func VPSLLVW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLVW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSLLVW: bad operands")
}

// VPSLLVW_Z: Variable Shift Packed Word Data Left Logical (Zeroing Masking).
//
// Forms:
//
// 	VPSLLVW.Z m512 zmm k zmm
// 	VPSLLVW.Z zmm  zmm k zmm
// 	VPSLLVW.Z m128 xmm k xmm
// 	VPSLLVW.Z m256 ymm k ymm
// 	VPSLLVW.Z xmm  xmm k xmm
// 	VPSLLVW.Z ymm  ymm k ymm
func VPSLLVW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSLLVW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSLLVW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSLLVW_Z: bad operands")
}

// VPSLLW: Shift Packed Word Data Left Logical.
//
// Forms:
//
// 	VPSLLW imm8 ymm  ymm
// 	VPSLLW m128 ymm  ymm
// 	VPSLLW xmm  ymm  ymm
// 	VPSLLW imm8 xmm  xmm
// 	VPSLLW m128 xmm  xmm
// 	VPSLLW xmm  xmm  xmm
// 	VPSLLW imm8 m512 k zmm
// 	VPSLLW imm8 m512 zmm
// 	VPSLLW imm8 zmm  k zmm
// 	VPSLLW imm8 zmm  zmm
// 	VPSLLW m128 zmm  k zmm
// 	VPSLLW m128 zmm  zmm
// 	VPSLLW xmm  zmm  k zmm
// 	VPSLLW xmm  zmm  zmm
// 	VPSLLW imm8 m128 k xmm
// 	VPSLLW imm8 m128 xmm
// 	VPSLLW imm8 m256 k ymm
// 	VPSLLW imm8 m256 ymm
// 	VPSLLW imm8 xmm  k xmm
// 	VPSLLW imm8 ymm  k ymm
// 	VPSLLW m128 xmm  k xmm
// 	VPSLLW m128 ymm  k ymm
// 	VPSLLW xmm  xmm  k xmm
// 	VPSLLW xmm  ymm  k ymm
func VPSLLW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSLLW: bad operands")
}

// VPSLLW_Z: Shift Packed Word Data Left Logical (Zeroing Masking).
//
// Forms:
//
// 	VPSLLW.Z imm8 m512 k zmm
// 	VPSLLW.Z imm8 zmm  k zmm
// 	VPSLLW.Z m128 zmm  k zmm
// 	VPSLLW.Z xmm  zmm  k zmm
// 	VPSLLW.Z imm8 m128 k xmm
// 	VPSLLW.Z imm8 m256 k ymm
// 	VPSLLW.Z imm8 xmm  k xmm
// 	VPSLLW.Z imm8 ymm  k ymm
// 	VPSLLW.Z m128 xmm  k xmm
// 	VPSLLW.Z m128 ymm  k ymm
// 	VPSLLW.Z xmm  xmm  k xmm
// 	VPSLLW.Z xmm  ymm  k ymm
func VPSLLW_Z(imx, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM128(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSLLW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSLLW_Z: bad operands")
}

// VPSRAD: Shift Packed Doubleword Data Right Arithmetic.
//
// Forms:
//
// 	VPSRAD imm8 ymm  ymm
// 	VPSRAD m128 ymm  ymm
// 	VPSRAD xmm  ymm  ymm
// 	VPSRAD imm8 xmm  xmm
// 	VPSRAD m128 xmm  xmm
// 	VPSRAD xmm  xmm  xmm
// 	VPSRAD imm8 m512 k zmm
// 	VPSRAD imm8 m512 zmm
// 	VPSRAD imm8 zmm  k zmm
// 	VPSRAD imm8 zmm  zmm
// 	VPSRAD m128 zmm  k zmm
// 	VPSRAD m128 zmm  zmm
// 	VPSRAD xmm  zmm  k zmm
// 	VPSRAD xmm  zmm  zmm
// 	VPSRAD imm8 m128 k xmm
// 	VPSRAD imm8 m128 xmm
// 	VPSRAD imm8 m256 k ymm
// 	VPSRAD imm8 m256 ymm
// 	VPSRAD imm8 xmm  k xmm
// 	VPSRAD imm8 ymm  k ymm
// 	VPSRAD m128 xmm  k xmm
// 	VPSRAD m128 ymm  k ymm
// 	VPSRAD xmm  xmm  k xmm
// 	VPSRAD xmm  ymm  k ymm
func VPSRAD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAD: bad operands")
}

// VPSRAD_BCST: Shift Packed Doubleword Data Right Arithmetic (Broadcast).
//
// Forms:
//
// 	VPSRAD.BCST imm8 m32 k zmm
// 	VPSRAD.BCST imm8 m32 zmm
// 	VPSRAD.BCST imm8 m32 k xmm
// 	VPSRAD.BCST imm8 m32 k ymm
// 	VPSRAD.BCST imm8 m32 xmm
// 	VPSRAD.BCST imm8 m32 ymm
func VPSRAD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAD_BCST: bad operands")
}

// VPSRAD_BCST_Z: Shift Packed Doubleword Data Right Arithmetic (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSRAD.BCST.Z imm8 m32 k zmm
// 	VPSRAD.BCST.Z imm8 m32 k xmm
// 	VPSRAD.BCST.Z imm8 m32 k ymm
func VPSRAD_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAD_BCST_Z: bad operands")
}

// VPSRAD_Z: Shift Packed Doubleword Data Right Arithmetic (Zeroing Masking).
//
// Forms:
//
// 	VPSRAD.Z imm8 m512 k zmm
// 	VPSRAD.Z imm8 zmm  k zmm
// 	VPSRAD.Z m128 zmm  k zmm
// 	VPSRAD.Z xmm  zmm  k zmm
// 	VPSRAD.Z imm8 m128 k xmm
// 	VPSRAD.Z imm8 m256 k ymm
// 	VPSRAD.Z imm8 xmm  k xmm
// 	VPSRAD.Z imm8 ymm  k ymm
// 	VPSRAD.Z m128 xmm  k xmm
// 	VPSRAD.Z m128 ymm  k ymm
// 	VPSRAD.Z xmm  xmm  k xmm
// 	VPSRAD.Z xmm  ymm  k ymm
func VPSRAD_Z(imx, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM128(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAD_Z: bad operands")
}

// VPSRAQ: Shift Packed Quadword Data Right Arithmetic.
//
// Forms:
//
// 	VPSRAQ imm8 m512 k zmm
// 	VPSRAQ imm8 m512 zmm
// 	VPSRAQ imm8 zmm  k zmm
// 	VPSRAQ imm8 zmm  zmm
// 	VPSRAQ m128 zmm  k zmm
// 	VPSRAQ m128 zmm  zmm
// 	VPSRAQ xmm  zmm  k zmm
// 	VPSRAQ xmm  zmm  zmm
// 	VPSRAQ imm8 m128 k xmm
// 	VPSRAQ imm8 m128 xmm
// 	VPSRAQ imm8 m256 k ymm
// 	VPSRAQ imm8 m256 ymm
// 	VPSRAQ imm8 xmm  k xmm
// 	VPSRAQ imm8 xmm  xmm
// 	VPSRAQ imm8 ymm  k ymm
// 	VPSRAQ imm8 ymm  ymm
// 	VPSRAQ m128 xmm  k xmm
// 	VPSRAQ m128 xmm  xmm
// 	VPSRAQ m128 ymm  k ymm
// 	VPSRAQ m128 ymm  ymm
// 	VPSRAQ xmm  xmm  k xmm
// 	VPSRAQ xmm  xmm  xmm
// 	VPSRAQ xmm  ymm  k ymm
// 	VPSRAQ xmm  ymm  ymm
func VPSRAQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAQ: bad operands")
}

// VPSRAQ_BCST: Shift Packed Quadword Data Right Arithmetic (Broadcast).
//
// Forms:
//
// 	VPSRAQ.BCST imm8 m64 k zmm
// 	VPSRAQ.BCST imm8 m64 zmm
// 	VPSRAQ.BCST imm8 m64 k xmm
// 	VPSRAQ.BCST imm8 m64 k ymm
// 	VPSRAQ.BCST imm8 m64 xmm
// 	VPSRAQ.BCST imm8 m64 ymm
func VPSRAQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAQ_BCST: bad operands")
}

// VPSRAQ_BCST_Z: Shift Packed Quadword Data Right Arithmetic (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSRAQ.BCST.Z imm8 m64 k zmm
// 	VPSRAQ.BCST.Z imm8 m64 k xmm
// 	VPSRAQ.BCST.Z imm8 m64 k ymm
func VPSRAQ_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAQ_BCST_Z: bad operands")
}

// VPSRAQ_Z: Shift Packed Quadword Data Right Arithmetic (Zeroing Masking).
//
// Forms:
//
// 	VPSRAQ.Z imm8 m512 k zmm
// 	VPSRAQ.Z imm8 zmm  k zmm
// 	VPSRAQ.Z m128 zmm  k zmm
// 	VPSRAQ.Z xmm  zmm  k zmm
// 	VPSRAQ.Z imm8 m128 k xmm
// 	VPSRAQ.Z imm8 m256 k ymm
// 	VPSRAQ.Z imm8 xmm  k xmm
// 	VPSRAQ.Z imm8 ymm  k ymm
// 	VPSRAQ.Z m128 xmm  k xmm
// 	VPSRAQ.Z m128 ymm  k ymm
// 	VPSRAQ.Z xmm  xmm  k xmm
// 	VPSRAQ.Z xmm  ymm  k ymm
func VPSRAQ_Z(imx, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM128(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAQ_Z: bad operands")
}

// VPSRAVD: Variable Shift Packed Doubleword Data Right Arithmetic.
//
// Forms:
//
// 	VPSRAVD m128 xmm xmm
// 	VPSRAVD m256 ymm ymm
// 	VPSRAVD xmm  xmm xmm
// 	VPSRAVD ymm  ymm ymm
// 	VPSRAVD m512 zmm k zmm
// 	VPSRAVD m512 zmm zmm
// 	VPSRAVD zmm  zmm k zmm
// 	VPSRAVD zmm  zmm zmm
// 	VPSRAVD m128 xmm k xmm
// 	VPSRAVD m256 ymm k ymm
// 	VPSRAVD xmm  xmm k xmm
// 	VPSRAVD ymm  ymm k ymm
func VPSRAVD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAVD: bad operands")
}

// VPSRAVD_BCST: Variable Shift Packed Doubleword Data Right Arithmetic (Broadcast).
//
// Forms:
//
// 	VPSRAVD.BCST m32 zmm k zmm
// 	VPSRAVD.BCST m32 zmm zmm
// 	VPSRAVD.BCST m32 xmm k xmm
// 	VPSRAVD.BCST m32 xmm xmm
// 	VPSRAVD.BCST m32 ymm k ymm
// 	VPSRAVD.BCST m32 ymm ymm
func VPSRAVD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAVD_BCST: bad operands")
}

// VPSRAVD_BCST_Z: Variable Shift Packed Doubleword Data Right Arithmetic (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSRAVD.BCST.Z m32 zmm k zmm
// 	VPSRAVD.BCST.Z m32 xmm k xmm
// 	VPSRAVD.BCST.Z m32 ymm k ymm
func VPSRAVD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRAVD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRAVD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAVD_BCST_Z: bad operands")
}

// VPSRAVD_Z: Variable Shift Packed Doubleword Data Right Arithmetic (Zeroing Masking).
//
// Forms:
//
// 	VPSRAVD.Z m512 zmm k zmm
// 	VPSRAVD.Z zmm  zmm k zmm
// 	VPSRAVD.Z m128 xmm k xmm
// 	VPSRAVD.Z m256 ymm k ymm
// 	VPSRAVD.Z xmm  xmm k xmm
// 	VPSRAVD.Z ymm  ymm k ymm
func VPSRAVD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRAVD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRAVD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAVD_Z: bad operands")
}

// VPSRAVQ: Variable Shift Packed Quadword Data Right Arithmetic.
//
// Forms:
//
// 	VPSRAVQ m512 zmm k zmm
// 	VPSRAVQ m512 zmm zmm
// 	VPSRAVQ zmm  zmm k zmm
// 	VPSRAVQ zmm  zmm zmm
// 	VPSRAVQ m128 xmm k xmm
// 	VPSRAVQ m128 xmm xmm
// 	VPSRAVQ m256 ymm k ymm
// 	VPSRAVQ m256 ymm ymm
// 	VPSRAVQ xmm  xmm k xmm
// 	VPSRAVQ xmm  xmm xmm
// 	VPSRAVQ ymm  ymm k ymm
// 	VPSRAVQ ymm  ymm ymm
func VPSRAVQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAVQ: bad operands")
}

// VPSRAVQ_BCST: Variable Shift Packed Quadword Data Right Arithmetic (Broadcast).
//
// Forms:
//
// 	VPSRAVQ.BCST m64 zmm k zmm
// 	VPSRAVQ.BCST m64 zmm zmm
// 	VPSRAVQ.BCST m64 xmm k xmm
// 	VPSRAVQ.BCST m64 xmm xmm
// 	VPSRAVQ.BCST m64 ymm k ymm
// 	VPSRAVQ.BCST m64 ymm ymm
func VPSRAVQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAVQ_BCST: bad operands")
}

// VPSRAVQ_BCST_Z: Variable Shift Packed Quadword Data Right Arithmetic (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSRAVQ.BCST.Z m64 zmm k zmm
// 	VPSRAVQ.BCST.Z m64 xmm k xmm
// 	VPSRAVQ.BCST.Z m64 ymm k ymm
func VPSRAVQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRAVQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRAVQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAVQ_BCST_Z: bad operands")
}

// VPSRAVQ_Z: Variable Shift Packed Quadword Data Right Arithmetic (Zeroing Masking).
//
// Forms:
//
// 	VPSRAVQ.Z m512 zmm k zmm
// 	VPSRAVQ.Z zmm  zmm k zmm
// 	VPSRAVQ.Z m128 xmm k xmm
// 	VPSRAVQ.Z m256 ymm k ymm
// 	VPSRAVQ.Z xmm  xmm k xmm
// 	VPSRAVQ.Z ymm  ymm k ymm
func VPSRAVQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRAVQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRAVQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRAVQ_Z: bad operands")
}

// VPSRAVW: Variable Shift Packed Word Data Right Arithmetic.
//
// Forms:
//
// 	VPSRAVW m512 zmm k zmm
// 	VPSRAVW m512 zmm zmm
// 	VPSRAVW zmm  zmm k zmm
// 	VPSRAVW zmm  zmm zmm
// 	VPSRAVW m128 xmm k xmm
// 	VPSRAVW m128 xmm xmm
// 	VPSRAVW m256 ymm k ymm
// 	VPSRAVW m256 ymm ymm
// 	VPSRAVW xmm  xmm k xmm
// 	VPSRAVW xmm  xmm xmm
// 	VPSRAVW ymm  ymm k ymm
// 	VPSRAVW ymm  ymm ymm
func VPSRAVW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAVW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSRAVW: bad operands")
}

// VPSRAVW_Z: Variable Shift Packed Word Data Right Arithmetic (Zeroing Masking).
//
// Forms:
//
// 	VPSRAVW.Z m512 zmm k zmm
// 	VPSRAVW.Z zmm  zmm k zmm
// 	VPSRAVW.Z m128 xmm k xmm
// 	VPSRAVW.Z m256 ymm k ymm
// 	VPSRAVW.Z xmm  xmm k xmm
// 	VPSRAVW.Z ymm  ymm k ymm
func VPSRAVW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRAVW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRAVW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSRAVW_Z: bad operands")
}

// VPSRAW: Shift Packed Word Data Right Arithmetic.
//
// Forms:
//
// 	VPSRAW imm8 ymm  ymm
// 	VPSRAW m128 ymm  ymm
// 	VPSRAW xmm  ymm  ymm
// 	VPSRAW imm8 xmm  xmm
// 	VPSRAW m128 xmm  xmm
// 	VPSRAW xmm  xmm  xmm
// 	VPSRAW imm8 m512 k zmm
// 	VPSRAW imm8 m512 zmm
// 	VPSRAW imm8 zmm  k zmm
// 	VPSRAW imm8 zmm  zmm
// 	VPSRAW m128 zmm  k zmm
// 	VPSRAW m128 zmm  zmm
// 	VPSRAW xmm  zmm  k zmm
// 	VPSRAW xmm  zmm  zmm
// 	VPSRAW imm8 m128 k xmm
// 	VPSRAW imm8 m128 xmm
// 	VPSRAW imm8 m256 k ymm
// 	VPSRAW imm8 m256 ymm
// 	VPSRAW imm8 xmm  k xmm
// 	VPSRAW imm8 ymm  k ymm
// 	VPSRAW m128 xmm  k xmm
// 	VPSRAW m128 ymm  k ymm
// 	VPSRAW xmm  xmm  k xmm
// 	VPSRAW xmm  ymm  k ymm
func VPSRAW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSRAW: bad operands")
}

// VPSRAW_Z: Shift Packed Word Data Right Arithmetic (Zeroing Masking).
//
// Forms:
//
// 	VPSRAW.Z imm8 m512 k zmm
// 	VPSRAW.Z imm8 zmm  k zmm
// 	VPSRAW.Z m128 zmm  k zmm
// 	VPSRAW.Z xmm  zmm  k zmm
// 	VPSRAW.Z imm8 m128 k xmm
// 	VPSRAW.Z imm8 m256 k ymm
// 	VPSRAW.Z imm8 xmm  k xmm
// 	VPSRAW.Z imm8 ymm  k ymm
// 	VPSRAW.Z m128 xmm  k xmm
// 	VPSRAW.Z m128 ymm  k ymm
// 	VPSRAW.Z xmm  xmm  k xmm
// 	VPSRAW.Z xmm  ymm  k ymm
func VPSRAW_Z(imx, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM128(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRAW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSRAW_Z: bad operands")
}

// VPSRLD: Shift Packed Doubleword Data Right Logical.
//
// Forms:
//
// 	VPSRLD imm8 ymm  ymm
// 	VPSRLD m128 ymm  ymm
// 	VPSRLD xmm  ymm  ymm
// 	VPSRLD imm8 xmm  xmm
// 	VPSRLD m128 xmm  xmm
// 	VPSRLD xmm  xmm  xmm
// 	VPSRLD imm8 m512 k zmm
// 	VPSRLD imm8 m512 zmm
// 	VPSRLD imm8 zmm  k zmm
// 	VPSRLD imm8 zmm  zmm
// 	VPSRLD m128 zmm  k zmm
// 	VPSRLD m128 zmm  zmm
// 	VPSRLD xmm  zmm  k zmm
// 	VPSRLD xmm  zmm  zmm
// 	VPSRLD imm8 m128 k xmm
// 	VPSRLD imm8 m128 xmm
// 	VPSRLD imm8 m256 k ymm
// 	VPSRLD imm8 m256 ymm
// 	VPSRLD imm8 xmm  k xmm
// 	VPSRLD imm8 ymm  k ymm
// 	VPSRLD m128 xmm  k xmm
// 	VPSRLD m128 ymm  k ymm
// 	VPSRLD xmm  xmm  k xmm
// 	VPSRLD xmm  ymm  k ymm
func VPSRLD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLD: bad operands")
}

// VPSRLDQ: Shift Packed Double Quadword Right Logical.
//
// Forms:
//
// 	VPSRLDQ imm8 ymm  ymm
// 	VPSRLDQ imm8 xmm  xmm
// 	VPSRLDQ imm8 m512 zmm
// 	VPSRLDQ imm8 zmm  zmm
// 	VPSRLDQ imm8 m128 xmm
// 	VPSRLDQ imm8 m256 ymm
func VPSRLDQ(i, mxyz, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsXMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLDQ",
			Operands: []operand.Op{i, mxyz, xyz},
			Inputs:   []operand.Op{mxyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLDQ",
			Operands: []operand.Op{i, mxyz, xyz},
			Inputs:   []operand.Op{mxyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX2"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLDQ",
			Operands: []operand.Op{i, mxyz, xyz},
			Inputs:   []operand.Op{mxyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLDQ",
			Operands: []operand.Op{i, mxyz, xyz},
			Inputs:   []operand.Op{mxyz},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSRLDQ: bad operands")
}

// VPSRLD_BCST: Shift Packed Doubleword Data Right Logical (Broadcast).
//
// Forms:
//
// 	VPSRLD.BCST imm8 m32 k zmm
// 	VPSRLD.BCST imm8 m32 zmm
// 	VPSRLD.BCST imm8 m32 k xmm
// 	VPSRLD.BCST imm8 m32 k ymm
// 	VPSRLD.BCST imm8 m32 xmm
// 	VPSRLD.BCST imm8 m32 ymm
func VPSRLD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLD_BCST: bad operands")
}

// VPSRLD_BCST_Z: Shift Packed Doubleword Data Right Logical (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSRLD.BCST.Z imm8 m32 k zmm
// 	VPSRLD.BCST.Z imm8 m32 k xmm
// 	VPSRLD.BCST.Z imm8 m32 k ymm
func VPSRLD_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLD_BCST_Z: bad operands")
}

// VPSRLD_Z: Shift Packed Doubleword Data Right Logical (Zeroing Masking).
//
// Forms:
//
// 	VPSRLD.Z imm8 m512 k zmm
// 	VPSRLD.Z imm8 zmm  k zmm
// 	VPSRLD.Z m128 zmm  k zmm
// 	VPSRLD.Z xmm  zmm  k zmm
// 	VPSRLD.Z imm8 m128 k xmm
// 	VPSRLD.Z imm8 m256 k ymm
// 	VPSRLD.Z imm8 xmm  k xmm
// 	VPSRLD.Z imm8 ymm  k ymm
// 	VPSRLD.Z m128 xmm  k xmm
// 	VPSRLD.Z m128 ymm  k ymm
// 	VPSRLD.Z xmm  xmm  k xmm
// 	VPSRLD.Z xmm  ymm  k ymm
func VPSRLD_Z(imx, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM128(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLD_Z: bad operands")
}

// VPSRLQ: Shift Packed Quadword Data Right Logical.
//
// Forms:
//
// 	VPSRLQ imm8 ymm  ymm
// 	VPSRLQ m128 ymm  ymm
// 	VPSRLQ xmm  ymm  ymm
// 	VPSRLQ imm8 xmm  xmm
// 	VPSRLQ m128 xmm  xmm
// 	VPSRLQ xmm  xmm  xmm
// 	VPSRLQ imm8 m512 k zmm
// 	VPSRLQ imm8 m512 zmm
// 	VPSRLQ imm8 zmm  k zmm
// 	VPSRLQ imm8 zmm  zmm
// 	VPSRLQ m128 zmm  k zmm
// 	VPSRLQ m128 zmm  zmm
// 	VPSRLQ xmm  zmm  k zmm
// 	VPSRLQ xmm  zmm  zmm
// 	VPSRLQ imm8 m128 k xmm
// 	VPSRLQ imm8 m128 xmm
// 	VPSRLQ imm8 m256 k ymm
// 	VPSRLQ imm8 m256 ymm
// 	VPSRLQ imm8 xmm  k xmm
// 	VPSRLQ imm8 ymm  k ymm
// 	VPSRLQ m128 xmm  k xmm
// 	VPSRLQ m128 ymm  k ymm
// 	VPSRLQ xmm  xmm  k xmm
// 	VPSRLQ xmm  ymm  k ymm
func VPSRLQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLQ: bad operands")
}

// VPSRLQ_BCST: Shift Packed Quadword Data Right Logical (Broadcast).
//
// Forms:
//
// 	VPSRLQ.BCST imm8 m64 k zmm
// 	VPSRLQ.BCST imm8 m64 zmm
// 	VPSRLQ.BCST imm8 m64 k xmm
// 	VPSRLQ.BCST imm8 m64 k ymm
// 	VPSRLQ.BCST imm8 m64 xmm
// 	VPSRLQ.BCST imm8 m64 ymm
func VPSRLQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLQ_BCST: bad operands")
}

// VPSRLQ_BCST_Z: Shift Packed Quadword Data Right Logical (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSRLQ.BCST.Z imm8 m64 k zmm
// 	VPSRLQ.BCST.Z imm8 m64 k xmm
// 	VPSRLQ.BCST.Z imm8 m64 k ymm
func VPSRLQ_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLQ_BCST_Z: bad operands")
}

// VPSRLQ_Z: Shift Packed Quadword Data Right Logical (Zeroing Masking).
//
// Forms:
//
// 	VPSRLQ.Z imm8 m512 k zmm
// 	VPSRLQ.Z imm8 zmm  k zmm
// 	VPSRLQ.Z m128 zmm  k zmm
// 	VPSRLQ.Z xmm  zmm  k zmm
// 	VPSRLQ.Z imm8 m128 k xmm
// 	VPSRLQ.Z imm8 m256 k ymm
// 	VPSRLQ.Z imm8 xmm  k xmm
// 	VPSRLQ.Z imm8 ymm  k ymm
// 	VPSRLQ.Z m128 xmm  k xmm
// 	VPSRLQ.Z m128 ymm  k ymm
// 	VPSRLQ.Z xmm  xmm  k xmm
// 	VPSRLQ.Z xmm  ymm  k ymm
func VPSRLQ_Z(imx, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM128(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLQ_Z: bad operands")
}

// VPSRLVD: Variable Shift Packed Doubleword Data Right Logical.
//
// Forms:
//
// 	VPSRLVD m128 xmm xmm
// 	VPSRLVD m256 ymm ymm
// 	VPSRLVD xmm  xmm xmm
// 	VPSRLVD ymm  ymm ymm
// 	VPSRLVD m512 zmm k zmm
// 	VPSRLVD m512 zmm zmm
// 	VPSRLVD zmm  zmm k zmm
// 	VPSRLVD zmm  zmm zmm
// 	VPSRLVD m128 xmm k xmm
// 	VPSRLVD m256 ymm k ymm
// 	VPSRLVD xmm  xmm k xmm
// 	VPSRLVD ymm  ymm k ymm
func VPSRLVD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLVD: bad operands")
}

// VPSRLVD_BCST: Variable Shift Packed Doubleword Data Right Logical (Broadcast).
//
// Forms:
//
// 	VPSRLVD.BCST m32 zmm k zmm
// 	VPSRLVD.BCST m32 zmm zmm
// 	VPSRLVD.BCST m32 xmm k xmm
// 	VPSRLVD.BCST m32 xmm xmm
// 	VPSRLVD.BCST m32 ymm k ymm
// 	VPSRLVD.BCST m32 ymm ymm
func VPSRLVD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLVD_BCST: bad operands")
}

// VPSRLVD_BCST_Z: Variable Shift Packed Doubleword Data Right Logical (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSRLVD.BCST.Z m32 zmm k zmm
// 	VPSRLVD.BCST.Z m32 xmm k xmm
// 	VPSRLVD.BCST.Z m32 ymm k ymm
func VPSRLVD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRLVD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRLVD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLVD_BCST_Z: bad operands")
}

// VPSRLVD_Z: Variable Shift Packed Doubleword Data Right Logical (Zeroing Masking).
//
// Forms:
//
// 	VPSRLVD.Z m512 zmm k zmm
// 	VPSRLVD.Z zmm  zmm k zmm
// 	VPSRLVD.Z m128 xmm k xmm
// 	VPSRLVD.Z m256 ymm k ymm
// 	VPSRLVD.Z xmm  xmm k xmm
// 	VPSRLVD.Z ymm  ymm k ymm
func VPSRLVD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRLVD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRLVD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLVD_Z: bad operands")
}

// VPSRLVQ: Variable Shift Packed Quadword Data Right Logical.
//
// Forms:
//
// 	VPSRLVQ m128 xmm xmm
// 	VPSRLVQ m256 ymm ymm
// 	VPSRLVQ xmm  xmm xmm
// 	VPSRLVQ ymm  ymm ymm
// 	VPSRLVQ m512 zmm k zmm
// 	VPSRLVQ m512 zmm zmm
// 	VPSRLVQ zmm  zmm k zmm
// 	VPSRLVQ zmm  zmm zmm
// 	VPSRLVQ m128 xmm k xmm
// 	VPSRLVQ m256 ymm k ymm
// 	VPSRLVQ xmm  xmm k xmm
// 	VPSRLVQ ymm  ymm k ymm
func VPSRLVQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLVQ: bad operands")
}

// VPSRLVQ_BCST: Variable Shift Packed Quadword Data Right Logical (Broadcast).
//
// Forms:
//
// 	VPSRLVQ.BCST m64 zmm k zmm
// 	VPSRLVQ.BCST m64 zmm zmm
// 	VPSRLVQ.BCST m64 xmm k xmm
// 	VPSRLVQ.BCST m64 xmm xmm
// 	VPSRLVQ.BCST m64 ymm k ymm
// 	VPSRLVQ.BCST m64 ymm ymm
func VPSRLVQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLVQ_BCST: bad operands")
}

// VPSRLVQ_BCST_Z: Variable Shift Packed Quadword Data Right Logical (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSRLVQ.BCST.Z m64 zmm k zmm
// 	VPSRLVQ.BCST.Z m64 xmm k xmm
// 	VPSRLVQ.BCST.Z m64 ymm k ymm
func VPSRLVQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRLVQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRLVQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLVQ_BCST_Z: bad operands")
}

// VPSRLVQ_Z: Variable Shift Packed Quadword Data Right Logical (Zeroing Masking).
//
// Forms:
//
// 	VPSRLVQ.Z m512 zmm k zmm
// 	VPSRLVQ.Z zmm  zmm k zmm
// 	VPSRLVQ.Z m128 xmm k xmm
// 	VPSRLVQ.Z m256 ymm k ymm
// 	VPSRLVQ.Z xmm  xmm k xmm
// 	VPSRLVQ.Z ymm  ymm k ymm
func VPSRLVQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRLVQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRLVQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSRLVQ_Z: bad operands")
}

// VPSRLVW: Variable Shift Packed Word Data Right Logical.
//
// Forms:
//
// 	VPSRLVW m512 zmm k zmm
// 	VPSRLVW m512 zmm zmm
// 	VPSRLVW zmm  zmm k zmm
// 	VPSRLVW zmm  zmm zmm
// 	VPSRLVW m128 xmm k xmm
// 	VPSRLVW m128 xmm xmm
// 	VPSRLVW m256 ymm k ymm
// 	VPSRLVW m256 ymm ymm
// 	VPSRLVW xmm  xmm k xmm
// 	VPSRLVW xmm  xmm xmm
// 	VPSRLVW ymm  ymm k ymm
// 	VPSRLVW ymm  ymm ymm
func VPSRLVW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLVW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSRLVW: bad operands")
}

// VPSRLVW_Z: Variable Shift Packed Word Data Right Logical (Zeroing Masking).
//
// Forms:
//
// 	VPSRLVW.Z m512 zmm k zmm
// 	VPSRLVW.Z zmm  zmm k zmm
// 	VPSRLVW.Z m128 xmm k xmm
// 	VPSRLVW.Z m256 ymm k ymm
// 	VPSRLVW.Z xmm  xmm k xmm
// 	VPSRLVW.Z ymm  ymm k ymm
func VPSRLVW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRLVW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSRLVW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSRLVW_Z: bad operands")
}

// VPSRLW: Shift Packed Word Data Right Logical.
//
// Forms:
//
// 	VPSRLW imm8 ymm  ymm
// 	VPSRLW m128 ymm  ymm
// 	VPSRLW xmm  ymm  ymm
// 	VPSRLW imm8 xmm  xmm
// 	VPSRLW m128 xmm  xmm
// 	VPSRLW xmm  xmm  xmm
// 	VPSRLW imm8 m512 k zmm
// 	VPSRLW imm8 m512 zmm
// 	VPSRLW imm8 zmm  k zmm
// 	VPSRLW imm8 zmm  zmm
// 	VPSRLW m128 zmm  k zmm
// 	VPSRLW m128 zmm  zmm
// 	VPSRLW xmm  zmm  k zmm
// 	VPSRLW xmm  zmm  zmm
// 	VPSRLW imm8 m128 k xmm
// 	VPSRLW imm8 m128 xmm
// 	VPSRLW imm8 m256 k ymm
// 	VPSRLW imm8 m256 ymm
// 	VPSRLW imm8 xmm  k xmm
// 	VPSRLW imm8 ymm  k ymm
// 	VPSRLW m128 xmm  k xmm
// 	VPSRLW m128 ymm  k ymm
// 	VPSRLW xmm  xmm  k xmm
// 	VPSRLW xmm  ymm  k ymm
func VPSRLW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSRLW: bad operands")
}

// VPSRLW_Z: Shift Packed Word Data Right Logical (Zeroing Masking).
//
// Forms:
//
// 	VPSRLW.Z imm8 m512 k zmm
// 	VPSRLW.Z imm8 zmm  k zmm
// 	VPSRLW.Z m128 zmm  k zmm
// 	VPSRLW.Z xmm  zmm  k zmm
// 	VPSRLW.Z imm8 m128 k xmm
// 	VPSRLW.Z imm8 m256 k ymm
// 	VPSRLW.Z imm8 xmm  k xmm
// 	VPSRLW.Z imm8 ymm  k ymm
// 	VPSRLW.Z m128 xmm  k xmm
// 	VPSRLW.Z m128 ymm  k ymm
// 	VPSRLW.Z xmm  xmm  k xmm
// 	VPSRLW.Z xmm  ymm  k ymm
func VPSRLW_Z(imx, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsXMM(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM128(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsXMM(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{imx, mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(imx) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsIMM8(imx) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(imx) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(imx) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VPSRLW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{imx, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSRLW_Z: bad operands")
}

// VPSUBB: Subtract Packed Byte Integers.
//
// Forms:
//
// 	VPSUBB m256 ymm ymm
// 	VPSUBB ymm  ymm ymm
// 	VPSUBB m128 xmm xmm
// 	VPSUBB xmm  xmm xmm
// 	VPSUBB m512 zmm k zmm
// 	VPSUBB m512 zmm zmm
// 	VPSUBB zmm  zmm k zmm
// 	VPSUBB zmm  zmm zmm
// 	VPSUBB m128 xmm k xmm
// 	VPSUBB m256 ymm k ymm
// 	VPSUBB xmm  xmm k xmm
// 	VPSUBB ymm  ymm k ymm
func VPSUBB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSUBB: bad operands")
}

// VPSUBB_Z: Subtract Packed Byte Integers (Zeroing Masking).
//
// Forms:
//
// 	VPSUBB.Z m512 zmm k zmm
// 	VPSUBB.Z zmm  zmm k zmm
// 	VPSUBB.Z m128 xmm k xmm
// 	VPSUBB.Z m256 ymm k ymm
// 	VPSUBB.Z xmm  xmm k xmm
// 	VPSUBB.Z ymm  ymm k ymm
func VPSUBB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBB",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBB",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSUBB_Z: bad operands")
}

// VPSUBD: Subtract Packed Doubleword Integers.
//
// Forms:
//
// 	VPSUBD m256 ymm ymm
// 	VPSUBD ymm  ymm ymm
// 	VPSUBD m128 xmm xmm
// 	VPSUBD xmm  xmm xmm
// 	VPSUBD m512 zmm k zmm
// 	VPSUBD m512 zmm zmm
// 	VPSUBD zmm  zmm k zmm
// 	VPSUBD zmm  zmm zmm
// 	VPSUBD m128 xmm k xmm
// 	VPSUBD m256 ymm k ymm
// 	VPSUBD xmm  xmm k xmm
// 	VPSUBD ymm  ymm k ymm
func VPSUBD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSUBD: bad operands")
}

// VPSUBD_BCST: Subtract Packed Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VPSUBD.BCST m32 zmm k zmm
// 	VPSUBD.BCST m32 zmm zmm
// 	VPSUBD.BCST m32 xmm k xmm
// 	VPSUBD.BCST m32 xmm xmm
// 	VPSUBD.BCST m32 ymm k ymm
// 	VPSUBD.BCST m32 ymm ymm
func VPSUBD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSUBD_BCST: bad operands")
}

// VPSUBD_BCST_Z: Subtract Packed Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSUBD.BCST.Z m32 zmm k zmm
// 	VPSUBD.BCST.Z m32 xmm k xmm
// 	VPSUBD.BCST.Z m32 ymm k ymm
func VPSUBD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSUBD_BCST_Z: bad operands")
}

// VPSUBD_Z: Subtract Packed Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPSUBD.Z m512 zmm k zmm
// 	VPSUBD.Z zmm  zmm k zmm
// 	VPSUBD.Z m128 xmm k xmm
// 	VPSUBD.Z m256 ymm k ymm
// 	VPSUBD.Z xmm  xmm k xmm
// 	VPSUBD.Z ymm  ymm k ymm
func VPSUBD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBD",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512F"},
			CancellingInputs: true,
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBD",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512VL", "AVX512F"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSUBD_Z: bad operands")
}

// VPSUBQ: Subtract Packed Quadword Integers.
//
// Forms:
//
// 	VPSUBQ m256 ymm ymm
// 	VPSUBQ ymm  ymm ymm
// 	VPSUBQ m128 xmm xmm
// 	VPSUBQ xmm  xmm xmm
// 	VPSUBQ m512 zmm k zmm
// 	VPSUBQ m512 zmm zmm
// 	VPSUBQ zmm  zmm k zmm
// 	VPSUBQ zmm  zmm zmm
// 	VPSUBQ m128 xmm k xmm
// 	VPSUBQ m256 ymm k ymm
// 	VPSUBQ xmm  xmm k xmm
// 	VPSUBQ ymm  ymm k ymm
func VPSUBQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBQ",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512F"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSUBQ: bad operands")
}

// VPSUBQ_BCST: Subtract Packed Quadword Integers (Broadcast).
//
// Forms:
//
// 	VPSUBQ.BCST m64 zmm k zmm
// 	VPSUBQ.BCST m64 zmm zmm
// 	VPSUBQ.BCST m64 xmm k xmm
// 	VPSUBQ.BCST m64 xmm xmm
// 	VPSUBQ.BCST m64 ymm k ymm
// 	VPSUBQ.BCST m64 ymm ymm
func VPSUBQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSUBQ_BCST: bad operands")
}

// VPSUBQ_BCST_Z: Subtract Packed Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPSUBQ.BCST.Z m64 zmm k zmm
// 	VPSUBQ.BCST.Z m64 xmm k xmm
// 	VPSUBQ.BCST.Z m64 ymm k ymm
func VPSUBQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSUBQ_BCST_Z: bad operands")
}

// VPSUBQ_Z: Subtract Packed Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPSUBQ.Z m512 zmm k zmm
// 	VPSUBQ.Z zmm  zmm k zmm
// 	VPSUBQ.Z m128 xmm k xmm
// 	VPSUBQ.Z m256 ymm k ymm
// 	VPSUBQ.Z xmm  xmm k xmm
// 	VPSUBQ.Z ymm  ymm k ymm
func VPSUBQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBQ",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512F"},
			CancellingInputs: true,
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBQ",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512VL", "AVX512F"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPSUBQ_Z: bad operands")
}

// VPSUBSB: Subtract Packed Signed Byte Integers with Signed Saturation.
//
// Forms:
//
// 	VPSUBSB m256 ymm ymm
// 	VPSUBSB ymm  ymm ymm
// 	VPSUBSB m128 xmm xmm
// 	VPSUBSB xmm  xmm xmm
// 	VPSUBSB m512 zmm k zmm
// 	VPSUBSB m512 zmm zmm
// 	VPSUBSB zmm  zmm k zmm
// 	VPSUBSB zmm  zmm zmm
// 	VPSUBSB m128 xmm k xmm
// 	VPSUBSB m256 ymm k ymm
// 	VPSUBSB xmm  xmm k xmm
// 	VPSUBSB ymm  ymm k ymm
func VPSUBSB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBSB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBSB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBSB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBSB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBSB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSUBSB: bad operands")
}

// VPSUBSB_Z: Subtract Packed Signed Byte Integers with Signed Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPSUBSB.Z m512 zmm k zmm
// 	VPSUBSB.Z zmm  zmm k zmm
// 	VPSUBSB.Z m128 xmm k xmm
// 	VPSUBSB.Z m256 ymm k ymm
// 	VPSUBSB.Z xmm  xmm k xmm
// 	VPSUBSB.Z ymm  ymm k ymm
func VPSUBSB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBSB",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBSB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBSB",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBSB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSUBSB_Z: bad operands")
}

// VPSUBSW: Subtract Packed Signed Word Integers with Signed Saturation.
//
// Forms:
//
// 	VPSUBSW m256 ymm ymm
// 	VPSUBSW ymm  ymm ymm
// 	VPSUBSW m128 xmm xmm
// 	VPSUBSW xmm  xmm xmm
// 	VPSUBSW m512 zmm k zmm
// 	VPSUBSW m512 zmm zmm
// 	VPSUBSW zmm  zmm k zmm
// 	VPSUBSW zmm  zmm zmm
// 	VPSUBSW m128 xmm k xmm
// 	VPSUBSW m256 ymm k ymm
// 	VPSUBSW xmm  xmm k xmm
// 	VPSUBSW ymm  ymm k ymm
func VPSUBSW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBSW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBSW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBSW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBSW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBSW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSUBSW: bad operands")
}

// VPSUBSW_Z: Subtract Packed Signed Word Integers with Signed Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPSUBSW.Z m512 zmm k zmm
// 	VPSUBSW.Z zmm  zmm k zmm
// 	VPSUBSW.Z m128 xmm k xmm
// 	VPSUBSW.Z m256 ymm k ymm
// 	VPSUBSW.Z xmm  xmm k xmm
// 	VPSUBSW.Z ymm  ymm k ymm
func VPSUBSW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBSW",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBSW",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSUBSW_Z: bad operands")
}

// VPSUBUSB: Subtract Packed Unsigned Byte Integers with Unsigned Saturation.
//
// Forms:
//
// 	VPSUBUSB m256 ymm ymm
// 	VPSUBUSB ymm  ymm ymm
// 	VPSUBUSB m128 xmm xmm
// 	VPSUBUSB xmm  xmm xmm
// 	VPSUBUSB m512 zmm k zmm
// 	VPSUBUSB m512 zmm zmm
// 	VPSUBUSB zmm  zmm k zmm
// 	VPSUBUSB zmm  zmm zmm
// 	VPSUBUSB m128 xmm k xmm
// 	VPSUBUSB m256 ymm k ymm
// 	VPSUBUSB xmm  xmm k xmm
// 	VPSUBUSB ymm  ymm k ymm
func VPSUBUSB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBUSB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBUSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBUSB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBUSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBUSB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBUSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBUSB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBUSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBUSB",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBUSB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSUBUSB: bad operands")
}

// VPSUBUSB_Z: Subtract Packed Unsigned Byte Integers with Unsigned Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPSUBUSB.Z m512 zmm k zmm
// 	VPSUBUSB.Z zmm  zmm k zmm
// 	VPSUBUSB.Z m128 xmm k xmm
// 	VPSUBUSB.Z m256 ymm k ymm
// 	VPSUBUSB.Z xmm  xmm k xmm
// 	VPSUBUSB.Z ymm  ymm k ymm
func VPSUBUSB_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBUSB",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBUSB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBUSB",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBUSB",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSUBUSB_Z: bad operands")
}

// VPSUBUSW: Subtract Packed Unsigned Word Integers with Unsigned Saturation.
//
// Forms:
//
// 	VPSUBUSW m256 ymm ymm
// 	VPSUBUSW ymm  ymm ymm
// 	VPSUBUSW m128 xmm xmm
// 	VPSUBUSW xmm  xmm xmm
// 	VPSUBUSW m512 zmm k zmm
// 	VPSUBUSW m512 zmm zmm
// 	VPSUBUSW zmm  zmm k zmm
// 	VPSUBUSW zmm  zmm zmm
// 	VPSUBUSW m128 xmm k xmm
// 	VPSUBUSW m256 ymm k ymm
// 	VPSUBUSW xmm  xmm k xmm
// 	VPSUBUSW ymm  ymm k ymm
func VPSUBUSW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBUSW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBUSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBUSW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBUSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBUSW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBUSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBUSW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBUSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBUSW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBUSW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSUBUSW: bad operands")
}

// VPSUBUSW_Z: Subtract Packed Unsigned Word Integers with Unsigned Saturation (Zeroing Masking).
//
// Forms:
//
// 	VPSUBUSW.Z m512 zmm k zmm
// 	VPSUBUSW.Z zmm  zmm k zmm
// 	VPSUBUSW.Z m128 xmm k xmm
// 	VPSUBUSW.Z m256 ymm k ymm
// 	VPSUBUSW.Z xmm  xmm k xmm
// 	VPSUBUSW.Z ymm  ymm k ymm
func VPSUBUSW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBUSW",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBUSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBUSW",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBUSW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSUBUSW_Z: bad operands")
}

// VPSUBW: Subtract Packed Word Integers.
//
// Forms:
//
// 	VPSUBW m256 ymm ymm
// 	VPSUBW ymm  ymm ymm
// 	VPSUBW m128 xmm xmm
// 	VPSUBW xmm  xmm xmm
// 	VPSUBW m512 zmm k zmm
// 	VPSUBW m512 zmm zmm
// 	VPSUBW zmm  zmm k zmm
// 	VPSUBW zmm  zmm zmm
// 	VPSUBW m128 xmm k xmm
// 	VPSUBW m256 ymm k ymm
// 	VPSUBW xmm  xmm k xmm
// 	VPSUBW ymm  ymm k ymm
func VPSUBW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VPSUBW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPSUBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VPSUBW",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPSUBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSUBW: bad operands")
}

// VPSUBW_Z: Subtract Packed Word Integers (Zeroing Masking).
//
// Forms:
//
// 	VPSUBW.Z m512 zmm k zmm
// 	VPSUBW.Z zmm  zmm k zmm
// 	VPSUBW.Z m128 xmm k xmm
// 	VPSUBW.Z m256 ymm k ymm
// 	VPSUBW.Z xmm  xmm k xmm
// 	VPSUBW.Z ymm  ymm k ymm
func VPSUBW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBW",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512BW"},
			CancellingInputs: true,
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VPSUBW",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512VL", "AVX512BW"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPSUBW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPSUBW_Z: bad operands")
}

// VPTERNLOGD: Bitwise Ternary Logical Operation on Doubleword Values.
//
// Forms:
//
// 	VPTERNLOGD imm8 m512 zmm k zmm
// 	VPTERNLOGD imm8 m512 zmm zmm
// 	VPTERNLOGD imm8 zmm  zmm k zmm
// 	VPTERNLOGD imm8 zmm  zmm zmm
// 	VPTERNLOGD imm8 m128 xmm k xmm
// 	VPTERNLOGD imm8 m128 xmm xmm
// 	VPTERNLOGD imm8 m256 ymm k ymm
// 	VPTERNLOGD imm8 m256 ymm ymm
// 	VPTERNLOGD imm8 xmm  xmm k xmm
// 	VPTERNLOGD imm8 xmm  xmm xmm
// 	VPTERNLOGD imm8 ymm  ymm k ymm
// 	VPTERNLOGD imm8 ymm  ymm ymm
func VPTERNLOGD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTERNLOGD: bad operands")
}

// VPTERNLOGD_BCST: Bitwise Ternary Logical Operation on Doubleword Values (Broadcast).
//
// Forms:
//
// 	VPTERNLOGD.BCST imm8 m32 zmm k zmm
// 	VPTERNLOGD.BCST imm8 m32 zmm zmm
// 	VPTERNLOGD.BCST imm8 m32 xmm k xmm
// 	VPTERNLOGD.BCST imm8 m32 xmm xmm
// 	VPTERNLOGD.BCST imm8 m32 ymm k ymm
// 	VPTERNLOGD.BCST imm8 m32 ymm ymm
func VPTERNLOGD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTERNLOGD_BCST: bad operands")
}

// VPTERNLOGD_BCST_Z: Bitwise Ternary Logical Operation on Doubleword Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPTERNLOGD.BCST.Z imm8 m32 zmm k zmm
// 	VPTERNLOGD.BCST.Z imm8 m32 xmm k xmm
// 	VPTERNLOGD.BCST.Z imm8 m32 ymm k ymm
func VPTERNLOGD_BCST_Z(i, m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTERNLOGD_BCST_Z: bad operands")
}

// VPTERNLOGD_Z: Bitwise Ternary Logical Operation on Doubleword Values (Zeroing Masking).
//
// Forms:
//
// 	VPTERNLOGD.Z imm8 m512 zmm k zmm
// 	VPTERNLOGD.Z imm8 zmm  zmm k zmm
// 	VPTERNLOGD.Z imm8 m128 xmm k xmm
// 	VPTERNLOGD.Z imm8 m256 ymm k ymm
// 	VPTERNLOGD.Z imm8 xmm  xmm k xmm
// 	VPTERNLOGD.Z imm8 ymm  ymm k ymm
func VPTERNLOGD_Z(i, mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTERNLOGD_Z: bad operands")
}

// VPTERNLOGQ: Bitwise Ternary Logical Operation on Quadword Values.
//
// Forms:
//
// 	VPTERNLOGQ imm8 m512 zmm k zmm
// 	VPTERNLOGQ imm8 m512 zmm zmm
// 	VPTERNLOGQ imm8 zmm  zmm k zmm
// 	VPTERNLOGQ imm8 zmm  zmm zmm
// 	VPTERNLOGQ imm8 m128 xmm k xmm
// 	VPTERNLOGQ imm8 m128 xmm xmm
// 	VPTERNLOGQ imm8 m256 ymm k ymm
// 	VPTERNLOGQ imm8 m256 ymm ymm
// 	VPTERNLOGQ imm8 xmm  xmm k xmm
// 	VPTERNLOGQ imm8 xmm  xmm xmm
// 	VPTERNLOGQ imm8 ymm  ymm k ymm
// 	VPTERNLOGQ imm8 ymm  ymm ymm
func VPTERNLOGQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTERNLOGQ: bad operands")
}

// VPTERNLOGQ_BCST: Bitwise Ternary Logical Operation on Quadword Values (Broadcast).
//
// Forms:
//
// 	VPTERNLOGQ.BCST imm8 m64 zmm k zmm
// 	VPTERNLOGQ.BCST imm8 m64 zmm zmm
// 	VPTERNLOGQ.BCST imm8 m64 xmm k xmm
// 	VPTERNLOGQ.BCST imm8 m64 xmm xmm
// 	VPTERNLOGQ.BCST imm8 m64 ymm k ymm
// 	VPTERNLOGQ.BCST imm8 m64 ymm ymm
func VPTERNLOGQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTERNLOGQ_BCST: bad operands")
}

// VPTERNLOGQ_BCST_Z: Bitwise Ternary Logical Operation on Quadword Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPTERNLOGQ.BCST.Z imm8 m64 zmm k zmm
// 	VPTERNLOGQ.BCST.Z imm8 m64 xmm k xmm
// 	VPTERNLOGQ.BCST.Z imm8 m64 ymm k ymm
func VPTERNLOGQ_BCST_Z(i, m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTERNLOGQ_BCST_Z: bad operands")
}

// VPTERNLOGQ_Z: Bitwise Ternary Logical Operation on Quadword Values (Zeroing Masking).
//
// Forms:
//
// 	VPTERNLOGQ.Z imm8 m512 zmm k zmm
// 	VPTERNLOGQ.Z imm8 zmm  zmm k zmm
// 	VPTERNLOGQ.Z imm8 m128 xmm k xmm
// 	VPTERNLOGQ.Z imm8 m256 ymm k ymm
// 	VPTERNLOGQ.Z imm8 xmm  xmm k xmm
// 	VPTERNLOGQ.Z imm8 ymm  ymm k ymm
func VPTERNLOGQ_Z(i, mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPTERNLOGQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k, xyz1},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTERNLOGQ_Z: bad operands")
}

// VPTEST: Packed Logical Compare.
//
// Forms:
//
// 	VPTEST m128 xmm
// 	VPTEST m256 ymm
// 	VPTEST xmm  xmm
// 	VPTEST ymm  ymm
func VPTEST(mxy, xy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy),
		operand.IsM256(mxy) && operand.IsYMM(xy),
		operand.IsXMM(mxy) && operand.IsXMM(xy),
		operand.IsYMM(mxy) && operand.IsYMM(xy):
		return &intrep.Instruction{
			Opcode:   "VPTEST",
			Operands: []operand.Op{mxy, xy},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VPTEST: bad operands")
}

// VPTESTMB: Logical AND of Packed Byte Integer Values and Set Mask.
//
// Forms:
//
// 	VPTESTMB m512 zmm k k
// 	VPTESTMB m512 zmm k
// 	VPTESTMB zmm  zmm k k
// 	VPTESTMB zmm  zmm k
// 	VPTESTMB m128 xmm k k
// 	VPTESTMB m128 xmm k
// 	VPTESTMB m256 ymm k k
// 	VPTESTMB m256 ymm k
// 	VPTESTMB xmm  xmm k k
// 	VPTESTMB xmm  xmm k
// 	VPTESTMB ymm  ymm k k
// 	VPTESTMB ymm  ymm k
func VPTESTMB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPTESTMB: bad operands")
}

// VPTESTMD: Logical AND of Packed Doubleword Integer Values and Set Mask.
//
// Forms:
//
// 	VPTESTMD m512 zmm k k
// 	VPTESTMD m512 zmm k
// 	VPTESTMD zmm  zmm k k
// 	VPTESTMD zmm  zmm k
// 	VPTESTMD m128 xmm k k
// 	VPTESTMD m128 xmm k
// 	VPTESTMD m256 ymm k k
// 	VPTESTMD m256 ymm k
// 	VPTESTMD xmm  xmm k k
// 	VPTESTMD xmm  xmm k
// 	VPTESTMD ymm  ymm k k
// 	VPTESTMD ymm  ymm k
func VPTESTMD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTESTMD: bad operands")
}

// VPTESTMD_BCST: Logical AND of Packed Doubleword Integer Values and Set Mask (Broadcast).
//
// Forms:
//
// 	VPTESTMD.BCST m32 zmm k k
// 	VPTESTMD.BCST m32 zmm k
// 	VPTESTMD.BCST m32 xmm k k
// 	VPTESTMD.BCST m32 xmm k
// 	VPTESTMD.BCST m32 ymm k k
// 	VPTESTMD.BCST m32 ymm k
func VPTESTMD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTESTMD_BCST: bad operands")
}

// VPTESTMQ: Logical AND of Packed Quadword Integer Values and Set Mask.
//
// Forms:
//
// 	VPTESTMQ m512 zmm k k
// 	VPTESTMQ m512 zmm k
// 	VPTESTMQ zmm  zmm k k
// 	VPTESTMQ zmm  zmm k
// 	VPTESTMQ m128 xmm k k
// 	VPTESTMQ m128 xmm k
// 	VPTESTMQ m256 ymm k k
// 	VPTESTMQ m256 ymm k
// 	VPTESTMQ xmm  xmm k k
// 	VPTESTMQ xmm  xmm k
// 	VPTESTMQ ymm  ymm k k
// 	VPTESTMQ ymm  ymm k
func VPTESTMQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTESTMQ: bad operands")
}

// VPTESTMQ_BCST: Logical AND of Packed Quadword Integer Values and Set Mask (Broadcast).
//
// Forms:
//
// 	VPTESTMQ.BCST m64 zmm k k
// 	VPTESTMQ.BCST m64 zmm k
// 	VPTESTMQ.BCST m64 xmm k k
// 	VPTESTMQ.BCST m64 xmm k
// 	VPTESTMQ.BCST m64 ymm k k
// 	VPTESTMQ.BCST m64 ymm k
func VPTESTMQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTESTMQ_BCST: bad operands")
}

// VPTESTMW: Logical AND of Packed Word Integer Values and Set Mask.
//
// Forms:
//
// 	VPTESTMW m512 zmm k k
// 	VPTESTMW m512 zmm k
// 	VPTESTMW zmm  zmm k k
// 	VPTESTMW zmm  zmm k
// 	VPTESTMW m128 xmm k k
// 	VPTESTMW m128 xmm k
// 	VPTESTMW m256 ymm k k
// 	VPTESTMW m256 ymm k
// 	VPTESTMW xmm  xmm k k
// 	VPTESTMW xmm  xmm k
// 	VPTESTMW ymm  ymm k k
// 	VPTESTMW ymm  ymm k
func VPTESTMW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPTESTMW: bad operands")
}

// VPTESTNMB: Logical NAND of Packed Byte Integer Values and Set Mask.
//
// Forms:
//
// 	VPTESTNMB m512 zmm k k
// 	VPTESTNMB m512 zmm k
// 	VPTESTNMB zmm  zmm k k
// 	VPTESTNMB zmm  zmm k
// 	VPTESTNMB m128 xmm k k
// 	VPTESTNMB m128 xmm k
// 	VPTESTNMB m256 ymm k k
// 	VPTESTNMB m256 ymm k
// 	VPTESTNMB xmm  xmm k k
// 	VPTESTNMB xmm  xmm k
// 	VPTESTNMB ymm  ymm k k
// 	VPTESTNMB ymm  ymm k
func VPTESTNMB(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F", "AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMB",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPTESTNMB: bad operands")
}

// VPTESTNMD: Logical NAND of Packed Doubleword Integer Values and Set Mask.
//
// Forms:
//
// 	VPTESTNMD m512 zmm k k
// 	VPTESTNMD m512 zmm k
// 	VPTESTNMD zmm  zmm k k
// 	VPTESTNMD zmm  zmm k
// 	VPTESTNMD m128 xmm k k
// 	VPTESTNMD m128 xmm k
// 	VPTESTNMD m256 ymm k k
// 	VPTESTNMD m256 ymm k
// 	VPTESTNMD xmm  xmm k k
// 	VPTESTNMD xmm  xmm k
// 	VPTESTNMD ymm  ymm k k
// 	VPTESTNMD ymm  ymm k
func VPTESTNMD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTESTNMD: bad operands")
}

// VPTESTNMD_BCST: Logical NAND of Packed Doubleword Integer Values and Set Mask (Broadcast).
//
// Forms:
//
// 	VPTESTNMD.BCST m32 zmm k k
// 	VPTESTNMD.BCST m32 zmm k
// 	VPTESTNMD.BCST m32 xmm k k
// 	VPTESTNMD.BCST m32 xmm k
// 	VPTESTNMD.BCST m32 ymm k k
// 	VPTESTNMD.BCST m32 ymm k
func VPTESTNMD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTESTNMD_BCST: bad operands")
}

// VPTESTNMQ: Logical NAND of Packed Quadword Integer Values and Set Mask.
//
// Forms:
//
// 	VPTESTNMQ m512 zmm k k
// 	VPTESTNMQ m512 zmm k
// 	VPTESTNMQ zmm  zmm k k
// 	VPTESTNMQ zmm  zmm k
// 	VPTESTNMQ m128 xmm k k
// 	VPTESTNMQ m128 xmm k
// 	VPTESTNMQ m256 ymm k k
// 	VPTESTNMQ m256 ymm k
// 	VPTESTNMQ xmm  xmm k k
// 	VPTESTNMQ xmm  xmm k
// 	VPTESTNMQ ymm  ymm k k
// 	VPTESTNMQ ymm  ymm k
func VPTESTNMQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTESTNMQ: bad operands")
}

// VPTESTNMQ_BCST: Logical NAND of Packed Quadword Integer Values and Set Mask (Broadcast).
//
// Forms:
//
// 	VPTESTNMQ.BCST m64 zmm k k
// 	VPTESTNMQ.BCST m64 zmm k
// 	VPTESTNMQ.BCST m64 xmm k k
// 	VPTESTNMQ.BCST m64 xmm k
// 	VPTESTNMQ.BCST m64 ymm k k
// 	VPTESTNMQ.BCST m64 ymm k
func VPTESTNMQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPTESTNMQ_BCST: bad operands")
}

// VPTESTNMW: Logical NAND of Packed Word Integer Values and Set Mask.
//
// Forms:
//
// 	VPTESTNMW m512 zmm k k
// 	VPTESTNMW m512 zmm k
// 	VPTESTNMW zmm  zmm k k
// 	VPTESTNMW zmm  zmm k
// 	VPTESTNMW m128 xmm k k
// 	VPTESTNMW m128 xmm k
// 	VPTESTNMW m256 ymm k k
// 	VPTESTNMW m256 ymm k
// 	VPTESTNMW xmm  xmm k k
// 	VPTESTNMW xmm  xmm k
// 	VPTESTNMW ymm  ymm k k
// 	VPTESTNMW ymm  ymm k
func VPTESTNMW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F", "AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsK(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPTESTNMW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPTESTNMW: bad operands")
}

// VPUNPCKHBW: Unpack and Interleave High-Order Bytes into Words.
//
// Forms:
//
// 	VPUNPCKHBW m256 ymm ymm
// 	VPUNPCKHBW ymm  ymm ymm
// 	VPUNPCKHBW m128 xmm xmm
// 	VPUNPCKHBW xmm  xmm xmm
// 	VPUNPCKHBW m512 zmm k zmm
// 	VPUNPCKHBW m512 zmm zmm
// 	VPUNPCKHBW zmm  zmm k zmm
// 	VPUNPCKHBW zmm  zmm zmm
// 	VPUNPCKHBW m128 xmm k xmm
// 	VPUNPCKHBW m256 ymm k ymm
// 	VPUNPCKHBW xmm  xmm k xmm
// 	VPUNPCKHBW ymm  ymm k ymm
func VPUNPCKHBW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPUNPCKHBW: bad operands")
}

// VPUNPCKHBW_Z: Unpack and Interleave High-Order Bytes into Words (Zeroing Masking).
//
// Forms:
//
// 	VPUNPCKHBW.Z m512 zmm k zmm
// 	VPUNPCKHBW.Z zmm  zmm k zmm
// 	VPUNPCKHBW.Z m128 xmm k xmm
// 	VPUNPCKHBW.Z m256 ymm k ymm
// 	VPUNPCKHBW.Z xmm  xmm k xmm
// 	VPUNPCKHBW.Z ymm  ymm k ymm
func VPUNPCKHBW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHBW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHBW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPUNPCKHBW_Z: bad operands")
}

// VPUNPCKHDQ: Unpack and Interleave High-Order Doublewords into Quadwords.
//
// Forms:
//
// 	VPUNPCKHDQ m256 ymm ymm
// 	VPUNPCKHDQ ymm  ymm ymm
// 	VPUNPCKHDQ m128 xmm xmm
// 	VPUNPCKHDQ xmm  xmm xmm
// 	VPUNPCKHDQ m512 zmm k zmm
// 	VPUNPCKHDQ m512 zmm zmm
// 	VPUNPCKHDQ zmm  zmm k zmm
// 	VPUNPCKHDQ zmm  zmm zmm
// 	VPUNPCKHDQ m128 xmm k xmm
// 	VPUNPCKHDQ m256 ymm k ymm
// 	VPUNPCKHDQ xmm  xmm k xmm
// 	VPUNPCKHDQ ymm  ymm k ymm
func VPUNPCKHDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKHDQ: bad operands")
}

// VPUNPCKHDQ_BCST: Unpack and Interleave High-Order Doublewords into Quadwords (Broadcast).
//
// Forms:
//
// 	VPUNPCKHDQ.BCST m32 zmm k zmm
// 	VPUNPCKHDQ.BCST m32 zmm zmm
// 	VPUNPCKHDQ.BCST m32 xmm k xmm
// 	VPUNPCKHDQ.BCST m32 xmm xmm
// 	VPUNPCKHDQ.BCST m32 ymm k ymm
// 	VPUNPCKHDQ.BCST m32 ymm ymm
func VPUNPCKHDQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKHDQ_BCST: bad operands")
}

// VPUNPCKHDQ_BCST_Z: Unpack and Interleave High-Order Doublewords into Quadwords (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPUNPCKHDQ.BCST.Z m32 zmm k zmm
// 	VPUNPCKHDQ.BCST.Z m32 xmm k xmm
// 	VPUNPCKHDQ.BCST.Z m32 ymm k ymm
func VPUNPCKHDQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKHDQ_BCST_Z: bad operands")
}

// VPUNPCKHDQ_Z: Unpack and Interleave High-Order Doublewords into Quadwords (Zeroing Masking).
//
// Forms:
//
// 	VPUNPCKHDQ.Z m512 zmm k zmm
// 	VPUNPCKHDQ.Z zmm  zmm k zmm
// 	VPUNPCKHDQ.Z m128 xmm k xmm
// 	VPUNPCKHDQ.Z m256 ymm k ymm
// 	VPUNPCKHDQ.Z xmm  xmm k xmm
// 	VPUNPCKHDQ.Z ymm  ymm k ymm
func VPUNPCKHDQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKHDQ_Z: bad operands")
}

// VPUNPCKHQDQ: Unpack and Interleave High-Order Quadwords into Double Quadwords.
//
// Forms:
//
// 	VPUNPCKHQDQ m256 ymm ymm
// 	VPUNPCKHQDQ ymm  ymm ymm
// 	VPUNPCKHQDQ m128 xmm xmm
// 	VPUNPCKHQDQ xmm  xmm xmm
// 	VPUNPCKHQDQ m512 zmm k zmm
// 	VPUNPCKHQDQ m512 zmm zmm
// 	VPUNPCKHQDQ zmm  zmm k zmm
// 	VPUNPCKHQDQ zmm  zmm zmm
// 	VPUNPCKHQDQ m128 xmm k xmm
// 	VPUNPCKHQDQ m256 ymm k ymm
// 	VPUNPCKHQDQ xmm  xmm k xmm
// 	VPUNPCKHQDQ ymm  ymm k ymm
func VPUNPCKHQDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHQDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHQDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHQDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHQDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHQDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKHQDQ: bad operands")
}

// VPUNPCKHQDQ_BCST: Unpack and Interleave High-Order Quadwords into Double Quadwords (Broadcast).
//
// Forms:
//
// 	VPUNPCKHQDQ.BCST m64 zmm k zmm
// 	VPUNPCKHQDQ.BCST m64 zmm zmm
// 	VPUNPCKHQDQ.BCST m64 xmm k xmm
// 	VPUNPCKHQDQ.BCST m64 xmm xmm
// 	VPUNPCKHQDQ.BCST m64 ymm k ymm
// 	VPUNPCKHQDQ.BCST m64 ymm ymm
func VPUNPCKHQDQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHQDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHQDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHQDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHQDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKHQDQ_BCST: bad operands")
}

// VPUNPCKHQDQ_BCST_Z: Unpack and Interleave High-Order Quadwords into Double Quadwords (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPUNPCKHQDQ.BCST.Z m64 zmm k zmm
// 	VPUNPCKHQDQ.BCST.Z m64 xmm k xmm
// 	VPUNPCKHQDQ.BCST.Z m64 ymm k ymm
func VPUNPCKHQDQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHQDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHQDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKHQDQ_BCST_Z: bad operands")
}

// VPUNPCKHQDQ_Z: Unpack and Interleave High-Order Quadwords into Double Quadwords (Zeroing Masking).
//
// Forms:
//
// 	VPUNPCKHQDQ.Z m512 zmm k zmm
// 	VPUNPCKHQDQ.Z zmm  zmm k zmm
// 	VPUNPCKHQDQ.Z m128 xmm k xmm
// 	VPUNPCKHQDQ.Z m256 ymm k ymm
// 	VPUNPCKHQDQ.Z xmm  xmm k xmm
// 	VPUNPCKHQDQ.Z ymm  ymm k ymm
func VPUNPCKHQDQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHQDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHQDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKHQDQ_Z: bad operands")
}

// VPUNPCKHWD: Unpack and Interleave High-Order Words into Doublewords.
//
// Forms:
//
// 	VPUNPCKHWD m256 ymm ymm
// 	VPUNPCKHWD ymm  ymm ymm
// 	VPUNPCKHWD m128 xmm xmm
// 	VPUNPCKHWD xmm  xmm xmm
// 	VPUNPCKHWD m512 zmm k zmm
// 	VPUNPCKHWD m512 zmm zmm
// 	VPUNPCKHWD zmm  zmm k zmm
// 	VPUNPCKHWD zmm  zmm zmm
// 	VPUNPCKHWD m128 xmm k xmm
// 	VPUNPCKHWD m256 ymm k ymm
// 	VPUNPCKHWD xmm  xmm k xmm
// 	VPUNPCKHWD ymm  ymm k ymm
func VPUNPCKHWD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPUNPCKHWD: bad operands")
}

// VPUNPCKHWD_Z: Unpack and Interleave High-Order Words into Doublewords (Zeroing Masking).
//
// Forms:
//
// 	VPUNPCKHWD.Z m512 zmm k zmm
// 	VPUNPCKHWD.Z zmm  zmm k zmm
// 	VPUNPCKHWD.Z m128 xmm k xmm
// 	VPUNPCKHWD.Z m256 ymm k ymm
// 	VPUNPCKHWD.Z xmm  xmm k xmm
// 	VPUNPCKHWD.Z ymm  ymm k ymm
func VPUNPCKHWD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHWD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKHWD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPUNPCKHWD_Z: bad operands")
}

// VPUNPCKLBW: Unpack and Interleave Low-Order Bytes into Words.
//
// Forms:
//
// 	VPUNPCKLBW m256 ymm ymm
// 	VPUNPCKLBW ymm  ymm ymm
// 	VPUNPCKLBW m128 xmm xmm
// 	VPUNPCKLBW xmm  xmm xmm
// 	VPUNPCKLBW m512 zmm k zmm
// 	VPUNPCKLBW m512 zmm zmm
// 	VPUNPCKLBW zmm  zmm k zmm
// 	VPUNPCKLBW zmm  zmm zmm
// 	VPUNPCKLBW m128 xmm k xmm
// 	VPUNPCKLBW m256 ymm k ymm
// 	VPUNPCKLBW xmm  xmm k xmm
// 	VPUNPCKLBW ymm  ymm k ymm
func VPUNPCKLBW(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLBW",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPUNPCKLBW: bad operands")
}

// VPUNPCKLBW_Z: Unpack and Interleave Low-Order Bytes into Words (Zeroing Masking).
//
// Forms:
//
// 	VPUNPCKLBW.Z m512 zmm k zmm
// 	VPUNPCKLBW.Z zmm  zmm k zmm
// 	VPUNPCKLBW.Z m128 xmm k xmm
// 	VPUNPCKLBW.Z m256 ymm k ymm
// 	VPUNPCKLBW.Z xmm  xmm k xmm
// 	VPUNPCKLBW.Z ymm  ymm k ymm
func VPUNPCKLBW_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLBW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLBW",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPUNPCKLBW_Z: bad operands")
}

// VPUNPCKLDQ: Unpack and Interleave Low-Order Doublewords into Quadwords.
//
// Forms:
//
// 	VPUNPCKLDQ m256 ymm ymm
// 	VPUNPCKLDQ ymm  ymm ymm
// 	VPUNPCKLDQ m128 xmm xmm
// 	VPUNPCKLDQ xmm  xmm xmm
// 	VPUNPCKLDQ m512 zmm k zmm
// 	VPUNPCKLDQ m512 zmm zmm
// 	VPUNPCKLDQ zmm  zmm k zmm
// 	VPUNPCKLDQ zmm  zmm zmm
// 	VPUNPCKLDQ m128 xmm k xmm
// 	VPUNPCKLDQ m256 ymm k ymm
// 	VPUNPCKLDQ xmm  xmm k xmm
// 	VPUNPCKLDQ ymm  ymm k ymm
func VPUNPCKLDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKLDQ: bad operands")
}

// VPUNPCKLDQ_BCST: Unpack and Interleave Low-Order Doublewords into Quadwords (Broadcast).
//
// Forms:
//
// 	VPUNPCKLDQ.BCST m32 zmm k zmm
// 	VPUNPCKLDQ.BCST m32 zmm zmm
// 	VPUNPCKLDQ.BCST m32 xmm k xmm
// 	VPUNPCKLDQ.BCST m32 xmm xmm
// 	VPUNPCKLDQ.BCST m32 ymm k ymm
// 	VPUNPCKLDQ.BCST m32 ymm ymm
func VPUNPCKLDQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKLDQ_BCST: bad operands")
}

// VPUNPCKLDQ_BCST_Z: Unpack and Interleave Low-Order Doublewords into Quadwords (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPUNPCKLDQ.BCST.Z m32 zmm k zmm
// 	VPUNPCKLDQ.BCST.Z m32 xmm k xmm
// 	VPUNPCKLDQ.BCST.Z m32 ymm k ymm
func VPUNPCKLDQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKLDQ_BCST_Z: bad operands")
}

// VPUNPCKLDQ_Z: Unpack and Interleave Low-Order Doublewords into Quadwords (Zeroing Masking).
//
// Forms:
//
// 	VPUNPCKLDQ.Z m512 zmm k zmm
// 	VPUNPCKLDQ.Z zmm  zmm k zmm
// 	VPUNPCKLDQ.Z m128 xmm k xmm
// 	VPUNPCKLDQ.Z m256 ymm k ymm
// 	VPUNPCKLDQ.Z xmm  xmm k xmm
// 	VPUNPCKLDQ.Z ymm  ymm k ymm
func VPUNPCKLDQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKLDQ_Z: bad operands")
}

// VPUNPCKLQDQ: Unpack and Interleave Low-Order Quadwords into Double Quadwords.
//
// Forms:
//
// 	VPUNPCKLQDQ m256 ymm ymm
// 	VPUNPCKLQDQ ymm  ymm ymm
// 	VPUNPCKLQDQ m128 xmm xmm
// 	VPUNPCKLQDQ xmm  xmm xmm
// 	VPUNPCKLQDQ m512 zmm k zmm
// 	VPUNPCKLQDQ m512 zmm zmm
// 	VPUNPCKLQDQ zmm  zmm k zmm
// 	VPUNPCKLQDQ zmm  zmm zmm
// 	VPUNPCKLQDQ m128 xmm k xmm
// 	VPUNPCKLQDQ m256 ymm k ymm
// 	VPUNPCKLQDQ xmm  xmm k xmm
// 	VPUNPCKLQDQ ymm  ymm k ymm
func VPUNPCKLQDQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLQDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLQDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLQDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLQDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLQDQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKLQDQ: bad operands")
}

// VPUNPCKLQDQ_BCST: Unpack and Interleave Low-Order Quadwords into Double Quadwords (Broadcast).
//
// Forms:
//
// 	VPUNPCKLQDQ.BCST m64 zmm k zmm
// 	VPUNPCKLQDQ.BCST m64 zmm zmm
// 	VPUNPCKLQDQ.BCST m64 xmm k xmm
// 	VPUNPCKLQDQ.BCST m64 xmm xmm
// 	VPUNPCKLQDQ.BCST m64 ymm k ymm
// 	VPUNPCKLQDQ.BCST m64 ymm ymm
func VPUNPCKLQDQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLQDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLQDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLQDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLQDQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKLQDQ_BCST: bad operands")
}

// VPUNPCKLQDQ_BCST_Z: Unpack and Interleave Low-Order Quadwords into Double Quadwords (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPUNPCKLQDQ.BCST.Z m64 zmm k zmm
// 	VPUNPCKLQDQ.BCST.Z m64 xmm k xmm
// 	VPUNPCKLQDQ.BCST.Z m64 ymm k ymm
func VPUNPCKLQDQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLQDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLQDQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKLQDQ_BCST_Z: bad operands")
}

// VPUNPCKLQDQ_Z: Unpack and Interleave Low-Order Quadwords into Double Quadwords (Zeroing Masking).
//
// Forms:
//
// 	VPUNPCKLQDQ.Z m512 zmm k zmm
// 	VPUNPCKLQDQ.Z zmm  zmm k zmm
// 	VPUNPCKLQDQ.Z m128 xmm k xmm
// 	VPUNPCKLQDQ.Z m256 ymm k ymm
// 	VPUNPCKLQDQ.Z xmm  xmm k xmm
// 	VPUNPCKLQDQ.Z ymm  ymm k ymm
func VPUNPCKLQDQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLQDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLQDQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPUNPCKLQDQ_Z: bad operands")
}

// VPUNPCKLWD: Unpack and Interleave Low-Order Words into Doublewords.
//
// Forms:
//
// 	VPUNPCKLWD m256 ymm ymm
// 	VPUNPCKLWD ymm  ymm ymm
// 	VPUNPCKLWD m128 xmm xmm
// 	VPUNPCKLWD xmm  xmm xmm
// 	VPUNPCKLWD m512 zmm k zmm
// 	VPUNPCKLWD m512 zmm zmm
// 	VPUNPCKLWD zmm  zmm k zmm
// 	VPUNPCKLWD zmm  zmm zmm
// 	VPUNPCKLWD m128 xmm k xmm
// 	VPUNPCKLWD m256 ymm k ymm
// 	VPUNPCKLWD xmm  xmm k xmm
// 	VPUNPCKLWD ymm  ymm k ymm
func VPUNPCKLWD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512BW"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX2"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLWD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPUNPCKLWD: bad operands")
}

// VPUNPCKLWD_Z: Unpack and Interleave Low-Order Words into Doublewords (Zeroing Masking).
//
// Forms:
//
// 	VPUNPCKLWD.Z m512 zmm k zmm
// 	VPUNPCKLWD.Z zmm  zmm k zmm
// 	VPUNPCKLWD.Z m128 xmm k xmm
// 	VPUNPCKLWD.Z m256 ymm k ymm
// 	VPUNPCKLWD.Z xmm  xmm k xmm
// 	VPUNPCKLWD.Z ymm  ymm k ymm
func VPUNPCKLWD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLWD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512BW"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPUNPCKLWD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512BW"},
		}, nil
	}
	return nil, errors.New("VPUNPCKLWD_Z: bad operands")
}

// VPXOR: Packed Bitwise Logical Exclusive OR.
//
// Forms:
//
// 	VPXOR m256 ymm ymm
// 	VPXOR ymm  ymm ymm
// 	VPXOR m128 xmm xmm
// 	VPXOR xmm  xmm xmm
func VPXOR(mxy, xy, xy1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:           "VPXOR",
			Operands:         []operand.Op{mxy, xy, xy1},
			Inputs:           []operand.Op{mxy, xy},
			Outputs:          []operand.Op{xy1},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxy) && operand.IsXMM(xy) && operand.IsXMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPXOR",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX"},
		}, nil
	case operand.IsYMM(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:           "VPXOR",
			Operands:         []operand.Op{mxy, xy, xy1},
			Inputs:           []operand.Op{mxy, xy},
			Outputs:          []operand.Op{xy1},
			ISA:              []string{"AVX2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM256(mxy) && operand.IsYMM(xy) && operand.IsYMM(xy1):
		return &intrep.Instruction{
			Opcode:   "VPXOR",
			Operands: []operand.Op{mxy, xy, xy1},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{xy1},
			ISA:      []string{"AVX2"},
		}, nil
	}
	return nil, errors.New("VPXOR: bad operands")
}

// VPXORD: Bitwise Logical Exclusive OR of Packed Doubleword Integers.
//
// Forms:
//
// 	VPXORD m512 zmm k zmm
// 	VPXORD m512 zmm zmm
// 	VPXORD zmm  zmm k zmm
// 	VPXORD zmm  zmm zmm
// 	VPXORD m128 xmm k xmm
// 	VPXORD m128 xmm xmm
// 	VPXORD m256 ymm k ymm
// 	VPXORD m256 ymm ymm
// 	VPXORD xmm  xmm k xmm
// 	VPXORD xmm  xmm xmm
// 	VPXORD ymm  ymm k ymm
// 	VPXORD ymm  ymm ymm
func VPXORD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPXORD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPXORD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPXORD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPXORD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPXORD: bad operands")
}

// VPXORD_BCST: Bitwise Logical Exclusive OR of Packed Doubleword Integers (Broadcast).
//
// Forms:
//
// 	VPXORD.BCST m32 zmm k zmm
// 	VPXORD.BCST m32 zmm zmm
// 	VPXORD.BCST m32 xmm k xmm
// 	VPXORD.BCST m32 xmm xmm
// 	VPXORD.BCST m32 ymm k ymm
// 	VPXORD.BCST m32 ymm ymm
func VPXORD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPXORD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPXORD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPXORD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPXORD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPXORD_BCST: bad operands")
}

// VPXORD_BCST_Z: Bitwise Logical Exclusive OR of Packed Doubleword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPXORD.BCST.Z m32 zmm k zmm
// 	VPXORD.BCST.Z m32 xmm k xmm
// 	VPXORD.BCST.Z m32 ymm k ymm
func VPXORD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPXORD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPXORD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPXORD_BCST_Z: bad operands")
}

// VPXORD_Z: Bitwise Logical Exclusive OR of Packed Doubleword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPXORD.Z m512 zmm k zmm
// 	VPXORD.Z zmm  zmm k zmm
// 	VPXORD.Z m128 xmm k xmm
// 	VPXORD.Z m256 ymm k ymm
// 	VPXORD.Z xmm  xmm k xmm
// 	VPXORD.Z ymm  ymm k ymm
func VPXORD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPXORD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPXORD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPXORD_Z: bad operands")
}

// VPXORQ: Bitwise Logical Exclusive OR of Packed Quadword Integers.
//
// Forms:
//
// 	VPXORQ m512 zmm k zmm
// 	VPXORQ m512 zmm zmm
// 	VPXORQ zmm  zmm k zmm
// 	VPXORQ zmm  zmm zmm
// 	VPXORQ m128 xmm k xmm
// 	VPXORQ m128 xmm xmm
// 	VPXORQ m256 ymm k ymm
// 	VPXORQ m256 ymm ymm
// 	VPXORQ xmm  xmm k xmm
// 	VPXORQ xmm  xmm xmm
// 	VPXORQ ymm  ymm k ymm
// 	VPXORQ ymm  ymm ymm
func VPXORQ(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPXORQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPXORQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPXORQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPXORQ",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPXORQ: bad operands")
}

// VPXORQ_BCST: Bitwise Logical Exclusive OR of Packed Quadword Integers (Broadcast).
//
// Forms:
//
// 	VPXORQ.BCST m64 zmm k zmm
// 	VPXORQ.BCST m64 zmm zmm
// 	VPXORQ.BCST m64 xmm k xmm
// 	VPXORQ.BCST m64 xmm xmm
// 	VPXORQ.BCST m64 ymm k ymm
// 	VPXORQ.BCST m64 ymm ymm
func VPXORQ_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPXORQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VPXORQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPXORQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VPXORQ",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPXORQ_BCST: bad operands")
}

// VPXORQ_BCST_Z: Bitwise Logical Exclusive OR of Packed Quadword Integers (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VPXORQ.BCST.Z m64 zmm k zmm
// 	VPXORQ.BCST.Z m64 xmm k xmm
// 	VPXORQ.BCST.Z m64 ymm k ymm
func VPXORQ_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPXORQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPXORQ",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPXORQ_BCST_Z: bad operands")
}

// VPXORQ_Z: Bitwise Logical Exclusive OR of Packed Quadword Integers (Zeroing Masking).
//
// Forms:
//
// 	VPXORQ.Z m512 zmm k zmm
// 	VPXORQ.Z zmm  zmm k zmm
// 	VPXORQ.Z m128 xmm k xmm
// 	VPXORQ.Z m256 ymm k ymm
// 	VPXORQ.Z xmm  xmm k xmm
// 	VPXORQ.Z ymm  ymm k ymm
func VPXORQ_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPXORQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VPXORQ",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VPXORQ_Z: bad operands")
}

// VRANGEPD: Range Restriction Calculation For Packed Pairs of Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VRANGEPD imm8 m512 zmm k zmm
// 	VRANGEPD imm8 m512 zmm zmm
// 	VRANGEPD imm8 zmm  zmm k zmm
// 	VRANGEPD imm8 zmm  zmm zmm
// 	VRANGEPD imm8 m128 xmm k xmm
// 	VRANGEPD imm8 m128 xmm xmm
// 	VRANGEPD imm8 m256 ymm k ymm
// 	VRANGEPD imm8 m256 ymm ymm
// 	VRANGEPD imm8 xmm  xmm k xmm
// 	VRANGEPD imm8 xmm  xmm xmm
// 	VRANGEPD imm8 ymm  ymm k ymm
// 	VRANGEPD imm8 ymm  ymm ymm
func VRANGEPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGEPD: bad operands")
}

// VRANGEPD_BCST: Range Restriction Calculation For Packed Pairs of Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VRANGEPD.BCST imm8 m64 zmm k zmm
// 	VRANGEPD.BCST imm8 m64 zmm zmm
// 	VRANGEPD.BCST imm8 m64 xmm k xmm
// 	VRANGEPD.BCST imm8 m64 xmm xmm
// 	VRANGEPD.BCST imm8 m64 ymm k ymm
// 	VRANGEPD.BCST imm8 m64 ymm ymm
func VRANGEPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGEPD_BCST: bad operands")
}

// VRANGEPD_BCST_Z: Range Restriction Calculation For Packed Pairs of Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VRANGEPD.BCST.Z imm8 m64 zmm k zmm
// 	VRANGEPD.BCST.Z imm8 m64 xmm k xmm
// 	VRANGEPD.BCST.Z imm8 m64 ymm k ymm
func VRANGEPD_BCST_Z(i, m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGEPD_BCST_Z: bad operands")
}

// VRANGEPD_SAE: Range Restriction Calculation For Packed Pairs of Double-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VRANGEPD.SAE imm8 zmm zmm k zmm
// 	VRANGEPD.SAE imm8 zmm zmm zmm
func VRANGEPD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGEPD_SAE: bad operands")
}

// VRANGEPD_SAE_Z: Range Restriction Calculation For Packed Pairs of Double-Precision Floating-Point Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRANGEPD.SAE.Z imm8 zmm zmm k zmm
func VRANGEPD_SAE_Z(i, z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGEPD_SAE_Z: bad operands")
}

// VRANGEPD_Z: Range Restriction Calculation For Packed Pairs of Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VRANGEPD.Z imm8 m512 zmm k zmm
// 	VRANGEPD.Z imm8 zmm  zmm k zmm
// 	VRANGEPD.Z imm8 m128 xmm k xmm
// 	VRANGEPD.Z imm8 m256 ymm k ymm
// 	VRANGEPD.Z imm8 xmm  xmm k xmm
// 	VRANGEPD.Z imm8 ymm  ymm k ymm
func VRANGEPD_Z(i, mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VRANGEPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGEPD_Z: bad operands")
}

// VRANGEPS: Range Restriction Calculation For Packed Pairs of Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VRANGEPS imm8 m512 zmm k zmm
// 	VRANGEPS imm8 m512 zmm zmm
// 	VRANGEPS imm8 zmm  zmm k zmm
// 	VRANGEPS imm8 zmm  zmm zmm
// 	VRANGEPS imm8 m128 xmm k xmm
// 	VRANGEPS imm8 m128 xmm xmm
// 	VRANGEPS imm8 m256 ymm k ymm
// 	VRANGEPS imm8 m256 ymm ymm
// 	VRANGEPS imm8 xmm  xmm k xmm
// 	VRANGEPS imm8 xmm  xmm xmm
// 	VRANGEPS imm8 ymm  ymm k ymm
// 	VRANGEPS imm8 ymm  ymm ymm
func VRANGEPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGEPS: bad operands")
}

// VRANGEPS_BCST: Range Restriction Calculation For Packed Pairs of Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VRANGEPS.BCST imm8 m32 zmm k zmm
// 	VRANGEPS.BCST imm8 m32 zmm zmm
// 	VRANGEPS.BCST imm8 m32 xmm k xmm
// 	VRANGEPS.BCST imm8 m32 xmm xmm
// 	VRANGEPS.BCST imm8 m32 ymm k ymm
// 	VRANGEPS.BCST imm8 m32 ymm ymm
func VRANGEPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGEPS_BCST: bad operands")
}

// VRANGEPS_BCST_Z: Range Restriction Calculation For Packed Pairs of Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VRANGEPS.BCST.Z imm8 m32 zmm k zmm
// 	VRANGEPS.BCST.Z imm8 m32 xmm k xmm
// 	VRANGEPS.BCST.Z imm8 m32 ymm k ymm
func VRANGEPS_BCST_Z(i, m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGEPS_BCST_Z: bad operands")
}

// VRANGEPS_SAE: Range Restriction Calculation For Packed Pairs of Single-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VRANGEPS.SAE imm8 zmm zmm k zmm
// 	VRANGEPS.SAE imm8 zmm zmm zmm
func VRANGEPS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGEPS_SAE: bad operands")
}

// VRANGEPS_SAE_Z: Range Restriction Calculation For Packed Pairs of Single-Precision Floating-Point Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRANGEPS.SAE.Z imm8 zmm zmm k zmm
func VRANGEPS_SAE_Z(i, z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGEPS_SAE_Z: bad operands")
}

// VRANGEPS_Z: Range Restriction Calculation For Packed Pairs of Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VRANGEPS.Z imm8 m512 zmm k zmm
// 	VRANGEPS.Z imm8 zmm  zmm k zmm
// 	VRANGEPS.Z imm8 m128 xmm k xmm
// 	VRANGEPS.Z imm8 m256 ymm k ymm
// 	VRANGEPS.Z imm8 xmm  xmm k xmm
// 	VRANGEPS.Z imm8 ymm  ymm k ymm
func VRANGEPS_Z(i, mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VRANGEPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGEPS_Z: bad operands")
}

// VRANGESD: Range Restriction Calculation For a pair of Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VRANGESD imm8 m64 xmm k xmm
// 	VRANGESD imm8 m64 xmm xmm
// 	VRANGESD imm8 xmm xmm k xmm
// 	VRANGESD imm8 xmm xmm xmm
func VRANGESD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRANGESD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRANGESD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGESD: bad operands")
}

// VRANGESD_SAE: Range Restriction Calculation For a pair of Scalar Double-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VRANGESD.SAE imm8 xmm xmm k xmm
// 	VRANGESD.SAE imm8 xmm xmm xmm
func VRANGESD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRANGESD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRANGESD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGESD_SAE: bad operands")
}

// VRANGESD_SAE_Z: Range Restriction Calculation For a pair of Scalar Double-Precision Floating-Point Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRANGESD.SAE.Z imm8 xmm xmm k xmm
func VRANGESD_SAE_Z(i, x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VRANGESD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGESD_SAE_Z: bad operands")
}

// VRANGESD_Z: Range Restriction Calculation For a pair of Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VRANGESD.Z imm8 m64 xmm k xmm
// 	VRANGESD.Z imm8 xmm xmm k xmm
func VRANGESD_Z(i, mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VRANGESD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGESD_Z: bad operands")
}

// VRANGESS: Range Restriction Calculation For a pair of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VRANGESS imm8 m32 xmm k xmm
// 	VRANGESS imm8 m32 xmm xmm
// 	VRANGESS imm8 xmm xmm k xmm
// 	VRANGESS imm8 xmm xmm xmm
func VRANGESS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRANGESS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRANGESS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGESS: bad operands")
}

// VRANGESS_SAE: Range Restriction Calculation For a pair of Scalar Single-Precision Floating-Point Values (Suppress All Exceptions).
//
// Forms:
//
// 	VRANGESS.SAE imm8 xmm xmm k xmm
// 	VRANGESS.SAE imm8 xmm xmm xmm
func VRANGESS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRANGESS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRANGESS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGESS_SAE: bad operands")
}

// VRANGESS_SAE_Z: Range Restriction Calculation For a pair of Scalar Single-Precision Floating-Point Values (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRANGESS.SAE.Z imm8 xmm xmm k xmm
func VRANGESS_SAE_Z(i, x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VRANGESS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGESS_SAE_Z: bad operands")
}

// VRANGESS_Z: Range Restriction Calculation For a pair of Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VRANGESS.Z imm8 m32 xmm k xmm
// 	VRANGESS.Z imm8 xmm xmm k xmm
func VRANGESS_Z(i, mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VRANGESS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VRANGESS_Z: bad operands")
}

// VRCP14PD: Compute Approximate Reciprocals of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VRCP14PD m512 k zmm
// 	VRCP14PD m512 zmm
// 	VRCP14PD zmm  k zmm
// 	VRCP14PD zmm  zmm
// 	VRCP14PD m128 k xmm
// 	VRCP14PD m128 xmm
// 	VRCP14PD m256 k ymm
// 	VRCP14PD m256 ymm
// 	VRCP14PD xmm  k xmm
// 	VRCP14PD xmm  xmm
// 	VRCP14PD ymm  k ymm
// 	VRCP14PD ymm  ymm
func VRCP14PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRCP14PD: bad operands")
}

// VRCP14PD_BCST: Compute Approximate Reciprocals of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VRCP14PD.BCST m64 k zmm
// 	VRCP14PD.BCST m64 zmm
// 	VRCP14PD.BCST m64 k xmm
// 	VRCP14PD.BCST m64 k ymm
// 	VRCP14PD.BCST m64 xmm
// 	VRCP14PD.BCST m64 ymm
func VRCP14PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRCP14PD_BCST: bad operands")
}

// VRCP14PD_BCST_Z: Compute Approximate Reciprocals of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VRCP14PD.BCST.Z m64 k zmm
// 	VRCP14PD.BCST.Z m64 k xmm
// 	VRCP14PD.BCST.Z m64 k ymm
func VRCP14PD_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRCP14PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRCP14PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRCP14PD_BCST_Z: bad operands")
}

// VRCP14PD_Z: Compute Approximate Reciprocals of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VRCP14PD.Z m512 k zmm
// 	VRCP14PD.Z zmm  k zmm
// 	VRCP14PD.Z m128 k xmm
// 	VRCP14PD.Z m256 k ymm
// 	VRCP14PD.Z xmm  k xmm
// 	VRCP14PD.Z ymm  k ymm
func VRCP14PD_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRCP14PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRCP14PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRCP14PD_Z: bad operands")
}

// VRCP14PS: Compute Approximate Reciprocals of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VRCP14PS m512 k zmm
// 	VRCP14PS m512 zmm
// 	VRCP14PS zmm  k zmm
// 	VRCP14PS zmm  zmm
// 	VRCP14PS m128 k xmm
// 	VRCP14PS m128 xmm
// 	VRCP14PS m256 k ymm
// 	VRCP14PS m256 ymm
// 	VRCP14PS xmm  k xmm
// 	VRCP14PS xmm  xmm
// 	VRCP14PS ymm  k ymm
// 	VRCP14PS ymm  ymm
func VRCP14PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRCP14PS: bad operands")
}

// VRCP14PS_BCST: Compute Approximate Reciprocals of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VRCP14PS.BCST m32 k zmm
// 	VRCP14PS.BCST m32 zmm
// 	VRCP14PS.BCST m32 k xmm
// 	VRCP14PS.BCST m32 k ymm
// 	VRCP14PS.BCST m32 xmm
// 	VRCP14PS.BCST m32 ymm
func VRCP14PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRCP14PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRCP14PS_BCST: bad operands")
}

// VRCP14PS_BCST_Z: Compute Approximate Reciprocals of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VRCP14PS.BCST.Z m32 k zmm
// 	VRCP14PS.BCST.Z m32 k xmm
// 	VRCP14PS.BCST.Z m32 k ymm
func VRCP14PS_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRCP14PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRCP14PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRCP14PS_BCST_Z: bad operands")
}

// VRCP14PS_Z: Compute Approximate Reciprocals of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VRCP14PS.Z m512 k zmm
// 	VRCP14PS.Z zmm  k zmm
// 	VRCP14PS.Z m128 k xmm
// 	VRCP14PS.Z m256 k ymm
// 	VRCP14PS.Z xmm  k xmm
// 	VRCP14PS.Z ymm  k ymm
func VRCP14PS_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRCP14PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRCP14PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRCP14PS_Z: bad operands")
}

// VRCP14SD: Compute Approximate Reciprocal of a Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VRCP14SD m64 xmm k xmm
// 	VRCP14SD m64 xmm xmm
// 	VRCP14SD xmm xmm k xmm
// 	VRCP14SD xmm xmm xmm
func VRCP14SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRCP14SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP14SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRCP14SD: bad operands")
}

// VRCP14SD_Z: Compute Approximate Reciprocal of a Scalar Double-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VRCP14SD.Z m64 xmm k xmm
// 	VRCP14SD.Z xmm xmm k xmm
func VRCP14SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VRCP14SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRCP14SD_Z: bad operands")
}

// VRCP14SS: Compute Approximate Reciprocal of a Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	VRCP14SS m32 xmm k xmm
// 	VRCP14SS m32 xmm xmm
// 	VRCP14SS xmm xmm k xmm
// 	VRCP14SS xmm xmm xmm
func VRCP14SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRCP14SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP14SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRCP14SS: bad operands")
}

// VRCP14SS_Z: Compute Approximate Reciprocal of a Scalar Single-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VRCP14SS.Z m32 xmm k xmm
// 	VRCP14SS.Z xmm xmm k xmm
func VRCP14SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VRCP14SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRCP14SS_Z: bad operands")
}

// VRCP28PD: Approximation to the Reciprocal of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error.
//
// Forms:
//
// 	VRCP28PD m512 k zmm
// 	VRCP28PD m512 zmm
// 	VRCP28PD zmm  k zmm
// 	VRCP28PD zmm  zmm
func VRCP28PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP28PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRCP28PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28PD: bad operands")
}

// VRCP28PD_BCST: Approximation to the Reciprocal of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Broadcast).
//
// Forms:
//
// 	VRCP28PD.BCST m64 k zmm
// 	VRCP28PD.BCST m64 zmm
func VRCP28PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP28PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRCP28PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28PD_BCST: bad operands")
}

// VRCP28PD_BCST_Z: Approximation to the Reciprocal of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VRCP28PD.BCST.Z m64 k zmm
func VRCP28PD_BCST_Z(m, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VRCP28PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, z},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28PD_BCST_Z: bad operands")
}

// VRCP28PD_SAE: Approximation to the Reciprocal of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Suppress All Exceptions).
//
// Forms:
//
// 	VRCP28PD.SAE zmm k zmm
// 	VRCP28PD.SAE zmm zmm
func VRCP28PD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP28PD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRCP28PD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28PD_SAE: bad operands")
}

// VRCP28PD_SAE_Z: Approximation to the Reciprocal of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRCP28PD.SAE.Z zmm k zmm
func VRCP28PD_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VRCP28PD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28PD_SAE_Z: bad operands")
}

// VRCP28PD_Z: Approximation to the Reciprocal of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Zeroing Masking).
//
// Forms:
//
// 	VRCP28PD.Z m512 k zmm
// 	VRCP28PD.Z zmm  k zmm
func VRCP28PD_Z(mz, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsZMM(z),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VRCP28PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, z},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28PD_Z: bad operands")
}

// VRCP28PS: Approximation to the Reciprocal of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error.
//
// Forms:
//
// 	VRCP28PS m512 k zmm
// 	VRCP28PS m512 zmm
// 	VRCP28PS zmm  k zmm
// 	VRCP28PS zmm  zmm
func VRCP28PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP28PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRCP28PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28PS: bad operands")
}

// VRCP28PS_BCST: Approximation to the Reciprocal of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Broadcast).
//
// Forms:
//
// 	VRCP28PS.BCST m32 k zmm
// 	VRCP28PS.BCST m32 zmm
func VRCP28PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP28PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRCP28PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28PS_BCST: bad operands")
}

// VRCP28PS_BCST_Z: Approximation to the Reciprocal of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VRCP28PS.BCST.Z m32 k zmm
func VRCP28PS_BCST_Z(m, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VRCP28PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, z},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28PS_BCST_Z: bad operands")
}

// VRCP28PS_SAE: Approximation to the Reciprocal of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Suppress All Exceptions).
//
// Forms:
//
// 	VRCP28PS.SAE zmm k zmm
// 	VRCP28PS.SAE zmm zmm
func VRCP28PS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP28PS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRCP28PS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28PS_SAE: bad operands")
}

// VRCP28PS_SAE_Z: Approximation to the Reciprocal of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRCP28PS.SAE.Z zmm k zmm
func VRCP28PS_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VRCP28PS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28PS_SAE_Z: bad operands")
}

// VRCP28PS_Z: Approximation to the Reciprocal of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Zeroing Masking).
//
// Forms:
//
// 	VRCP28PS.Z m512 k zmm
// 	VRCP28PS.Z zmm  k zmm
func VRCP28PS_Z(mz, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsZMM(z),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VRCP28PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, z},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28PS_Z: bad operands")
}

// VRCP28SD: Approximation to the Reciprocal of a Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error.
//
// Forms:
//
// 	VRCP28SD m64 xmm k xmm
// 	VRCP28SD m64 xmm xmm
// 	VRCP28SD xmm xmm k xmm
// 	VRCP28SD xmm xmm xmm
func VRCP28SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRCP28SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP28SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28SD: bad operands")
}

// VRCP28SD_SAE: Approximation to the Reciprocal of a Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error (Suppress All Exceptions).
//
// Forms:
//
// 	VRCP28SD.SAE xmm xmm k xmm
// 	VRCP28SD.SAE xmm xmm xmm
func VRCP28SD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRCP28SD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP28SD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28SD_SAE: bad operands")
}

// VRCP28SD_SAE_Z: Approximation to the Reciprocal of a Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRCP28SD.SAE.Z xmm xmm k xmm
func VRCP28SD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VRCP28SD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28SD_SAE_Z: bad operands")
}

// VRCP28SD_Z: Approximation to the Reciprocal of a Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error (Zeroing Masking).
//
// Forms:
//
// 	VRCP28SD.Z m64 xmm k xmm
// 	VRCP28SD.Z xmm xmm k xmm
func VRCP28SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VRCP28SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28SD_Z: bad operands")
}

// VRCP28SS: Approximation to the Reciprocal of a Scalar Single-Precision Floating-Point Value with Less Than 2^-28 Relative Error.
//
// Forms:
//
// 	VRCP28SS m32 xmm k xmm
// 	VRCP28SS m32 xmm xmm
// 	VRCP28SS xmm xmm k xmm
// 	VRCP28SS xmm xmm xmm
func VRCP28SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRCP28SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP28SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28SS: bad operands")
}

// VRCP28SS_SAE: Approximation to the Reciprocal of a Scalar Single-Precision Floating-Point Value with Less Than 2^-28 Relative Error (Suppress All Exceptions).
//
// Forms:
//
// 	VRCP28SS.SAE xmm xmm k xmm
// 	VRCP28SS.SAE xmm xmm xmm
func VRCP28SS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRCP28SS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRCP28SS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28SS_SAE: bad operands")
}

// VRCP28SS_SAE_Z: Approximation to the Reciprocal of a Scalar Single-Precision Floating-Point Value with Less Than 2^-28 Relative Error (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRCP28SS.SAE.Z xmm xmm k xmm
func VRCP28SS_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VRCP28SS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28SS_SAE_Z: bad operands")
}

// VRCP28SS_Z: Approximation to the Reciprocal of a Scalar Single-Precision Floating-Point Value with Less Than 2^-28 Relative Error (Zeroing Masking).
//
// Forms:
//
// 	VRCP28SS.Z m32 xmm k xmm
// 	VRCP28SS.Z xmm xmm k xmm
func VRCP28SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VRCP28SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRCP28SS_Z: bad operands")
}

// VRCPPS: Compute Approximate Reciprocals of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VRCPPS m128 xmm
// 	VRCPPS m256 ymm
// 	VRCPPS xmm  xmm
// 	VRCPPS ymm  ymm
func VRCPPS(mxy, xy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy),
		operand.IsM256(mxy) && operand.IsYMM(xy),
		operand.IsXMM(mxy) && operand.IsXMM(xy),
		operand.IsYMM(mxy) && operand.IsYMM(xy):
		return &intrep.Instruction{
			Opcode:   "VRCPPS",
			Operands: []operand.Op{mxy, xy},
			Inputs:   []operand.Op{mxy},
			Outputs:  []operand.Op{xy},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VRCPPS: bad operands")
}

// VRCPSS: Compute Approximate Reciprocal of Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VRCPSS m32 xmm xmm
// 	VRCPSS xmm xmm xmm
func VRCPSS(mx, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VRCPSS",
			Operands: []operand.Op{mx, x, x1},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VRCPSS: bad operands")
}

// VREDUCEPD: Perform Reduction Transformation on Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VREDUCEPD imm8 m512 k zmm
// 	VREDUCEPD imm8 m512 zmm
// 	VREDUCEPD imm8 zmm  k zmm
// 	VREDUCEPD imm8 zmm  zmm
// 	VREDUCEPD imm8 m128 k xmm
// 	VREDUCEPD imm8 m128 xmm
// 	VREDUCEPD imm8 m256 k ymm
// 	VREDUCEPD imm8 m256 ymm
// 	VREDUCEPD imm8 xmm  k xmm
// 	VREDUCEPD imm8 xmm  xmm
// 	VREDUCEPD imm8 ymm  k ymm
// 	VREDUCEPD imm8 ymm  ymm
func VREDUCEPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VREDUCEPD: bad operands")
}

// VREDUCEPD_BCST: Perform Reduction Transformation on Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VREDUCEPD.BCST imm8 m64 k zmm
// 	VREDUCEPD.BCST imm8 m64 zmm
// 	VREDUCEPD.BCST imm8 m64 k xmm
// 	VREDUCEPD.BCST imm8 m64 k ymm
// 	VREDUCEPD.BCST imm8 m64 xmm
// 	VREDUCEPD.BCST imm8 m64 ymm
func VREDUCEPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VREDUCEPD_BCST: bad operands")
}

// VREDUCEPD_BCST_Z: Perform Reduction Transformation on Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VREDUCEPD.BCST.Z imm8 m64 k zmm
// 	VREDUCEPD.BCST.Z imm8 m64 k xmm
// 	VREDUCEPD.BCST.Z imm8 m64 k ymm
func VREDUCEPD_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VREDUCEPD_BCST_Z: bad operands")
}

// VREDUCEPD_Z: Perform Reduction Transformation on Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VREDUCEPD.Z imm8 m512 k zmm
// 	VREDUCEPD.Z imm8 zmm  k zmm
// 	VREDUCEPD.Z imm8 m128 k xmm
// 	VREDUCEPD.Z imm8 m256 k ymm
// 	VREDUCEPD.Z imm8 xmm  k xmm
// 	VREDUCEPD.Z imm8 ymm  k ymm
func VREDUCEPD_Z(i, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VREDUCEPD_Z: bad operands")
}

// VREDUCEPS: Perform Reduction Transformation on Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VREDUCEPS imm8 m512 k zmm
// 	VREDUCEPS imm8 m512 zmm
// 	VREDUCEPS imm8 zmm  k zmm
// 	VREDUCEPS imm8 zmm  zmm
// 	VREDUCEPS imm8 m128 k xmm
// 	VREDUCEPS imm8 m128 xmm
// 	VREDUCEPS imm8 m256 k ymm
// 	VREDUCEPS imm8 m256 ymm
// 	VREDUCEPS imm8 xmm  k xmm
// 	VREDUCEPS imm8 xmm  xmm
// 	VREDUCEPS imm8 ymm  k ymm
// 	VREDUCEPS imm8 ymm  ymm
func VREDUCEPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VREDUCEPS: bad operands")
}

// VREDUCEPS_BCST: Perform Reduction Transformation on Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VREDUCEPS.BCST imm8 m32 k zmm
// 	VREDUCEPS.BCST imm8 m32 zmm
// 	VREDUCEPS.BCST imm8 m32 k xmm
// 	VREDUCEPS.BCST imm8 m32 k ymm
// 	VREDUCEPS.BCST imm8 m32 xmm
// 	VREDUCEPS.BCST imm8 m32 ymm
func VREDUCEPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VREDUCEPS_BCST: bad operands")
}

// VREDUCEPS_BCST_Z: Perform Reduction Transformation on Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VREDUCEPS.BCST.Z imm8 m32 k zmm
// 	VREDUCEPS.BCST.Z imm8 m32 k xmm
// 	VREDUCEPS.BCST.Z imm8 m32 k ymm
func VREDUCEPS_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VREDUCEPS_BCST_Z: bad operands")
}

// VREDUCEPS_Z: Perform Reduction Transformation on Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VREDUCEPS.Z imm8 m512 k zmm
// 	VREDUCEPS.Z imm8 zmm  k zmm
// 	VREDUCEPS.Z imm8 m128 k xmm
// 	VREDUCEPS.Z imm8 m256 k ymm
// 	VREDUCEPS.Z imm8 xmm  k xmm
// 	VREDUCEPS.Z imm8 ymm  k ymm
func VREDUCEPS_Z(i, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VREDUCEPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VREDUCEPS_Z: bad operands")
}

// VREDUCESD: Perform Reduction Transformation on a Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VREDUCESD imm8 m64 xmm k xmm
// 	VREDUCESD imm8 m64 xmm xmm
// 	VREDUCESD imm8 xmm xmm k xmm
// 	VREDUCESD imm8 xmm xmm xmm
func VREDUCESD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VREDUCESD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VREDUCESD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VREDUCESD: bad operands")
}

// VREDUCESD_Z: Perform Reduction Transformation on a Scalar Double-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VREDUCESD.Z imm8 m64 xmm k xmm
// 	VREDUCESD.Z imm8 xmm xmm k xmm
func VREDUCESD_Z(i, mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VREDUCESD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VREDUCESD_Z: bad operands")
}

// VREDUCESS: Perform Reduction Transformation on a Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	VREDUCESS imm8 m32 xmm k xmm
// 	VREDUCESS imm8 m32 xmm xmm
// 	VREDUCESS imm8 xmm xmm k xmm
// 	VREDUCESS imm8 xmm xmm xmm
func VREDUCESS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VREDUCESS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VREDUCESS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VREDUCESS: bad operands")
}

// VREDUCESS_Z: Perform Reduction Transformation on a Scalar Single-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VREDUCESS.Z imm8 m32 xmm k xmm
// 	VREDUCESS.Z imm8 xmm xmm k xmm
func VREDUCESS_Z(i, mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VREDUCESS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VREDUCESS_Z: bad operands")
}

// VRNDSCALEPD: Round Packed Double-Precision Floating-Point Values To Include A Given Number Of Fraction Bits.
//
// Forms:
//
// 	VRNDSCALEPD imm8 m512 k zmm
// 	VRNDSCALEPD imm8 m512 zmm
// 	VRNDSCALEPD imm8 zmm  k zmm
// 	VRNDSCALEPD imm8 zmm  zmm
// 	VRNDSCALEPD imm8 m128 k xmm
// 	VRNDSCALEPD imm8 m128 xmm
// 	VRNDSCALEPD imm8 m256 k ymm
// 	VRNDSCALEPD imm8 m256 ymm
// 	VRNDSCALEPD imm8 xmm  k xmm
// 	VRNDSCALEPD imm8 xmm  xmm
// 	VRNDSCALEPD imm8 ymm  k ymm
// 	VRNDSCALEPD imm8 ymm  ymm
func VRNDSCALEPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALEPD: bad operands")
}

// VRNDSCALEPD_BCST: Round Packed Double-Precision Floating-Point Values To Include A Given Number Of Fraction Bits (Broadcast).
//
// Forms:
//
// 	VRNDSCALEPD.BCST imm8 m64 k zmm
// 	VRNDSCALEPD.BCST imm8 m64 zmm
// 	VRNDSCALEPD.BCST imm8 m64 k xmm
// 	VRNDSCALEPD.BCST imm8 m64 k ymm
// 	VRNDSCALEPD.BCST imm8 m64 xmm
// 	VRNDSCALEPD.BCST imm8 m64 ymm
func VRNDSCALEPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALEPD_BCST: bad operands")
}

// VRNDSCALEPD_BCST_Z: Round Packed Double-Precision Floating-Point Values To Include A Given Number Of Fraction Bits (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VRNDSCALEPD.BCST.Z imm8 m64 k zmm
// 	VRNDSCALEPD.BCST.Z imm8 m64 k xmm
// 	VRNDSCALEPD.BCST.Z imm8 m64 k ymm
func VRNDSCALEPD_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALEPD_BCST_Z: bad operands")
}

// VRNDSCALEPD_SAE: Round Packed Double-Precision Floating-Point Values To Include A Given Number Of Fraction Bits (Suppress All Exceptions).
//
// Forms:
//
// 	VRNDSCALEPD.SAE imm8 zmm k zmm
// 	VRNDSCALEPD.SAE imm8 zmm zmm
func VRNDSCALEPD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALEPD_SAE: bad operands")
}

// VRNDSCALEPD_SAE_Z: Round Packed Double-Precision Floating-Point Values To Include A Given Number Of Fraction Bits (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRNDSCALEPD.SAE.Z imm8 zmm k zmm
func VRNDSCALEPD_SAE_Z(i, z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALEPD_SAE_Z: bad operands")
}

// VRNDSCALEPD_Z: Round Packed Double-Precision Floating-Point Values To Include A Given Number Of Fraction Bits (Zeroing Masking).
//
// Forms:
//
// 	VRNDSCALEPD.Z imm8 m512 k zmm
// 	VRNDSCALEPD.Z imm8 zmm  k zmm
// 	VRNDSCALEPD.Z imm8 m128 k xmm
// 	VRNDSCALEPD.Z imm8 m256 k ymm
// 	VRNDSCALEPD.Z imm8 xmm  k xmm
// 	VRNDSCALEPD.Z imm8 ymm  k ymm
func VRNDSCALEPD_Z(i, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALEPD_Z: bad operands")
}

// VRNDSCALEPS: Round Packed Single-Precision Floating-Point Values To Include A Given Number Of Fraction Bits.
//
// Forms:
//
// 	VRNDSCALEPS imm8 m512 k zmm
// 	VRNDSCALEPS imm8 m512 zmm
// 	VRNDSCALEPS imm8 zmm  k zmm
// 	VRNDSCALEPS imm8 zmm  zmm
// 	VRNDSCALEPS imm8 m128 k xmm
// 	VRNDSCALEPS imm8 m128 xmm
// 	VRNDSCALEPS imm8 m256 k ymm
// 	VRNDSCALEPS imm8 m256 ymm
// 	VRNDSCALEPS imm8 xmm  k xmm
// 	VRNDSCALEPS imm8 xmm  xmm
// 	VRNDSCALEPS imm8 ymm  k ymm
// 	VRNDSCALEPS imm8 ymm  ymm
func VRNDSCALEPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALEPS: bad operands")
}

// VRNDSCALEPS_BCST: Round Packed Single-Precision Floating-Point Values To Include A Given Number Of Fraction Bits (Broadcast).
//
// Forms:
//
// 	VRNDSCALEPS.BCST imm8 m32 k zmm
// 	VRNDSCALEPS.BCST imm8 m32 zmm
// 	VRNDSCALEPS.BCST imm8 m32 k xmm
// 	VRNDSCALEPS.BCST imm8 m32 k ymm
// 	VRNDSCALEPS.BCST imm8 m32 xmm
// 	VRNDSCALEPS.BCST imm8 m32 ymm
func VRNDSCALEPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALEPS_BCST: bad operands")
}

// VRNDSCALEPS_BCST_Z: Round Packed Single-Precision Floating-Point Values To Include A Given Number Of Fraction Bits (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VRNDSCALEPS.BCST.Z imm8 m32 k zmm
// 	VRNDSCALEPS.BCST.Z imm8 m32 k xmm
// 	VRNDSCALEPS.BCST.Z imm8 m32 k ymm
func VRNDSCALEPS_BCST_Z(i, m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALEPS_BCST_Z: bad operands")
}

// VRNDSCALEPS_SAE: Round Packed Single-Precision Floating-Point Values To Include A Given Number Of Fraction Bits (Suppress All Exceptions).
//
// Forms:
//
// 	VRNDSCALEPS.SAE imm8 zmm k zmm
// 	VRNDSCALEPS.SAE imm8 zmm zmm
func VRNDSCALEPS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALEPS_SAE: bad operands")
}

// VRNDSCALEPS_SAE_Z: Round Packed Single-Precision Floating-Point Values To Include A Given Number Of Fraction Bits (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRNDSCALEPS.SAE.Z imm8 zmm k zmm
func VRNDSCALEPS_SAE_Z(i, z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALEPS_SAE_Z: bad operands")
}

// VRNDSCALEPS_Z: Round Packed Single-Precision Floating-Point Values To Include A Given Number Of Fraction Bits (Zeroing Masking).
//
// Forms:
//
// 	VRNDSCALEPS.Z imm8 m512 k zmm
// 	VRNDSCALEPS.Z imm8 zmm  k zmm
// 	VRNDSCALEPS.Z imm8 m128 k xmm
// 	VRNDSCALEPS.Z imm8 m256 k ymm
// 	VRNDSCALEPS.Z imm8 xmm  k xmm
// 	VRNDSCALEPS.Z imm8 ymm  k ymm
func VRNDSCALEPS_Z(i, mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALEPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALEPS_Z: bad operands")
}

// VRNDSCALESD: Round Scalar Double-Precision Floating-Point Value To Include A Given Number Of Fraction Bits.
//
// Forms:
//
// 	VRNDSCALESD imm8 m64 xmm k xmm
// 	VRNDSCALESD imm8 m64 xmm xmm
// 	VRNDSCALESD imm8 xmm xmm k xmm
// 	VRNDSCALESD imm8 xmm xmm xmm
func VRNDSCALESD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALESD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALESD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALESD: bad operands")
}

// VRNDSCALESD_SAE: Round Scalar Double-Precision Floating-Point Value To Include A Given Number Of Fraction Bits (Suppress All Exceptions).
//
// Forms:
//
// 	VRNDSCALESD.SAE imm8 xmm xmm k xmm
// 	VRNDSCALESD.SAE imm8 xmm xmm xmm
func VRNDSCALESD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALESD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALESD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALESD_SAE: bad operands")
}

// VRNDSCALESD_SAE_Z: Round Scalar Double-Precision Floating-Point Value To Include A Given Number Of Fraction Bits (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRNDSCALESD.SAE.Z imm8 xmm xmm k xmm
func VRNDSCALESD_SAE_Z(i, x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALESD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALESD_SAE_Z: bad operands")
}

// VRNDSCALESD_Z: Round Scalar Double-Precision Floating-Point Value To Include A Given Number Of Fraction Bits (Zeroing Masking).
//
// Forms:
//
// 	VRNDSCALESD.Z imm8 m64 xmm k xmm
// 	VRNDSCALESD.Z imm8 xmm xmm k xmm
func VRNDSCALESD_Z(i, mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALESD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALESD_Z: bad operands")
}

// VRNDSCALESS: Round Scalar Single-Precision Floating-Point Value To Include A Given Number Of Fraction Bits.
//
// Forms:
//
// 	VRNDSCALESS imm8 m32 xmm k xmm
// 	VRNDSCALESS imm8 m32 xmm xmm
// 	VRNDSCALESS imm8 xmm xmm k xmm
// 	VRNDSCALESS imm8 xmm xmm xmm
func VRNDSCALESS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALESS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALESS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALESS: bad operands")
}

// VRNDSCALESS_SAE: Round Scalar Single-Precision Floating-Point Value To Include A Given Number Of Fraction Bits (Suppress All Exceptions).
//
// Forms:
//
// 	VRNDSCALESS.SAE imm8 xmm xmm k xmm
// 	VRNDSCALESS.SAE imm8 xmm xmm xmm
func VRNDSCALESS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALESS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALESS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALESS_SAE: bad operands")
}

// VRNDSCALESS_SAE_Z: Round Scalar Single-Precision Floating-Point Value To Include A Given Number Of Fraction Bits (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRNDSCALESS.SAE.Z imm8 xmm xmm k xmm
func VRNDSCALESS_SAE_Z(i, x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALESS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{i, x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALESS_SAE_Z: bad operands")
}

// VRNDSCALESS_Z: Round Scalar Single-Precision Floating-Point Value To Include A Given Number Of Fraction Bits (Zeroing Masking).
//
// Forms:
//
// 	VRNDSCALESS.Z imm8 m32 xmm k xmm
// 	VRNDSCALESS.Z imm8 xmm xmm k xmm
func VRNDSCALESS_Z(i, mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VRNDSCALESS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRNDSCALESS_Z: bad operands")
}

// VROUNDPD: Round Packed Double Precision Floating-Point Values.
//
// Forms:
//
// 	VROUNDPD imm8 m128 xmm
// 	VROUNDPD imm8 m256 ymm
// 	VROUNDPD imm8 xmm  xmm
// 	VROUNDPD imm8 ymm  ymm
func VROUNDPD(i, mxy, xy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mxy) && operand.IsXMM(xy),
		operand.IsIMM8(i) && operand.IsM256(mxy) && operand.IsYMM(xy),
		operand.IsIMM8(i) && operand.IsXMM(mxy) && operand.IsXMM(xy),
		operand.IsIMM8(i) && operand.IsYMM(mxy) && operand.IsYMM(xy):
		return &intrep.Instruction{
			Opcode:   "VROUNDPD",
			Operands: []operand.Op{i, mxy, xy},
			Inputs:   []operand.Op{mxy},
			Outputs:  []operand.Op{xy},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VROUNDPD: bad operands")
}

// VROUNDPS: Round Packed Single Precision Floating-Point Values.
//
// Forms:
//
// 	VROUNDPS imm8 m128 xmm
// 	VROUNDPS imm8 m256 ymm
// 	VROUNDPS imm8 xmm  xmm
// 	VROUNDPS imm8 ymm  ymm
func VROUNDPS(i, mxy, xy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM128(mxy) && operand.IsXMM(xy),
		operand.IsIMM8(i) && operand.IsM256(mxy) && operand.IsYMM(xy),
		operand.IsIMM8(i) && operand.IsXMM(mxy) && operand.IsXMM(xy),
		operand.IsIMM8(i) && operand.IsYMM(mxy) && operand.IsYMM(xy):
		return &intrep.Instruction{
			Opcode:   "VROUNDPS",
			Operands: []operand.Op{i, mxy, xy},
			Inputs:   []operand.Op{mxy},
			Outputs:  []operand.Op{xy},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VROUNDPS: bad operands")
}

// VROUNDSD: Round Scalar Double Precision Floating-Point Values.
//
// Forms:
//
// 	VROUNDSD imm8 m64 xmm xmm
// 	VROUNDSD imm8 xmm xmm xmm
func VROUNDSD(i, mx, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(mx) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VROUNDSD",
			Operands: []operand.Op{i, mx, x, x1},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VROUNDSD: bad operands")
}

// VROUNDSS: Round Scalar Single Precision Floating-Point Values.
//
// Forms:
//
// 	VROUNDSS imm8 m32 xmm xmm
// 	VROUNDSS imm8 xmm xmm xmm
func VROUNDSS(i, mx, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(mx) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsIMM8(i) && operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VROUNDSS",
			Operands: []operand.Op{i, mx, x, x1},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VROUNDSS: bad operands")
}

// VRSQRT14PD: Compute Approximate Reciprocals of Square Roots of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VRSQRT14PD m512 k zmm
// 	VRSQRT14PD m512 zmm
// 	VRSQRT14PD zmm  k zmm
// 	VRSQRT14PD zmm  zmm
// 	VRSQRT14PD m128 k xmm
// 	VRSQRT14PD m128 xmm
// 	VRSQRT14PD m256 k ymm
// 	VRSQRT14PD m256 ymm
// 	VRSQRT14PD xmm  k xmm
// 	VRSQRT14PD xmm  xmm
// 	VRSQRT14PD ymm  k ymm
// 	VRSQRT14PD ymm  ymm
func VRSQRT14PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRSQRT14PD: bad operands")
}

// VRSQRT14PD_BCST: Compute Approximate Reciprocals of Square Roots of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VRSQRT14PD.BCST m64 k zmm
// 	VRSQRT14PD.BCST m64 zmm
// 	VRSQRT14PD.BCST m64 k xmm
// 	VRSQRT14PD.BCST m64 k ymm
// 	VRSQRT14PD.BCST m64 xmm
// 	VRSQRT14PD.BCST m64 ymm
func VRSQRT14PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRSQRT14PD_BCST: bad operands")
}

// VRSQRT14PD_BCST_Z: Compute Approximate Reciprocals of Square Roots of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VRSQRT14PD.BCST.Z m64 k zmm
// 	VRSQRT14PD.BCST.Z m64 k xmm
// 	VRSQRT14PD.BCST.Z m64 k ymm
func VRSQRT14PD_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM64(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRSQRT14PD_BCST_Z: bad operands")
}

// VRSQRT14PD_Z: Compute Approximate Reciprocals of Square Roots of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VRSQRT14PD.Z m512 k zmm
// 	VRSQRT14PD.Z zmm  k zmm
// 	VRSQRT14PD.Z m128 k xmm
// 	VRSQRT14PD.Z m256 k ymm
// 	VRSQRT14PD.Z xmm  k xmm
// 	VRSQRT14PD.Z ymm  k ymm
func VRSQRT14PD_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRSQRT14PD_Z: bad operands")
}

// VRSQRT14PS: Compute Approximate Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VRSQRT14PS m512 k zmm
// 	VRSQRT14PS m512 zmm
// 	VRSQRT14PS zmm  k zmm
// 	VRSQRT14PS zmm  zmm
// 	VRSQRT14PS m128 k xmm
// 	VRSQRT14PS m128 xmm
// 	VRSQRT14PS m256 k ymm
// 	VRSQRT14PS m256 ymm
// 	VRSQRT14PS xmm  k xmm
// 	VRSQRT14PS xmm  xmm
// 	VRSQRT14PS ymm  k ymm
// 	VRSQRT14PS ymm  ymm
func VRSQRT14PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRSQRT14PS: bad operands")
}

// VRSQRT14PS_BCST: Compute Approximate Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VRSQRT14PS.BCST m32 k zmm
// 	VRSQRT14PS.BCST m32 zmm
// 	VRSQRT14PS.BCST m32 k xmm
// 	VRSQRT14PS.BCST m32 k ymm
// 	VRSQRT14PS.BCST m32 xmm
// 	VRSQRT14PS.BCST m32 ymm
func VRSQRT14PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRSQRT14PS_BCST: bad operands")
}

// VRSQRT14PS_BCST_Z: Compute Approximate Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VRSQRT14PS.BCST.Z m32 k zmm
// 	VRSQRT14PS.BCST.Z m32 k xmm
// 	VRSQRT14PS.BCST.Z m32 k ymm
func VRSQRT14PS_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRSQRT14PS_BCST_Z: bad operands")
}

// VRSQRT14PS_Z: Compute Approximate Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VRSQRT14PS.Z m512 k zmm
// 	VRSQRT14PS.Z zmm  k zmm
// 	VRSQRT14PS.Z m128 k xmm
// 	VRSQRT14PS.Z m256 k ymm
// 	VRSQRT14PS.Z xmm  k xmm
// 	VRSQRT14PS.Z ymm  k ymm
func VRSQRT14PS_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VRSQRT14PS_Z: bad operands")
}

// VRSQRT14SD: Compute Approximate Reciprocal of a Square Root of a Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VRSQRT14SD m64 xmm k xmm
// 	VRSQRT14SD m64 xmm xmm
// 	VRSQRT14SD xmm xmm k xmm
// 	VRSQRT14SD xmm xmm xmm
func VRSQRT14SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRSQRT14SD: bad operands")
}

// VRSQRT14SD_Z: Compute Approximate Reciprocal of a Square Root of a Scalar Double-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VRSQRT14SD.Z m64 xmm k xmm
// 	VRSQRT14SD.Z xmm xmm k xmm
func VRSQRT14SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRSQRT14SD_Z: bad operands")
}

// VRSQRT14SS: Compute Approximate Reciprocal of a Square Root of a Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	VRSQRT14SS m32 xmm k xmm
// 	VRSQRT14SS m32 xmm xmm
// 	VRSQRT14SS xmm xmm k xmm
// 	VRSQRT14SS xmm xmm xmm
func VRSQRT14SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRSQRT14SS: bad operands")
}

// VRSQRT14SS_Z: Compute Approximate Reciprocal of a Square Root of a Scalar Single-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VRSQRT14SS.Z m32 xmm k xmm
// 	VRSQRT14SS.Z xmm xmm k xmm
func VRSQRT14SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VRSQRT14SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VRSQRT14SS_Z: bad operands")
}

// VRSQRT28PD: Approximation to the Reciprocal Square Root of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error.
//
// Forms:
//
// 	VRSQRT28PD m512 k zmm
// 	VRSQRT28PD m512 zmm
// 	VRSQRT28PD zmm  k zmm
// 	VRSQRT28PD zmm  zmm
func VRSQRT28PD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28PD: bad operands")
}

// VRSQRT28PD_BCST: Approximation to the Reciprocal Square Root of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Broadcast).
//
// Forms:
//
// 	VRSQRT28PD.BCST m64 k zmm
// 	VRSQRT28PD.BCST m64 zmm
func VRSQRT28PD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28PD_BCST: bad operands")
}

// VRSQRT28PD_BCST_Z: Approximation to the Reciprocal Square Root of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VRSQRT28PD.BCST.Z m64 k zmm
func VRSQRT28PD_BCST_Z(m, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, z},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28PD_BCST_Z: bad operands")
}

// VRSQRT28PD_SAE: Approximation to the Reciprocal Square Root of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Suppress All Exceptions).
//
// Forms:
//
// 	VRSQRT28PD.SAE zmm k zmm
// 	VRSQRT28PD.SAE zmm zmm
func VRSQRT28PD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28PD_SAE: bad operands")
}

// VRSQRT28PD_SAE_Z: Approximation to the Reciprocal Square Root of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRSQRT28PD.SAE.Z zmm k zmm
func VRSQRT28PD_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28PD_SAE_Z: bad operands")
}

// VRSQRT28PD_Z: Approximation to the Reciprocal Square Root of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Zeroing Masking).
//
// Forms:
//
// 	VRSQRT28PD.Z m512 k zmm
// 	VRSQRT28PD.Z zmm  k zmm
func VRSQRT28PD_Z(mz, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsZMM(z),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, z},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28PD_Z: bad operands")
}

// VRSQRT28PS: Approximation to the Reciprocal Square Root of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error.
//
// Forms:
//
// 	VRSQRT28PS m512 k zmm
// 	VRSQRT28PS m512 zmm
// 	VRSQRT28PS zmm  k zmm
// 	VRSQRT28PS zmm  zmm
func VRSQRT28PS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28PS: bad operands")
}

// VRSQRT28PS_BCST: Approximation to the Reciprocal Square Root of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Broadcast).
//
// Forms:
//
// 	VRSQRT28PS.BCST m32 k zmm
// 	VRSQRT28PS.BCST m32 zmm
func VRSQRT28PS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28PS_BCST: bad operands")
}

// VRSQRT28PS_BCST_Z: Approximation to the Reciprocal Square Root of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VRSQRT28PS.BCST.Z m32 k zmm
func VRSQRT28PS_BCST_Z(m, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, z},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28PS_BCST_Z: bad operands")
}

// VRSQRT28PS_SAE: Approximation to the Reciprocal Square Root of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Suppress All Exceptions).
//
// Forms:
//
// 	VRSQRT28PS.SAE zmm k zmm
// 	VRSQRT28PS.SAE zmm zmm
func VRSQRT28PS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28PS_SAE: bad operands")
}

// VRSQRT28PS_SAE_Z: Approximation to the Reciprocal Square Root of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRSQRT28PS.SAE.Z zmm k zmm
func VRSQRT28PS_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28PS_SAE_Z: bad operands")
}

// VRSQRT28PS_Z: Approximation to the Reciprocal Square Root of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error (Zeroing Masking).
//
// Forms:
//
// 	VRSQRT28PS.Z m512 k zmm
// 	VRSQRT28PS.Z zmm  k zmm
func VRSQRT28PS_Z(mz, k, z operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mz) && operand.IsK(k) && operand.IsZMM(z),
		operand.IsZMM(mz) && operand.IsK(k) && operand.IsZMM(z):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28PS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mz, k, z},
			Inputs:   []operand.Op{mz, k},
			Outputs:  []operand.Op{z},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28PS_Z: bad operands")
}

// VRSQRT28SD: Approximation to the Reciprocal Square Root of a Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error.
//
// Forms:
//
// 	VRSQRT28SD m64 xmm k xmm
// 	VRSQRT28SD m64 xmm xmm
// 	VRSQRT28SD xmm xmm k xmm
// 	VRSQRT28SD xmm xmm xmm
func VRSQRT28SD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28SD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28SD: bad operands")
}

// VRSQRT28SD_SAE: Approximation to the Reciprocal Square Root of a Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error (Suppress All Exceptions).
//
// Forms:
//
// 	VRSQRT28SD.SAE xmm xmm k xmm
// 	VRSQRT28SD.SAE xmm xmm xmm
func VRSQRT28SD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28SD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28SD",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28SD_SAE: bad operands")
}

// VRSQRT28SD_SAE_Z: Approximation to the Reciprocal Square Root of a Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRSQRT28SD.SAE.Z xmm xmm k xmm
func VRSQRT28SD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28SD",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28SD_SAE_Z: bad operands")
}

// VRSQRT28SD_Z: Approximation to the Reciprocal Square Root of a Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error (Zeroing Masking).
//
// Forms:
//
// 	VRSQRT28SD.Z m64 xmm k xmm
// 	VRSQRT28SD.Z xmm xmm k xmm
func VRSQRT28SD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28SD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28SD_Z: bad operands")
}

// VRSQRT28SS: Approximation to the Reciprocal Square Root of a Scalar Single-Precision Floating-Point Value with Less Than 2^-28 Relative Error.
//
// Forms:
//
// 	VRSQRT28SS m32 xmm k xmm
// 	VRSQRT28SS m32 xmm xmm
// 	VRSQRT28SS xmm xmm k xmm
// 	VRSQRT28SS xmm xmm xmm
func VRSQRT28SS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28SS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28SS: bad operands")
}

// VRSQRT28SS_SAE: Approximation to the Reciprocal Square Root of a Scalar Single-Precision Floating-Point Value with Less Than 2^-28 Relative Error (Suppress All Exceptions).
//
// Forms:
//
// 	VRSQRT28SS.SAE xmm xmm k xmm
// 	VRSQRT28SS.SAE xmm xmm xmm
func VRSQRT28SS_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28SS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512ER"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28SS",
			Suffixes: []string{"SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28SS_SAE: bad operands")
}

// VRSQRT28SS_SAE_Z: Approximation to the Reciprocal Square Root of a Scalar Single-Precision Floating-Point Value with Less Than 2^-28 Relative Error (Suppress All Exceptions, Zeroing Masking).
//
// Forms:
//
// 	VRSQRT28SS.SAE.Z xmm xmm k xmm
func VRSQRT28SS_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28SS",
			Suffixes: []string{"SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28SS_SAE_Z: bad operands")
}

// VRSQRT28SS_Z: Approximation to the Reciprocal Square Root of a Scalar Single-Precision Floating-Point Value with Less Than 2^-28 Relative Error (Zeroing Masking).
//
// Forms:
//
// 	VRSQRT28SS.Z m32 xmm k xmm
// 	VRSQRT28SS.Z xmm xmm k xmm
func VRSQRT28SS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VRSQRT28SS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512ER"},
		}, nil
	}
	return nil, errors.New("VRSQRT28SS_Z: bad operands")
}

// VRSQRTPS: Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VRSQRTPS m128 xmm
// 	VRSQRTPS m256 ymm
// 	VRSQRTPS xmm  xmm
// 	VRSQRTPS ymm  ymm
func VRSQRTPS(mxy, xy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy),
		operand.IsM256(mxy) && operand.IsYMM(xy),
		operand.IsXMM(mxy) && operand.IsXMM(xy),
		operand.IsYMM(mxy) && operand.IsYMM(xy):
		return &intrep.Instruction{
			Opcode:   "VRSQRTPS",
			Operands: []operand.Op{mxy, xy},
			Inputs:   []operand.Op{mxy},
			Outputs:  []operand.Op{xy},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VRSQRTPS: bad operands")
}

// VRSQRTSS: Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	VRSQRTSS m32 xmm xmm
// 	VRSQRTSS xmm xmm xmm
func VRSQRTSS(mx, x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VRSQRTSS",
			Operands: []operand.Op{mx, x, x1},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VRSQRTSS: bad operands")
}

// VSCALEFPD: Scale Packed Double-Precision Floating-Point Values With Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VSCALEFPD m512 zmm k zmm
// 	VSCALEFPD m512 zmm zmm
// 	VSCALEFPD zmm  zmm k zmm
// 	VSCALEFPD zmm  zmm zmm
// 	VSCALEFPD m128 xmm k xmm
// 	VSCALEFPD m128 xmm xmm
// 	VSCALEFPD m256 ymm k ymm
// 	VSCALEFPD m256 ymm ymm
// 	VSCALEFPD xmm  xmm k xmm
// 	VSCALEFPD xmm  xmm xmm
// 	VSCALEFPD ymm  ymm k ymm
// 	VSCALEFPD ymm  ymm ymm
func VSCALEFPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPD: bad operands")
}

// VSCALEFPD_BCST: Scale Packed Double-Precision Floating-Point Values With Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VSCALEFPD.BCST m64 zmm k zmm
// 	VSCALEFPD.BCST m64 zmm zmm
// 	VSCALEFPD.BCST m64 xmm k xmm
// 	VSCALEFPD.BCST m64 xmm xmm
// 	VSCALEFPD.BCST m64 ymm k ymm
// 	VSCALEFPD.BCST m64 ymm ymm
func VSCALEFPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPD_BCST: bad operands")
}

// VSCALEFPD_BCST_Z: Scale Packed Double-Precision Floating-Point Values With Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFPD.BCST.Z m64 zmm k zmm
// 	VSCALEFPD.BCST.Z m64 xmm k xmm
// 	VSCALEFPD.BCST.Z m64 ymm k ymm
func VSCALEFPD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPD_BCST_Z: bad operands")
}

// VSCALEFPD_RD_SAE: Scale Packed Double-Precision Floating-Point Values With Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VSCALEFPD.RD_SAE zmm zmm k zmm
// 	VSCALEFPD.RD_SAE zmm zmm zmm
func VSCALEFPD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPD_RD_SAE: bad operands")
}

// VSCALEFPD_RD_SAE_Z: Scale Packed Double-Precision Floating-Point Values With Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFPD.RD_SAE.Z zmm zmm k zmm
func VSCALEFPD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPD_RD_SAE_Z: bad operands")
}

// VSCALEFPD_RN_SAE: Scale Packed Double-Precision Floating-Point Values With Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VSCALEFPD.RN_SAE zmm zmm k zmm
// 	VSCALEFPD.RN_SAE zmm zmm zmm
func VSCALEFPD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPD_RN_SAE: bad operands")
}

// VSCALEFPD_RN_SAE_Z: Scale Packed Double-Precision Floating-Point Values With Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFPD.RN_SAE.Z zmm zmm k zmm
func VSCALEFPD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPD_RN_SAE_Z: bad operands")
}

// VSCALEFPD_RU_SAE: Scale Packed Double-Precision Floating-Point Values With Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VSCALEFPD.RU_SAE zmm zmm k zmm
// 	VSCALEFPD.RU_SAE zmm zmm zmm
func VSCALEFPD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPD_RU_SAE: bad operands")
}

// VSCALEFPD_RU_SAE_Z: Scale Packed Double-Precision Floating-Point Values With Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFPD.RU_SAE.Z zmm zmm k zmm
func VSCALEFPD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPD_RU_SAE_Z: bad operands")
}

// VSCALEFPD_RZ_SAE: Scale Packed Double-Precision Floating-Point Values With Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VSCALEFPD.RZ_SAE zmm zmm k zmm
// 	VSCALEFPD.RZ_SAE zmm zmm zmm
func VSCALEFPD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPD_RZ_SAE: bad operands")
}

// VSCALEFPD_RZ_SAE_Z: Scale Packed Double-Precision Floating-Point Values With Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFPD.RZ_SAE.Z zmm zmm k zmm
func VSCALEFPD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPD_RZ_SAE_Z: bad operands")
}

// VSCALEFPD_Z: Scale Packed Double-Precision Floating-Point Values With Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VSCALEFPD.Z m512 zmm k zmm
// 	VSCALEFPD.Z zmm  zmm k zmm
// 	VSCALEFPD.Z m128 xmm k xmm
// 	VSCALEFPD.Z m256 ymm k ymm
// 	VSCALEFPD.Z xmm  xmm k xmm
// 	VSCALEFPD.Z ymm  ymm k ymm
func VSCALEFPD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPD_Z: bad operands")
}

// VSCALEFPS: Scale Packed Single-Precision Floating-Point Values With Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VSCALEFPS m512 zmm k zmm
// 	VSCALEFPS m512 zmm zmm
// 	VSCALEFPS zmm  zmm k zmm
// 	VSCALEFPS zmm  zmm zmm
// 	VSCALEFPS m128 xmm k xmm
// 	VSCALEFPS m128 xmm xmm
// 	VSCALEFPS m256 ymm k ymm
// 	VSCALEFPS m256 ymm ymm
// 	VSCALEFPS xmm  xmm k xmm
// 	VSCALEFPS xmm  xmm xmm
// 	VSCALEFPS ymm  ymm k ymm
// 	VSCALEFPS ymm  ymm ymm
func VSCALEFPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPS: bad operands")
}

// VSCALEFPS_BCST: Scale Packed Single-Precision Floating-Point Values With Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VSCALEFPS.BCST m32 zmm k zmm
// 	VSCALEFPS.BCST m32 zmm zmm
// 	VSCALEFPS.BCST m32 xmm k xmm
// 	VSCALEFPS.BCST m32 xmm xmm
// 	VSCALEFPS.BCST m32 ymm k ymm
// 	VSCALEFPS.BCST m32 ymm ymm
func VSCALEFPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPS_BCST: bad operands")
}

// VSCALEFPS_BCST_Z: Scale Packed Single-Precision Floating-Point Values With Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFPS.BCST.Z m32 zmm k zmm
// 	VSCALEFPS.BCST.Z m32 xmm k xmm
// 	VSCALEFPS.BCST.Z m32 ymm k ymm
func VSCALEFPS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPS_BCST_Z: bad operands")
}

// VSCALEFPS_RD_SAE: Scale Packed Single-Precision Floating-Point Values With Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VSCALEFPS.RD_SAE zmm zmm k zmm
// 	VSCALEFPS.RD_SAE zmm zmm zmm
func VSCALEFPS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPS_RD_SAE: bad operands")
}

// VSCALEFPS_RD_SAE_Z: Scale Packed Single-Precision Floating-Point Values With Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFPS.RD_SAE.Z zmm zmm k zmm
func VSCALEFPS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPS_RD_SAE_Z: bad operands")
}

// VSCALEFPS_RN_SAE: Scale Packed Single-Precision Floating-Point Values With Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VSCALEFPS.RN_SAE zmm zmm k zmm
// 	VSCALEFPS.RN_SAE zmm zmm zmm
func VSCALEFPS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPS_RN_SAE: bad operands")
}

// VSCALEFPS_RN_SAE_Z: Scale Packed Single-Precision Floating-Point Values With Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFPS.RN_SAE.Z zmm zmm k zmm
func VSCALEFPS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPS_RN_SAE_Z: bad operands")
}

// VSCALEFPS_RU_SAE: Scale Packed Single-Precision Floating-Point Values With Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VSCALEFPS.RU_SAE zmm zmm k zmm
// 	VSCALEFPS.RU_SAE zmm zmm zmm
func VSCALEFPS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPS_RU_SAE: bad operands")
}

// VSCALEFPS_RU_SAE_Z: Scale Packed Single-Precision Floating-Point Values With Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFPS.RU_SAE.Z zmm zmm k zmm
func VSCALEFPS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPS_RU_SAE_Z: bad operands")
}

// VSCALEFPS_RZ_SAE: Scale Packed Single-Precision Floating-Point Values With Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VSCALEFPS.RZ_SAE zmm zmm k zmm
// 	VSCALEFPS.RZ_SAE zmm zmm zmm
func VSCALEFPS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPS_RZ_SAE: bad operands")
}

// VSCALEFPS_RZ_SAE_Z: Scale Packed Single-Precision Floating-Point Values With Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFPS.RZ_SAE.Z zmm zmm k zmm
func VSCALEFPS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPS_RZ_SAE_Z: bad operands")
}

// VSCALEFPS_Z: Scale Packed Single-Precision Floating-Point Values With Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VSCALEFPS.Z m512 zmm k zmm
// 	VSCALEFPS.Z zmm  zmm k zmm
// 	VSCALEFPS.Z m128 xmm k xmm
// 	VSCALEFPS.Z m256 ymm k ymm
// 	VSCALEFPS.Z xmm  xmm k xmm
// 	VSCALEFPS.Z ymm  ymm k ymm
func VSCALEFPS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSCALEFPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFPS_Z: bad operands")
}

// VSCALEFSD: Scale Scalar Double-Precision Floating-Point Value With a Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VSCALEFSD m64 xmm k xmm
// 	VSCALEFSD m64 xmm xmm
// 	VSCALEFSD xmm xmm k xmm
// 	VSCALEFSD xmm xmm xmm
func VSCALEFSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSD: bad operands")
}

// VSCALEFSD_RD_SAE: Scale Scalar Double-Precision Floating-Point Value With a Double-Precision Floating-Point Value (Round Towards Negative Infinity).
//
// Forms:
//
// 	VSCALEFSD.RD_SAE xmm xmm k xmm
// 	VSCALEFSD.RD_SAE xmm xmm xmm
func VSCALEFSD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSD_RD_SAE: bad operands")
}

// VSCALEFSD_RD_SAE_Z: Scale Scalar Double-Precision Floating-Point Value With a Double-Precision Floating-Point Value (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFSD.RD_SAE.Z xmm xmm k xmm
func VSCALEFSD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSD_RD_SAE_Z: bad operands")
}

// VSCALEFSD_RN_SAE: Scale Scalar Double-Precision Floating-Point Value With a Double-Precision Floating-Point Value (Round Towards Nearest).
//
// Forms:
//
// 	VSCALEFSD.RN_SAE xmm xmm k xmm
// 	VSCALEFSD.RN_SAE xmm xmm xmm
func VSCALEFSD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSD_RN_SAE: bad operands")
}

// VSCALEFSD_RN_SAE_Z: Scale Scalar Double-Precision Floating-Point Value With a Double-Precision Floating-Point Value (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFSD.RN_SAE.Z xmm xmm k xmm
func VSCALEFSD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSD_RN_SAE_Z: bad operands")
}

// VSCALEFSD_RU_SAE: Scale Scalar Double-Precision Floating-Point Value With a Double-Precision Floating-Point Value (Round Towards Positive Infinity).
//
// Forms:
//
// 	VSCALEFSD.RU_SAE xmm xmm k xmm
// 	VSCALEFSD.RU_SAE xmm xmm xmm
func VSCALEFSD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSD_RU_SAE: bad operands")
}

// VSCALEFSD_RU_SAE_Z: Scale Scalar Double-Precision Floating-Point Value With a Double-Precision Floating-Point Value (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFSD.RU_SAE.Z xmm xmm k xmm
func VSCALEFSD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSD_RU_SAE_Z: bad operands")
}

// VSCALEFSD_RZ_SAE: Scale Scalar Double-Precision Floating-Point Value With a Double-Precision Floating-Point Value (Round Towards Zero).
//
// Forms:
//
// 	VSCALEFSD.RZ_SAE xmm xmm k xmm
// 	VSCALEFSD.RZ_SAE xmm xmm xmm
func VSCALEFSD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSD_RZ_SAE: bad operands")
}

// VSCALEFSD_RZ_SAE_Z: Scale Scalar Double-Precision Floating-Point Value With a Double-Precision Floating-Point Value (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFSD.RZ_SAE.Z xmm xmm k xmm
func VSCALEFSD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSD_RZ_SAE_Z: bad operands")
}

// VSCALEFSD_Z: Scale Scalar Double-Precision Floating-Point Value With a Double-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VSCALEFSD.Z m64 xmm k xmm
// 	VSCALEFSD.Z xmm xmm k xmm
func VSCALEFSD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSD_Z: bad operands")
}

// VSCALEFSS: Scale Scalar Single-Precision Floating-Point Value With a Single-Precision Floating-Point Value.
//
// Forms:
//
// 	VSCALEFSS m32 xmm k xmm
// 	VSCALEFSS m32 xmm xmm
// 	VSCALEFSS xmm xmm k xmm
// 	VSCALEFSS xmm xmm xmm
func VSCALEFSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSS: bad operands")
}

// VSCALEFSS_RD_SAE: Scale Scalar Single-Precision Floating-Point Value With a Single-Precision Floating-Point Value (Round Towards Negative Infinity).
//
// Forms:
//
// 	VSCALEFSS.RD_SAE xmm xmm k xmm
// 	VSCALEFSS.RD_SAE xmm xmm xmm
func VSCALEFSS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSS_RD_SAE: bad operands")
}

// VSCALEFSS_RD_SAE_Z: Scale Scalar Single-Precision Floating-Point Value With a Single-Precision Floating-Point Value (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFSS.RD_SAE.Z xmm xmm k xmm
func VSCALEFSS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSS_RD_SAE_Z: bad operands")
}

// VSCALEFSS_RN_SAE: Scale Scalar Single-Precision Floating-Point Value With a Single-Precision Floating-Point Value (Round Towards Nearest).
//
// Forms:
//
// 	VSCALEFSS.RN_SAE xmm xmm k xmm
// 	VSCALEFSS.RN_SAE xmm xmm xmm
func VSCALEFSS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSS_RN_SAE: bad operands")
}

// VSCALEFSS_RN_SAE_Z: Scale Scalar Single-Precision Floating-Point Value With a Single-Precision Floating-Point Value (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFSS.RN_SAE.Z xmm xmm k xmm
func VSCALEFSS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSS_RN_SAE_Z: bad operands")
}

// VSCALEFSS_RU_SAE: Scale Scalar Single-Precision Floating-Point Value With a Single-Precision Floating-Point Value (Round Towards Positive Infinity).
//
// Forms:
//
// 	VSCALEFSS.RU_SAE xmm xmm k xmm
// 	VSCALEFSS.RU_SAE xmm xmm xmm
func VSCALEFSS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSS_RU_SAE: bad operands")
}

// VSCALEFSS_RU_SAE_Z: Scale Scalar Single-Precision Floating-Point Value With a Single-Precision Floating-Point Value (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFSS.RU_SAE.Z xmm xmm k xmm
func VSCALEFSS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSS_RU_SAE_Z: bad operands")
}

// VSCALEFSS_RZ_SAE: Scale Scalar Single-Precision Floating-Point Value With a Single-Precision Floating-Point Value (Round Towards Zero).
//
// Forms:
//
// 	VSCALEFSS.RZ_SAE xmm xmm k xmm
// 	VSCALEFSS.RZ_SAE xmm xmm xmm
func VSCALEFSS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSS_RZ_SAE: bad operands")
}

// VSCALEFSS_RZ_SAE_Z: Scale Scalar Single-Precision Floating-Point Value With a Single-Precision Floating-Point Value (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VSCALEFSS.RZ_SAE.Z xmm xmm k xmm
func VSCALEFSS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSS_RZ_SAE_Z: bad operands")
}

// VSCALEFSS_Z: Scale Scalar Single-Precision Floating-Point Value With a Single-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VSCALEFSS.Z m32 xmm k xmm
// 	VSCALEFSS.Z xmm xmm k xmm
func VSCALEFSS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VSCALEFSS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCALEFSS_Z: bad operands")
}

// VSCATTERDPD: Scatter Packed Double-Precision Floating-Point Values with Signed Doubleword Indices.
//
// Forms:
//
// 	VSCATTERDPD zmm k vm32y
// 	VSCATTERDPD xmm k vm32x
// 	VSCATTERDPD ymm k vm32x
func VSCATTERDPD(xyz, k, v operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsVM32Y(v):
		return &intrep.Instruction{
			Opcode:   "VSCATTERDPD",
			Operands: []operand.Op{xyz, k, v},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsVM32X(v),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsVM32X(v):
		return &intrep.Instruction{
			Opcode:   "VSCATTERDPD",
			Operands: []operand.Op{xyz, k, v},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCATTERDPD: bad operands")
}

// VSCATTERDPS: Scatter Packed Single-Precision Floating-Point Values with Signed Doubleword Indices.
//
// Forms:
//
// 	VSCATTERDPS zmm k vm32z
// 	VSCATTERDPS xmm k vm32x
// 	VSCATTERDPS ymm k vm32y
func VSCATTERDPS(xyz, k, v operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsVM32Z(v):
		return &intrep.Instruction{
			Opcode:   "VSCATTERDPS",
			Operands: []operand.Op{xyz, k, v},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsVM32X(v),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsVM32Y(v):
		return &intrep.Instruction{
			Opcode:   "VSCATTERDPS",
			Operands: []operand.Op{xyz, k, v},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCATTERDPS: bad operands")
}

// VSCATTERQPD: Scatter Packed Double-Precision Floating-Point Values with Signed Quadword Indices.
//
// Forms:
//
// 	VSCATTERQPD zmm k vm64z
// 	VSCATTERQPD xmm k vm64x
// 	VSCATTERQPD ymm k vm64y
func VSCATTERQPD(xyz, k, v operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(xyz) && operand.IsK(k) && operand.IsVM64Z(v):
		return &intrep.Instruction{
			Opcode:   "VSCATTERQPD",
			Operands: []operand.Op{xyz, k, v},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xyz) && operand.IsK(k) && operand.IsVM64X(v),
		operand.IsYMM(xyz) && operand.IsK(k) && operand.IsVM64Y(v):
		return &intrep.Instruction{
			Opcode:   "VSCATTERQPD",
			Operands: []operand.Op{xyz, k, v},
			Inputs:   []operand.Op{xyz, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCATTERQPD: bad operands")
}

// VSCATTERQPS: Scatter Packed Single-Precision Floating-Point Values with Signed Quadword Indices.
//
// Forms:
//
// 	VSCATTERQPS ymm k vm64z
// 	VSCATTERQPS xmm k vm64x
// 	VSCATTERQPS xmm k vm64y
func VSCATTERQPS(xy, k, v operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsYMM(xy) && operand.IsK(k) && operand.IsVM64Z(v):
		return &intrep.Instruction{
			Opcode:   "VSCATTERQPS",
			Operands: []operand.Op{xy, k, v},
			Inputs:   []operand.Op{xy, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsXMM(xy) && operand.IsK(k) && operand.IsVM64X(v),
		operand.IsXMM(xy) && operand.IsK(k) && operand.IsVM64Y(v):
		return &intrep.Instruction{
			Opcode:   "VSCATTERQPS",
			Operands: []operand.Op{xy, k, v},
			Inputs:   []operand.Op{xy, k},
			Outputs:  []operand.Op{v},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSCATTERQPS: bad operands")
}

// VSHUFF32X4: Shuffle 128-Bit Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VSHUFF32X4 imm8 m512 zmm k zmm
// 	VSHUFF32X4 imm8 m512 zmm zmm
// 	VSHUFF32X4 imm8 zmm  zmm k zmm
// 	VSHUFF32X4 imm8 zmm  zmm zmm
// 	VSHUFF32X4 imm8 m256 ymm k ymm
// 	VSHUFF32X4 imm8 m256 ymm ymm
// 	VSHUFF32X4 imm8 ymm  ymm k ymm
// 	VSHUFF32X4 imm8 ymm  ymm ymm
func VSHUFF32X4(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFF32X4: bad operands")
}

// VSHUFF32X4_BCST: Shuffle 128-Bit Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VSHUFF32X4.BCST imm8 m32 zmm k zmm
// 	VSHUFF32X4.BCST imm8 m32 zmm zmm
// 	VSHUFF32X4.BCST imm8 m32 ymm k ymm
// 	VSHUFF32X4.BCST imm8 m32 ymm ymm
func VSHUFF32X4_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF32X4",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF32X4",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF32X4",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF32X4",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFF32X4_BCST: bad operands")
}

// VSHUFF32X4_BCST_Z: Shuffle 128-Bit Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VSHUFF32X4.BCST.Z imm8 m32 zmm k zmm
// 	VSHUFF32X4.BCST.Z imm8 m32 ymm k ymm
func VSHUFF32X4_BCST_Z(i, m, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFF32X4",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, yz, k, yz1},
			Inputs:   []operand.Op{m, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFF32X4",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, yz, k, yz1},
			Inputs:   []operand.Op{m, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFF32X4_BCST_Z: bad operands")
}

// VSHUFF32X4_Z: Shuffle 128-Bit Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VSHUFF32X4.Z imm8 m512 zmm k zmm
// 	VSHUFF32X4.Z imm8 zmm  zmm k zmm
// 	VSHUFF32X4.Z imm8 m256 ymm k ymm
// 	VSHUFF32X4.Z imm8 ymm  ymm k ymm
func VSHUFF32X4_Z(i, myz, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(myz) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1),
		operand.IsIMM8(i) && operand.IsZMM(myz) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFF32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, myz, yz, k, yz1},
			Inputs:   []operand.Op{myz, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM256(myz) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1),
		operand.IsIMM8(i) && operand.IsYMM(myz) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFF32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, myz, yz, k, yz1},
			Inputs:   []operand.Op{myz, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFF32X4_Z: bad operands")
}

// VSHUFF64X2: Shuffle 128-Bit Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VSHUFF64X2 imm8 m512 zmm k zmm
// 	VSHUFF64X2 imm8 m512 zmm zmm
// 	VSHUFF64X2 imm8 zmm  zmm k zmm
// 	VSHUFF64X2 imm8 zmm  zmm zmm
// 	VSHUFF64X2 imm8 m256 ymm k ymm
// 	VSHUFF64X2 imm8 m256 ymm ymm
// 	VSHUFF64X2 imm8 ymm  ymm k ymm
// 	VSHUFF64X2 imm8 ymm  ymm ymm
func VSHUFF64X2(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFF64X2: bad operands")
}

// VSHUFF64X2_BCST: Shuffle 128-Bit Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VSHUFF64X2.BCST imm8 m64 zmm k zmm
// 	VSHUFF64X2.BCST imm8 m64 zmm zmm
// 	VSHUFF64X2.BCST imm8 m64 ymm k ymm
// 	VSHUFF64X2.BCST imm8 m64 ymm ymm
func VSHUFF64X2_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF64X2",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF64X2",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF64X2",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFF64X2",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFF64X2_BCST: bad operands")
}

// VSHUFF64X2_BCST_Z: Shuffle 128-Bit Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VSHUFF64X2.BCST.Z imm8 m64 zmm k zmm
// 	VSHUFF64X2.BCST.Z imm8 m64 ymm k ymm
func VSHUFF64X2_BCST_Z(i, m, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFF64X2",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, yz, k, yz1},
			Inputs:   []operand.Op{m, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFF64X2",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, yz, k, yz1},
			Inputs:   []operand.Op{m, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFF64X2_BCST_Z: bad operands")
}

// VSHUFF64X2_Z: Shuffle 128-Bit Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VSHUFF64X2.Z imm8 m512 zmm k zmm
// 	VSHUFF64X2.Z imm8 zmm  zmm k zmm
// 	VSHUFF64X2.Z imm8 m256 ymm k ymm
// 	VSHUFF64X2.Z imm8 ymm  ymm k ymm
func VSHUFF64X2_Z(i, myz, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(myz) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1),
		operand.IsIMM8(i) && operand.IsZMM(myz) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFF64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, myz, yz, k, yz1},
			Inputs:   []operand.Op{myz, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM256(myz) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1),
		operand.IsIMM8(i) && operand.IsYMM(myz) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFF64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, myz, yz, k, yz1},
			Inputs:   []operand.Op{myz, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFF64X2_Z: bad operands")
}

// VSHUFI32X4: Shuffle 128-Bit Packed Doubleword Integer Values.
//
// Forms:
//
// 	VSHUFI32X4 imm8 m512 zmm k zmm
// 	VSHUFI32X4 imm8 m512 zmm zmm
// 	VSHUFI32X4 imm8 zmm  zmm k zmm
// 	VSHUFI32X4 imm8 zmm  zmm zmm
// 	VSHUFI32X4 imm8 m256 ymm k ymm
// 	VSHUFI32X4 imm8 m256 ymm ymm
// 	VSHUFI32X4 imm8 ymm  ymm k ymm
// 	VSHUFI32X4 imm8 ymm  ymm ymm
func VSHUFI32X4(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI32X4",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFI32X4: bad operands")
}

// VSHUFI32X4_BCST: Shuffle 128-Bit Packed Doubleword Integer Values (Broadcast).
//
// Forms:
//
// 	VSHUFI32X4.BCST imm8 m32 zmm k zmm
// 	VSHUFI32X4.BCST imm8 m32 zmm zmm
// 	VSHUFI32X4.BCST imm8 m32 ymm k ymm
// 	VSHUFI32X4.BCST imm8 m32 ymm ymm
func VSHUFI32X4_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI32X4",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI32X4",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI32X4",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI32X4",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFI32X4_BCST: bad operands")
}

// VSHUFI32X4_BCST_Z: Shuffle 128-Bit Packed Doubleword Integer Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VSHUFI32X4.BCST.Z imm8 m32 zmm k zmm
// 	VSHUFI32X4.BCST.Z imm8 m32 ymm k ymm
func VSHUFI32X4_BCST_Z(i, m, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFI32X4",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, yz, k, yz1},
			Inputs:   []operand.Op{m, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFI32X4",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, yz, k, yz1},
			Inputs:   []operand.Op{m, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFI32X4_BCST_Z: bad operands")
}

// VSHUFI32X4_Z: Shuffle 128-Bit Packed Doubleword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VSHUFI32X4.Z imm8 m512 zmm k zmm
// 	VSHUFI32X4.Z imm8 zmm  zmm k zmm
// 	VSHUFI32X4.Z imm8 m256 ymm k ymm
// 	VSHUFI32X4.Z imm8 ymm  ymm k ymm
func VSHUFI32X4_Z(i, myz, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(myz) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1),
		operand.IsIMM8(i) && operand.IsZMM(myz) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFI32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, myz, yz, k, yz1},
			Inputs:   []operand.Op{myz, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM256(myz) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1),
		operand.IsIMM8(i) && operand.IsYMM(myz) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFI32X4",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, myz, yz, k, yz1},
			Inputs:   []operand.Op{myz, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFI32X4_Z: bad operands")
}

// VSHUFI64X2: Shuffle 128-Bit Packed Quadword Integer Values.
//
// Forms:
//
// 	VSHUFI64X2 imm8 m512 zmm k zmm
// 	VSHUFI64X2 imm8 m512 zmm zmm
// 	VSHUFI64X2 imm8 zmm  zmm k zmm
// 	VSHUFI64X2 imm8 zmm  zmm zmm
// 	VSHUFI64X2 imm8 m256 ymm k ymm
// 	VSHUFI64X2 imm8 m256 ymm ymm
// 	VSHUFI64X2 imm8 ymm  ymm k ymm
// 	VSHUFI64X2 imm8 ymm  ymm ymm
func VSHUFI64X2(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI64X2",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFI64X2: bad operands")
}

// VSHUFI64X2_BCST: Shuffle 128-Bit Packed Quadword Integer Values (Broadcast).
//
// Forms:
//
// 	VSHUFI64X2.BCST imm8 m64 zmm k zmm
// 	VSHUFI64X2.BCST imm8 m64 zmm zmm
// 	VSHUFI64X2.BCST imm8 m64 ymm k ymm
// 	VSHUFI64X2.BCST imm8 m64 ymm ymm
func VSHUFI64X2_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI64X2",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI64X2",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI64X2",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFI64X2",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFI64X2_BCST: bad operands")
}

// VSHUFI64X2_BCST_Z: Shuffle 128-Bit Packed Quadword Integer Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VSHUFI64X2.BCST.Z imm8 m64 zmm k zmm
// 	VSHUFI64X2.BCST.Z imm8 m64 ymm k ymm
func VSHUFI64X2_BCST_Z(i, m, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFI64X2",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, yz, k, yz1},
			Inputs:   []operand.Op{m, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFI64X2",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, yz, k, yz1},
			Inputs:   []operand.Op{m, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFI64X2_BCST_Z: bad operands")
}

// VSHUFI64X2_Z: Shuffle 128-Bit Packed Quadword Integer Values (Zeroing Masking).
//
// Forms:
//
// 	VSHUFI64X2.Z imm8 m512 zmm k zmm
// 	VSHUFI64X2.Z imm8 zmm  zmm k zmm
// 	VSHUFI64X2.Z imm8 m256 ymm k ymm
// 	VSHUFI64X2.Z imm8 ymm  ymm k ymm
func VSHUFI64X2_Z(i, myz, yz, k, yz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(myz) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1),
		operand.IsIMM8(i) && operand.IsZMM(myz) && operand.IsZMM(yz) && operand.IsK(k) && operand.IsZMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFI64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, myz, yz, k, yz1},
			Inputs:   []operand.Op{myz, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM256(myz) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1),
		operand.IsIMM8(i) && operand.IsYMM(myz) && operand.IsYMM(yz) && operand.IsK(k) && operand.IsYMM(yz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFI64X2",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, myz, yz, k, yz1},
			Inputs:   []operand.Op{myz, yz, k},
			Outputs:  []operand.Op{yz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFI64X2_Z: bad operands")
}

// VSHUFPD: Shuffle Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VSHUFPD imm8 m128 xmm xmm
// 	VSHUFPD imm8 m256 ymm ymm
// 	VSHUFPD imm8 xmm  xmm xmm
// 	VSHUFPD imm8 ymm  ymm ymm
// 	VSHUFPD imm8 m512 zmm k zmm
// 	VSHUFPD imm8 m512 zmm zmm
// 	VSHUFPD imm8 zmm  zmm k zmm
// 	VSHUFPD imm8 zmm  zmm zmm
// 	VSHUFPD imm8 m128 xmm k xmm
// 	VSHUFPD imm8 m256 ymm k ymm
// 	VSHUFPD imm8 xmm  xmm k xmm
// 	VSHUFPD imm8 ymm  ymm k ymm
func VSHUFPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFPD: bad operands")
}

// VSHUFPD_BCST: Shuffle Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VSHUFPD.BCST imm8 m64 zmm k zmm
// 	VSHUFPD.BCST imm8 m64 zmm zmm
// 	VSHUFPD.BCST imm8 m64 xmm k xmm
// 	VSHUFPD.BCST imm8 m64 xmm xmm
// 	VSHUFPD.BCST imm8 m64 ymm k ymm
// 	VSHUFPD.BCST imm8 m64 ymm ymm
func VSHUFPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM64(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFPD_BCST: bad operands")
}

// VSHUFPD_BCST_Z: Shuffle Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VSHUFPD.BCST.Z imm8 m64 zmm k zmm
// 	VSHUFPD.BCST.Z imm8 m64 xmm k xmm
// 	VSHUFPD.BCST.Z imm8 m64 ymm k ymm
func VSHUFPD_BCST_Z(i, m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFPD_BCST_Z: bad operands")
}

// VSHUFPD_Z: Shuffle Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VSHUFPD.Z imm8 m512 zmm k zmm
// 	VSHUFPD.Z imm8 zmm  zmm k zmm
// 	VSHUFPD.Z imm8 m128 xmm k xmm
// 	VSHUFPD.Z imm8 m256 ymm k ymm
// 	VSHUFPD.Z imm8 xmm  xmm k xmm
// 	VSHUFPD.Z imm8 ymm  ymm k ymm
func VSHUFPD_Z(i, mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFPD_Z: bad operands")
}

// VSHUFPS: Shuffle Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VSHUFPS imm8 m128 xmm xmm
// 	VSHUFPS imm8 m256 ymm ymm
// 	VSHUFPS imm8 xmm  xmm xmm
// 	VSHUFPS imm8 ymm  ymm ymm
// 	VSHUFPS imm8 m512 zmm k zmm
// 	VSHUFPS imm8 m512 zmm zmm
// 	VSHUFPS imm8 zmm  zmm k zmm
// 	VSHUFPS imm8 zmm  zmm zmm
// 	VSHUFPS imm8 m128 xmm k xmm
// 	VSHUFPS imm8 m256 ymm k ymm
// 	VSHUFPS imm8 xmm  xmm k xmm
// 	VSHUFPS imm8 ymm  ymm k ymm
func VSHUFPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM128(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM256(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM512(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFPS: bad operands")
}

// VSHUFPS_BCST: Shuffle Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VSHUFPS.BCST imm8 m32 zmm k zmm
// 	VSHUFPS.BCST imm8 m32 zmm zmm
// 	VSHUFPS.BCST imm8 m32 xmm k xmm
// 	VSHUFPS.BCST imm8 m32 xmm xmm
// 	VSHUFPS.BCST imm8 m32 ymm k ymm
// 	VSHUFPS.BCST imm8 m32 ymm ymm
func VSHUFPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsK(ops[3]) && operand.IsZMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsK(ops[3]) && operand.IsXMM(ops[4]),
		len(ops) == 5 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsK(ops[3]) && operand.IsYMM(ops[4]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2], ops[3], ops[4]},
			Outputs:  []operand.Op{ops[4]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsZMM(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsXMM(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsIMM8(ops[0]) && operand.IsM32(ops[1]) && operand.IsYMM(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSHUFPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[1], ops[2]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFPS_BCST: bad operands")
}

// VSHUFPS_BCST_Z: Shuffle Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VSHUFPS.BCST.Z imm8 m32 zmm k zmm
// 	VSHUFPS.BCST.Z imm8 m32 xmm k xmm
// 	VSHUFPS.BCST.Z imm8 m32 ymm k ymm
func VSHUFPS_BCST_Z(i, m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{i, m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFPS_BCST_Z: bad operands")
}

// VSHUFPS_Z: Shuffle Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VSHUFPS.Z imm8 m512 zmm k zmm
// 	VSHUFPS.Z imm8 zmm  zmm k zmm
// 	VSHUFPS.Z imm8 m128 xmm k xmm
// 	VSHUFPS.Z imm8 m256 ymm k ymm
// 	VSHUFPS.Z imm8 xmm  xmm k xmm
// 	VSHUFPS.Z imm8 ymm  ymm k ymm
func VSHUFPS_Z(i, mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(i) && operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsIMM8(i) && operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsIMM8(i) && operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsIMM8(i) && operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsIMM8(i) && operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSHUFPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{i, mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSHUFPS_Z: bad operands")
}

// VSQRTPD: Compute Square Roots of Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VSQRTPD m128 xmm
// 	VSQRTPD m256 ymm
// 	VSQRTPD xmm  xmm
// 	VSQRTPD ymm  ymm
// 	VSQRTPD m512 k zmm
// 	VSQRTPD m512 zmm
// 	VSQRTPD zmm  k zmm
// 	VSQRTPD zmm  zmm
// 	VSQRTPD m128 k xmm
// 	VSQRTPD m256 k ymm
// 	VSQRTPD xmm  k xmm
// 	VSQRTPD ymm  k ymm
func VSQRTPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPD: bad operands")
}

// VSQRTPD_BCST: Compute Square Roots of Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VSQRTPD.BCST m64 k zmm
// 	VSQRTPD.BCST m64 zmm
// 	VSQRTPD.BCST m32 k xmm
// 	VSQRTPD.BCST m32 k ymm
// 	VSQRTPD.BCST m32 xmm
// 	VSQRTPD.BCST m32 ymm
func VSQRTPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPD_BCST: bad operands")
}

// VSQRTPD_BCST_Z: Compute Square Roots of Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VSQRTPD.BCST.Z m64 k zmm
// 	VSQRTPD.BCST.Z m32 k xmm
// 	VSQRTPD.BCST.Z m32 k ymm
func VSQRTPD_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPD_BCST_Z: bad operands")
}

// VSQRTPD_RD_SAE: Compute Square Roots of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VSQRTPD.RD_SAE zmm k zmm
// 	VSQRTPD.RD_SAE zmm zmm
func VSQRTPD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPD_RD_SAE: bad operands")
}

// VSQRTPD_RD_SAE_Z: Compute Square Roots of Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSQRTPD.RD_SAE.Z zmm k zmm
func VSQRTPD_RD_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPD_RD_SAE_Z: bad operands")
}

// VSQRTPD_RN_SAE: Compute Square Roots of Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VSQRTPD.RN_SAE zmm k zmm
// 	VSQRTPD.RN_SAE zmm zmm
func VSQRTPD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPD_RN_SAE: bad operands")
}

// VSQRTPD_RN_SAE_Z: Compute Square Roots of Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VSQRTPD.RN_SAE.Z zmm k zmm
func VSQRTPD_RN_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPD_RN_SAE_Z: bad operands")
}

// VSQRTPD_RU_SAE: Compute Square Roots of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VSQRTPD.RU_SAE zmm k zmm
// 	VSQRTPD.RU_SAE zmm zmm
func VSQRTPD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPD_RU_SAE: bad operands")
}

// VSQRTPD_RU_SAE_Z: Compute Square Roots of Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSQRTPD.RU_SAE.Z zmm k zmm
func VSQRTPD_RU_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPD_RU_SAE_Z: bad operands")
}

// VSQRTPD_RZ_SAE: Compute Square Roots of Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VSQRTPD.RZ_SAE zmm k zmm
// 	VSQRTPD.RZ_SAE zmm zmm
func VSQRTPD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPD_RZ_SAE: bad operands")
}

// VSQRTPD_RZ_SAE_Z: Compute Square Roots of Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VSQRTPD.RZ_SAE.Z zmm k zmm
func VSQRTPD_RZ_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPD_RZ_SAE_Z: bad operands")
}

// VSQRTPD_Z: Compute Square Roots of Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VSQRTPD.Z m512 k zmm
// 	VSQRTPD.Z zmm  k zmm
// 	VSQRTPD.Z m128 k xmm
// 	VSQRTPD.Z m256 k ymm
// 	VSQRTPD.Z xmm  k xmm
// 	VSQRTPD.Z ymm  k ymm
func VSQRTPD_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VSQRTPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPD_Z: bad operands")
}

// VSQRTPS: Compute Square Roots of Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VSQRTPS m128 xmm
// 	VSQRTPS m256 ymm
// 	VSQRTPS xmm  xmm
// 	VSQRTPS ymm  ymm
// 	VSQRTPS m512 k zmm
// 	VSQRTPS m512 zmm
// 	VSQRTPS zmm  k zmm
// 	VSQRTPS zmm  zmm
// 	VSQRTPS m128 k xmm
// 	VSQRTPS m256 k ymm
// 	VSQRTPS xmm  k xmm
// 	VSQRTPS ymm  k ymm
func VSQRTPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]),
		len(ops) == 2 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 2 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]),
		len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPS: bad operands")
}

// VSQRTPS_BCST: Compute Square Roots of Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VSQRTPS.BCST m32 k zmm
// 	VSQRTPS.BCST m32 zmm
// 	VSQRTPS.BCST m32 k xmm
// 	VSQRTPS.BCST m32 k ymm
// 	VSQRTPS.BCST m32 xmm
// 	VSQRTPS.BCST m32 ymm
func VSQRTPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsK(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]),
		len(ops) == 2 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPS_BCST: bad operands")
}

// VSQRTPS_BCST_Z: Compute Square Roots of Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VSQRTPS.BCST.Z m32 k zmm
// 	VSQRTPS.BCST.Z m32 k xmm
// 	VSQRTPS.BCST.Z m32 k ymm
func VSQRTPS_BCST_Z(m, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM32(m) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, k, xyz},
			Inputs:   []operand.Op{m, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPS_BCST_Z: bad operands")
}

// VSQRTPS_RD_SAE: Compute Square Roots of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VSQRTPS.RD_SAE zmm k zmm
// 	VSQRTPS.RD_SAE zmm zmm
func VSQRTPS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPS_RD_SAE: bad operands")
}

// VSQRTPS_RD_SAE_Z: Compute Square Roots of Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSQRTPS.RD_SAE.Z zmm k zmm
func VSQRTPS_RD_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPS_RD_SAE_Z: bad operands")
}

// VSQRTPS_RN_SAE: Compute Square Roots of Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VSQRTPS.RN_SAE zmm k zmm
// 	VSQRTPS.RN_SAE zmm zmm
func VSQRTPS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPS_RN_SAE: bad operands")
}

// VSQRTPS_RN_SAE_Z: Compute Square Roots of Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VSQRTPS.RN_SAE.Z zmm k zmm
func VSQRTPS_RN_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPS_RN_SAE_Z: bad operands")
}

// VSQRTPS_RU_SAE: Compute Square Roots of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VSQRTPS.RU_SAE zmm k zmm
// 	VSQRTPS.RU_SAE zmm zmm
func VSQRTPS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPS_RU_SAE: bad operands")
}

// VSQRTPS_RU_SAE_Z: Compute Square Roots of Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSQRTPS.RU_SAE.Z zmm k zmm
func VSQRTPS_RU_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPS_RU_SAE_Z: bad operands")
}

// VSQRTPS_RZ_SAE: Compute Square Roots of Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VSQRTPS.RZ_SAE zmm k zmm
// 	VSQRTPS.RZ_SAE zmm zmm
func VSQRTPS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsK(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 2 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0]},
			Outputs:  []operand.Op{ops[1]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPS_RZ_SAE: bad operands")
}

// VSQRTPS_RZ_SAE_Z: Compute Square Roots of Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VSQRTPS.RZ_SAE.Z zmm k zmm
func VSQRTPS_RZ_SAE_Z(z, k, z1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsK(k) && operand.IsZMM(z1):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, k, z1},
			Inputs:   []operand.Op{z, k},
			Outputs:  []operand.Op{z1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPS_RZ_SAE_Z: bad operands")
}

// VSQRTPS_Z: Compute Square Roots of Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VSQRTPS.Z m512 k zmm
// 	VSQRTPS.Z zmm  k zmm
// 	VSQRTPS.Z m128 k xmm
// 	VSQRTPS.Z m256 k ymm
// 	VSQRTPS.Z xmm  k xmm
// 	VSQRTPS.Z ymm  k ymm
func VSQRTPS_Z(mxyz, k, xyz operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsK(k) && operand.IsZMM(xyz),
		operand.IsZMM(mxyz) && operand.IsK(k) && operand.IsZMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsM256(mxyz) && operand.IsK(k) && operand.IsYMM(xyz),
		operand.IsXMM(mxyz) && operand.IsK(k) && operand.IsXMM(xyz),
		operand.IsYMM(mxyz) && operand.IsK(k) && operand.IsYMM(xyz):
		return &intrep.Instruction{
			Opcode:   "VSQRTPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, k, xyz},
			Inputs:   []operand.Op{mxyz, k},
			Outputs:  []operand.Op{xyz},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTPS_Z: bad operands")
}

// VSQRTSD: Compute Square Root of Scalar Double-Precision Floating-Point Value.
//
// Forms:
//
// 	VSQRTSD m64 xmm xmm
// 	VSQRTSD xmm xmm xmm
// 	VSQRTSD m64 xmm k xmm
// 	VSQRTSD xmm xmm k xmm
func VSQRTSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VSQRTSD: bad operands")
}

// VSQRTSD_RD_SAE: Compute Square Root of Scalar Double-Precision Floating-Point Value (Round Towards Negative Infinity).
//
// Forms:
//
// 	VSQRTSD.RD_SAE xmm xmm k xmm
// 	VSQRTSD.RD_SAE xmm xmm xmm
func VSQRTSD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSD_RD_SAE: bad operands")
}

// VSQRTSD_RD_SAE_Z: Compute Square Root of Scalar Double-Precision Floating-Point Value (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSQRTSD.RD_SAE.Z xmm xmm k xmm
func VSQRTSD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSD_RD_SAE_Z: bad operands")
}

// VSQRTSD_RN_SAE: Compute Square Root of Scalar Double-Precision Floating-Point Value (Round Towards Nearest).
//
// Forms:
//
// 	VSQRTSD.RN_SAE xmm xmm k xmm
// 	VSQRTSD.RN_SAE xmm xmm xmm
func VSQRTSD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSD_RN_SAE: bad operands")
}

// VSQRTSD_RN_SAE_Z: Compute Square Root of Scalar Double-Precision Floating-Point Value (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VSQRTSD.RN_SAE.Z xmm xmm k xmm
func VSQRTSD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSD_RN_SAE_Z: bad operands")
}

// VSQRTSD_RU_SAE: Compute Square Root of Scalar Double-Precision Floating-Point Value (Round Towards Positive Infinity).
//
// Forms:
//
// 	VSQRTSD.RU_SAE xmm xmm k xmm
// 	VSQRTSD.RU_SAE xmm xmm xmm
func VSQRTSD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSD_RU_SAE: bad operands")
}

// VSQRTSD_RU_SAE_Z: Compute Square Root of Scalar Double-Precision Floating-Point Value (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSQRTSD.RU_SAE.Z xmm xmm k xmm
func VSQRTSD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSD_RU_SAE_Z: bad operands")
}

// VSQRTSD_RZ_SAE: Compute Square Root of Scalar Double-Precision Floating-Point Value (Round Towards Zero).
//
// Forms:
//
// 	VSQRTSD.RZ_SAE xmm xmm k xmm
// 	VSQRTSD.RZ_SAE xmm xmm xmm
func VSQRTSD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSD_RZ_SAE: bad operands")
}

// VSQRTSD_RZ_SAE_Z: Compute Square Root of Scalar Double-Precision Floating-Point Value (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VSQRTSD.RZ_SAE.Z xmm xmm k xmm
func VSQRTSD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSD_RZ_SAE_Z: bad operands")
}

// VSQRTSD_Z: Compute Square Root of Scalar Double-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VSQRTSD.Z m64 xmm k xmm
// 	VSQRTSD.Z xmm xmm k xmm
func VSQRTSD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VSQRTSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSD_Z: bad operands")
}

// VSQRTSS: Compute Square Root of Scalar Single-Precision Floating-Point Value.
//
// Forms:
//
// 	VSQRTSS m32 xmm xmm
// 	VSQRTSS xmm xmm xmm
// 	VSQRTSS m32 xmm k xmm
// 	VSQRTSS xmm xmm k xmm
func VSQRTSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VSQRTSS: bad operands")
}

// VSQRTSS_RD_SAE: Compute Square Root of Scalar Single-Precision Floating-Point Value (Round Towards Negative Infinity).
//
// Forms:
//
// 	VSQRTSS.RD_SAE xmm xmm k xmm
// 	VSQRTSS.RD_SAE xmm xmm xmm
func VSQRTSS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSS_RD_SAE: bad operands")
}

// VSQRTSS_RD_SAE_Z: Compute Square Root of Scalar Single-Precision Floating-Point Value (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSQRTSS.RD_SAE.Z xmm xmm k xmm
func VSQRTSS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSS_RD_SAE_Z: bad operands")
}

// VSQRTSS_RN_SAE: Compute Square Root of Scalar Single-Precision Floating-Point Value (Round Towards Nearest).
//
// Forms:
//
// 	VSQRTSS.RN_SAE xmm xmm k xmm
// 	VSQRTSS.RN_SAE xmm xmm xmm
func VSQRTSS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSS_RN_SAE: bad operands")
}

// VSQRTSS_RN_SAE_Z: Compute Square Root of Scalar Single-Precision Floating-Point Value (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VSQRTSS.RN_SAE.Z xmm xmm k xmm
func VSQRTSS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSS_RN_SAE_Z: bad operands")
}

// VSQRTSS_RU_SAE: Compute Square Root of Scalar Single-Precision Floating-Point Value (Round Towards Positive Infinity).
//
// Forms:
//
// 	VSQRTSS.RU_SAE xmm xmm k xmm
// 	VSQRTSS.RU_SAE xmm xmm xmm
func VSQRTSS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSS_RU_SAE: bad operands")
}

// VSQRTSS_RU_SAE_Z: Compute Square Root of Scalar Single-Precision Floating-Point Value (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSQRTSS.RU_SAE.Z xmm xmm k xmm
func VSQRTSS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSS_RU_SAE_Z: bad operands")
}

// VSQRTSS_RZ_SAE: Compute Square Root of Scalar Single-Precision Floating-Point Value (Round Towards Zero).
//
// Forms:
//
// 	VSQRTSS.RZ_SAE xmm xmm k xmm
// 	VSQRTSS.RZ_SAE xmm xmm xmm
func VSQRTSS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSS_RZ_SAE: bad operands")
}

// VSQRTSS_RZ_SAE_Z: Compute Square Root of Scalar Single-Precision Floating-Point Value (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VSQRTSS.RZ_SAE.Z xmm xmm k xmm
func VSQRTSS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSS_RZ_SAE_Z: bad operands")
}

// VSQRTSS_Z: Compute Square Root of Scalar Single-Precision Floating-Point Value (Zeroing Masking).
//
// Forms:
//
// 	VSQRTSS.Z m32 xmm k xmm
// 	VSQRTSS.Z xmm xmm k xmm
func VSQRTSS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VSQRTSS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSQRTSS_Z: bad operands")
}

// VSTMXCSR: Store MXCSR Register State.
//
// Forms:
//
// 	VSTMXCSR m32
func VSTMXCSR(m operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m):
		return &intrep.Instruction{
			Opcode:   "VSTMXCSR",
			Operands: []operand.Op{m},
			Inputs:   []operand.Op{},
			Outputs:  []operand.Op{m},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VSTMXCSR: bad operands")
}

// VSUBPD: Subtract Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VSUBPD m128 xmm xmm
// 	VSUBPD m256 ymm ymm
// 	VSUBPD xmm  xmm xmm
// 	VSUBPD ymm  ymm ymm
// 	VSUBPD m512 zmm k zmm
// 	VSUBPD m512 zmm zmm
// 	VSUBPD zmm  zmm k zmm
// 	VSUBPD zmm  zmm zmm
// 	VSUBPD m128 xmm k xmm
// 	VSUBPD m256 ymm k ymm
// 	VSUBPD xmm  xmm k xmm
// 	VSUBPD ymm  ymm k ymm
func VSUBPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPD: bad operands")
}

// VSUBPD_BCST: Subtract Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VSUBPD.BCST m64 zmm k zmm
// 	VSUBPD.BCST m64 zmm zmm
// 	VSUBPD.BCST m64 xmm k xmm
// 	VSUBPD.BCST m64 xmm xmm
// 	VSUBPD.BCST m64 ymm k ymm
// 	VSUBPD.BCST m64 ymm ymm
func VSUBPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPD_BCST: bad operands")
}

// VSUBPD_BCST_Z: Subtract Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VSUBPD.BCST.Z m64 zmm k zmm
// 	VSUBPD.BCST.Z m64 xmm k xmm
// 	VSUBPD.BCST.Z m64 ymm k ymm
func VSUBPD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPD_BCST_Z: bad operands")
}

// VSUBPD_RD_SAE: Subtract Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VSUBPD.RD_SAE zmm zmm k zmm
// 	VSUBPD.RD_SAE zmm zmm zmm
func VSUBPD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPD_RD_SAE: bad operands")
}

// VSUBPD_RD_SAE_Z: Subtract Packed Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSUBPD.RD_SAE.Z zmm zmm k zmm
func VSUBPD_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPD_RD_SAE_Z: bad operands")
}

// VSUBPD_RN_SAE: Subtract Packed Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VSUBPD.RN_SAE zmm zmm k zmm
// 	VSUBPD.RN_SAE zmm zmm zmm
func VSUBPD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPD_RN_SAE: bad operands")
}

// VSUBPD_RN_SAE_Z: Subtract Packed Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VSUBPD.RN_SAE.Z zmm zmm k zmm
func VSUBPD_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPD_RN_SAE_Z: bad operands")
}

// VSUBPD_RU_SAE: Subtract Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VSUBPD.RU_SAE zmm zmm k zmm
// 	VSUBPD.RU_SAE zmm zmm zmm
func VSUBPD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPD_RU_SAE: bad operands")
}

// VSUBPD_RU_SAE_Z: Subtract Packed Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSUBPD.RU_SAE.Z zmm zmm k zmm
func VSUBPD_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPD_RU_SAE_Z: bad operands")
}

// VSUBPD_RZ_SAE: Subtract Packed Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VSUBPD.RZ_SAE zmm zmm k zmm
// 	VSUBPD.RZ_SAE zmm zmm zmm
func VSUBPD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPD_RZ_SAE: bad operands")
}

// VSUBPD_RZ_SAE_Z: Subtract Packed Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VSUBPD.RZ_SAE.Z zmm zmm k zmm
func VSUBPD_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPD_RZ_SAE_Z: bad operands")
}

// VSUBPD_Z: Subtract Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VSUBPD.Z m512 zmm k zmm
// 	VSUBPD.Z zmm  zmm k zmm
// 	VSUBPD.Z m128 xmm k xmm
// 	VSUBPD.Z m256 ymm k ymm
// 	VSUBPD.Z xmm  xmm k xmm
// 	VSUBPD.Z ymm  ymm k ymm
func VSUBPD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSUBPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPD_Z: bad operands")
}

// VSUBPS: Subtract Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VSUBPS m128 xmm xmm
// 	VSUBPS m256 ymm ymm
// 	VSUBPS xmm  xmm xmm
// 	VSUBPS ymm  ymm ymm
// 	VSUBPS m512 zmm k zmm
// 	VSUBPS m512 zmm zmm
// 	VSUBPS zmm  zmm k zmm
// 	VSUBPS zmm  zmm zmm
// 	VSUBPS m128 xmm k xmm
// 	VSUBPS m256 ymm k ymm
// 	VSUBPS xmm  xmm k xmm
// 	VSUBPS ymm  ymm k ymm
func VSUBPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPS: bad operands")
}

// VSUBPS_BCST: Subtract Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VSUBPS.BCST m32 zmm k zmm
// 	VSUBPS.BCST m32 zmm zmm
// 	VSUBPS.BCST m32 xmm k xmm
// 	VSUBPS.BCST m32 xmm xmm
// 	VSUBPS.BCST m32 ymm k ymm
// 	VSUBPS.BCST m32 ymm ymm
func VSUBPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPS_BCST: bad operands")
}

// VSUBPS_BCST_Z: Subtract Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VSUBPS.BCST.Z m32 zmm k zmm
// 	VSUBPS.BCST.Z m32 xmm k xmm
// 	VSUBPS.BCST.Z m32 ymm k ymm
func VSUBPS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPS_BCST_Z: bad operands")
}

// VSUBPS_RD_SAE: Subtract Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VSUBPS.RD_SAE zmm zmm k zmm
// 	VSUBPS.RD_SAE zmm zmm zmm
func VSUBPS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPS_RD_SAE: bad operands")
}

// VSUBPS_RD_SAE_Z: Subtract Packed Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSUBPS.RD_SAE.Z zmm zmm k zmm
func VSUBPS_RD_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPS_RD_SAE_Z: bad operands")
}

// VSUBPS_RN_SAE: Subtract Packed Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VSUBPS.RN_SAE zmm zmm k zmm
// 	VSUBPS.RN_SAE zmm zmm zmm
func VSUBPS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPS_RN_SAE: bad operands")
}

// VSUBPS_RN_SAE_Z: Subtract Packed Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VSUBPS.RN_SAE.Z zmm zmm k zmm
func VSUBPS_RN_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPS_RN_SAE_Z: bad operands")
}

// VSUBPS_RU_SAE: Subtract Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VSUBPS.RU_SAE zmm zmm k zmm
// 	VSUBPS.RU_SAE zmm zmm zmm
func VSUBPS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPS_RU_SAE: bad operands")
}

// VSUBPS_RU_SAE_Z: Subtract Packed Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSUBPS.RU_SAE.Z zmm zmm k zmm
func VSUBPS_RU_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPS_RU_SAE_Z: bad operands")
}

// VSUBPS_RZ_SAE: Subtract Packed Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VSUBPS.RZ_SAE zmm zmm k zmm
// 	VSUBPS.RZ_SAE zmm zmm zmm
func VSUBPS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPS_RZ_SAE: bad operands")
}

// VSUBPS_RZ_SAE_Z: Subtract Packed Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VSUBPS.RZ_SAE.Z zmm zmm k zmm
func VSUBPS_RZ_SAE_Z(z, z1, k, z2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(z) && operand.IsZMM(z1) && operand.IsK(k) && operand.IsZMM(z2):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{z, z1, k, z2},
			Inputs:   []operand.Op{z, z1, k},
			Outputs:  []operand.Op{z2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPS_RZ_SAE_Z: bad operands")
}

// VSUBPS_Z: Subtract Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VSUBPS.Z m512 zmm k zmm
// 	VSUBPS.Z zmm  zmm k zmm
// 	VSUBPS.Z m128 xmm k xmm
// 	VSUBPS.Z m256 ymm k ymm
// 	VSUBPS.Z xmm  xmm k xmm
// 	VSUBPS.Z ymm  ymm k ymm
func VSUBPS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VSUBPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBPS_Z: bad operands")
}

// VSUBSD: Subtract Scalar Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VSUBSD m64 xmm xmm
// 	VSUBSD xmm xmm xmm
// 	VSUBSD m64 xmm k xmm
// 	VSUBSD xmm xmm k xmm
func VSUBSD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VSUBSD: bad operands")
}

// VSUBSD_RD_SAE: Subtract Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VSUBSD.RD_SAE xmm xmm k xmm
// 	VSUBSD.RD_SAE xmm xmm xmm
func VSUBSD_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSD_RD_SAE: bad operands")
}

// VSUBSD_RD_SAE_Z: Subtract Scalar Double-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSUBSD.RD_SAE.Z xmm xmm k xmm
func VSUBSD_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSD_RD_SAE_Z: bad operands")
}

// VSUBSD_RN_SAE: Subtract Scalar Double-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VSUBSD.RN_SAE xmm xmm k xmm
// 	VSUBSD.RN_SAE xmm xmm xmm
func VSUBSD_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSD_RN_SAE: bad operands")
}

// VSUBSD_RN_SAE_Z: Subtract Scalar Double-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VSUBSD.RN_SAE.Z xmm xmm k xmm
func VSUBSD_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSD_RN_SAE_Z: bad operands")
}

// VSUBSD_RU_SAE: Subtract Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VSUBSD.RU_SAE xmm xmm k xmm
// 	VSUBSD.RU_SAE xmm xmm xmm
func VSUBSD_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSD_RU_SAE: bad operands")
}

// VSUBSD_RU_SAE_Z: Subtract Scalar Double-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSUBSD.RU_SAE.Z xmm xmm k xmm
func VSUBSD_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSD_RU_SAE_Z: bad operands")
}

// VSUBSD_RZ_SAE: Subtract Scalar Double-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VSUBSD.RZ_SAE xmm xmm k xmm
// 	VSUBSD.RZ_SAE xmm xmm xmm
func VSUBSD_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSD_RZ_SAE: bad operands")
}

// VSUBSD_RZ_SAE_Z: Subtract Scalar Double-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VSUBSD.RZ_SAE.Z xmm xmm k xmm
func VSUBSD_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSD_RZ_SAE_Z: bad operands")
}

// VSUBSD_Z: Subtract Scalar Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VSUBSD.Z m64 xmm k xmm
// 	VSUBSD.Z xmm xmm k xmm
func VSUBSD_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VSUBSD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSD_Z: bad operands")
}

// VSUBSS: Subtract Scalar Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VSUBSS m32 xmm xmm
// 	VSUBSS xmm xmm xmm
// 	VSUBSS m32 xmm k xmm
// 	VSUBSS xmm xmm k xmm
func VSUBSS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VSUBSS: bad operands")
}

// VSUBSS_RD_SAE: Subtract Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity).
//
// Forms:
//
// 	VSUBSS.RD_SAE xmm xmm k xmm
// 	VSUBSS.RD_SAE xmm xmm xmm
func VSUBSS_RD_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Suffixes: []string{"RD_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSS_RD_SAE: bad operands")
}

// VSUBSS_RD_SAE_Z: Subtract Scalar Single-Precision Floating-Point Values (Round Towards Negative Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSUBSS.RD_SAE.Z xmm xmm k xmm
func VSUBSS_RD_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Suffixes: []string{"RD_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSS_RD_SAE_Z: bad operands")
}

// VSUBSS_RN_SAE: Subtract Scalar Single-Precision Floating-Point Values (Round Towards Nearest).
//
// Forms:
//
// 	VSUBSS.RN_SAE xmm xmm k xmm
// 	VSUBSS.RN_SAE xmm xmm xmm
func VSUBSS_RN_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Suffixes: []string{"RN_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSS_RN_SAE: bad operands")
}

// VSUBSS_RN_SAE_Z: Subtract Scalar Single-Precision Floating-Point Values (Round Towards Nearest, Zeroing Masking).
//
// Forms:
//
// 	VSUBSS.RN_SAE.Z xmm xmm k xmm
func VSUBSS_RN_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Suffixes: []string{"RN_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSS_RN_SAE_Z: bad operands")
}

// VSUBSS_RU_SAE: Subtract Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity).
//
// Forms:
//
// 	VSUBSS.RU_SAE xmm xmm k xmm
// 	VSUBSS.RU_SAE xmm xmm xmm
func VSUBSS_RU_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Suffixes: []string{"RU_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSS_RU_SAE: bad operands")
}

// VSUBSS_RU_SAE_Z: Subtract Scalar Single-Precision Floating-Point Values (Round Towards Positive Infinity, Zeroing Masking).
//
// Forms:
//
// 	VSUBSS.RU_SAE.Z xmm xmm k xmm
func VSUBSS_RU_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Suffixes: []string{"RU_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSS_RU_SAE_Z: bad operands")
}

// VSUBSS_RZ_SAE: Subtract Scalar Single-Precision Floating-Point Values (Round Towards Zero).
//
// Forms:
//
// 	VSUBSS.RZ_SAE xmm xmm k xmm
// 	VSUBSS.RZ_SAE xmm xmm xmm
func VSUBSS_RZ_SAE(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Suffixes: []string{"RZ_SAE"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSS_RZ_SAE: bad operands")
}

// VSUBSS_RZ_SAE_Z: Subtract Scalar Single-Precision Floating-Point Values (Round Towards Zero, Zeroing Masking).
//
// Forms:
//
// 	VSUBSS.RZ_SAE.Z xmm xmm k xmm
func VSUBSS_RZ_SAE_Z(x, x1, k, x2 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1) && operand.IsK(k) && operand.IsXMM(x2):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Suffixes: []string{"RZ_SAE", "Z"},
			Operands: []operand.Op{x, x1, k, x2},
			Inputs:   []operand.Op{x, x1, k},
			Outputs:  []operand.Op{x2},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSS_RZ_SAE_Z: bad operands")
}

// VSUBSS_Z: Subtract Scalar Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VSUBSS.Z m32 xmm k xmm
// 	VSUBSS.Z xmm xmm k xmm
func VSUBSS_Z(mx, x, k, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1),
		operand.IsXMM(mx) && operand.IsXMM(x) && operand.IsK(k) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VSUBSS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mx, x, k, x1},
			Inputs:   []operand.Op{mx, x, k},
			Outputs:  []operand.Op{x1},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VSUBSS_Z: bad operands")
}

// VTESTPD: Packed Double-Precision Floating-Point Bit Test.
//
// Forms:
//
// 	VTESTPD m128 xmm
// 	VTESTPD m256 ymm
// 	VTESTPD xmm  xmm
// 	VTESTPD ymm  ymm
func VTESTPD(mxy, xy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy),
		operand.IsM256(mxy) && operand.IsYMM(xy),
		operand.IsXMM(mxy) && operand.IsXMM(xy),
		operand.IsYMM(mxy) && operand.IsYMM(xy):
		return &intrep.Instruction{
			Opcode:   "VTESTPD",
			Operands: []operand.Op{mxy, xy},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VTESTPD: bad operands")
}

// VTESTPS: Packed Single-Precision Floating-Point Bit Test.
//
// Forms:
//
// 	VTESTPS m128 xmm
// 	VTESTPS m256 ymm
// 	VTESTPS xmm  xmm
// 	VTESTPS ymm  ymm
func VTESTPS(mxy, xy operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM128(mxy) && operand.IsXMM(xy),
		operand.IsM256(mxy) && operand.IsYMM(xy),
		operand.IsXMM(mxy) && operand.IsXMM(xy),
		operand.IsYMM(mxy) && operand.IsYMM(xy):
		return &intrep.Instruction{
			Opcode:   "VTESTPS",
			Operands: []operand.Op{mxy, xy},
			Inputs:   []operand.Op{mxy, xy},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VTESTPS: bad operands")
}

// VUCOMISD: Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS.
//
// Forms:
//
// 	VUCOMISD m64 xmm
// 	VUCOMISD xmm xmm
func VUCOMISD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VUCOMISD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VUCOMISD: bad operands")
}

// VUCOMISD_SAE: Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS (Suppress All Exceptions).
//
// Forms:
//
// 	VUCOMISD.SAE xmm xmm
func VUCOMISD_SAE(x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VUCOMISD",
			Suffixes: []string{"SAE"},
			Operands: []operand.Op{x, x1},
			Inputs:   []operand.Op{x, x1},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VUCOMISD_SAE: bad operands")
}

// VUCOMISS: Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS.
//
// Forms:
//
// 	VUCOMISS m32 xmm
// 	VUCOMISS xmm xmm
func VUCOMISS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(mx) && operand.IsXMM(x),
		operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "VUCOMISS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX"},
		}, nil
	}
	return nil, errors.New("VUCOMISS: bad operands")
}

// VUCOMISS_SAE: Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS (Suppress All Exceptions).
//
// Forms:
//
// 	VUCOMISS.SAE xmm xmm
func VUCOMISS_SAE(x, x1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(x) && operand.IsXMM(x1):
		return &intrep.Instruction{
			Opcode:   "VUCOMISS",
			Suffixes: []string{"SAE"},
			Operands: []operand.Op{x, x1},
			Inputs:   []operand.Op{x, x1},
			Outputs:  []operand.Op{},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VUCOMISS_SAE: bad operands")
}

// VUNPCKHPD: Unpack and Interleave High Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VUNPCKHPD m128 xmm xmm
// 	VUNPCKHPD m256 ymm ymm
// 	VUNPCKHPD xmm  xmm xmm
// 	VUNPCKHPD ymm  ymm ymm
// 	VUNPCKHPD m512 zmm k zmm
// 	VUNPCKHPD m512 zmm zmm
// 	VUNPCKHPD zmm  zmm k zmm
// 	VUNPCKHPD zmm  zmm zmm
// 	VUNPCKHPD m128 xmm k xmm
// 	VUNPCKHPD m256 ymm k ymm
// 	VUNPCKHPD xmm  xmm k xmm
// 	VUNPCKHPD ymm  ymm k ymm
func VUNPCKHPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKHPD: bad operands")
}

// VUNPCKHPD_BCST: Unpack and Interleave High Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VUNPCKHPD.BCST m64 zmm k zmm
// 	VUNPCKHPD.BCST m64 zmm zmm
// 	VUNPCKHPD.BCST m64 xmm k xmm
// 	VUNPCKHPD.BCST m64 xmm xmm
// 	VUNPCKHPD.BCST m64 ymm k ymm
// 	VUNPCKHPD.BCST m64 ymm ymm
func VUNPCKHPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKHPD_BCST: bad operands")
}

// VUNPCKHPD_BCST_Z: Unpack and Interleave High Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VUNPCKHPD.BCST.Z m64 zmm k zmm
// 	VUNPCKHPD.BCST.Z m64 xmm k xmm
// 	VUNPCKHPD.BCST.Z m64 ymm k ymm
func VUNPCKHPD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKHPD_BCST_Z: bad operands")
}

// VUNPCKHPD_Z: Unpack and Interleave High Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VUNPCKHPD.Z m512 zmm k zmm
// 	VUNPCKHPD.Z zmm  zmm k zmm
// 	VUNPCKHPD.Z m128 xmm k xmm
// 	VUNPCKHPD.Z m256 ymm k ymm
// 	VUNPCKHPD.Z xmm  xmm k xmm
// 	VUNPCKHPD.Z ymm  ymm k ymm
func VUNPCKHPD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKHPD_Z: bad operands")
}

// VUNPCKHPS: Unpack and Interleave High Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VUNPCKHPS m128 xmm xmm
// 	VUNPCKHPS m256 ymm ymm
// 	VUNPCKHPS xmm  xmm xmm
// 	VUNPCKHPS ymm  ymm ymm
// 	VUNPCKHPS m512 zmm k zmm
// 	VUNPCKHPS m512 zmm zmm
// 	VUNPCKHPS zmm  zmm k zmm
// 	VUNPCKHPS zmm  zmm zmm
// 	VUNPCKHPS m128 xmm k xmm
// 	VUNPCKHPS m256 ymm k ymm
// 	VUNPCKHPS xmm  xmm k xmm
// 	VUNPCKHPS ymm  ymm k ymm
func VUNPCKHPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKHPS: bad operands")
}

// VUNPCKHPS_BCST: Unpack and Interleave High Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VUNPCKHPS.BCST m32 zmm k zmm
// 	VUNPCKHPS.BCST m32 zmm zmm
// 	VUNPCKHPS.BCST m32 xmm k xmm
// 	VUNPCKHPS.BCST m32 xmm xmm
// 	VUNPCKHPS.BCST m32 ymm k ymm
// 	VUNPCKHPS.BCST m32 ymm ymm
func VUNPCKHPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKHPS_BCST: bad operands")
}

// VUNPCKHPS_BCST_Z: Unpack and Interleave High Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VUNPCKHPS.BCST.Z m32 zmm k zmm
// 	VUNPCKHPS.BCST.Z m32 xmm k xmm
// 	VUNPCKHPS.BCST.Z m32 ymm k ymm
func VUNPCKHPS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKHPS_BCST_Z: bad operands")
}

// VUNPCKHPS_Z: Unpack and Interleave High Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VUNPCKHPS.Z m512 zmm k zmm
// 	VUNPCKHPS.Z zmm  zmm k zmm
// 	VUNPCKHPS.Z m128 xmm k xmm
// 	VUNPCKHPS.Z m256 ymm k ymm
// 	VUNPCKHPS.Z xmm  xmm k xmm
// 	VUNPCKHPS.Z ymm  ymm k ymm
func VUNPCKHPS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKHPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKHPS_Z: bad operands")
}

// VUNPCKLPD: Unpack and Interleave Low Packed Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VUNPCKLPD m128 xmm xmm
// 	VUNPCKLPD m256 ymm ymm
// 	VUNPCKLPD xmm  xmm xmm
// 	VUNPCKLPD ymm  ymm ymm
// 	VUNPCKLPD m512 zmm k zmm
// 	VUNPCKLPD m512 zmm zmm
// 	VUNPCKLPD zmm  zmm k zmm
// 	VUNPCKLPD zmm  zmm zmm
// 	VUNPCKLPD m128 xmm k xmm
// 	VUNPCKLPD m256 ymm k ymm
// 	VUNPCKLPD xmm  xmm k xmm
// 	VUNPCKLPD ymm  ymm k ymm
func VUNPCKLPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKLPD: bad operands")
}

// VUNPCKLPD_BCST: Unpack and Interleave Low Packed Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VUNPCKLPD.BCST m64 zmm k zmm
// 	VUNPCKLPD.BCST m64 zmm zmm
// 	VUNPCKLPD.BCST m64 xmm k xmm
// 	VUNPCKLPD.BCST m64 xmm xmm
// 	VUNPCKLPD.BCST m64 ymm k ymm
// 	VUNPCKLPD.BCST m64 ymm ymm
func VUNPCKLPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKLPD_BCST: bad operands")
}

// VUNPCKLPD_BCST_Z: Unpack and Interleave Low Packed Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VUNPCKLPD.BCST.Z m64 zmm k zmm
// 	VUNPCKLPD.BCST.Z m64 xmm k xmm
// 	VUNPCKLPD.BCST.Z m64 ymm k ymm
func VUNPCKLPD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKLPD_BCST_Z: bad operands")
}

// VUNPCKLPD_Z: Unpack and Interleave Low Packed Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VUNPCKLPD.Z m512 zmm k zmm
// 	VUNPCKLPD.Z zmm  zmm k zmm
// 	VUNPCKLPD.Z m128 xmm k xmm
// 	VUNPCKLPD.Z m256 ymm k ymm
// 	VUNPCKLPD.Z xmm  xmm k xmm
// 	VUNPCKLPD.Z ymm  ymm k ymm
func VUNPCKLPD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKLPD_Z: bad operands")
}

// VUNPCKLPS: Unpack and Interleave Low Packed Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VUNPCKLPS m128 xmm xmm
// 	VUNPCKLPS m256 ymm ymm
// 	VUNPCKLPS xmm  xmm xmm
// 	VUNPCKLPS ymm  ymm ymm
// 	VUNPCKLPS m512 zmm k zmm
// 	VUNPCKLPS m512 zmm zmm
// 	VUNPCKLPS zmm  zmm k zmm
// 	VUNPCKLPS zmm  zmm zmm
// 	VUNPCKLPS m128 xmm k xmm
// 	VUNPCKLPS m256 ymm k ymm
// 	VUNPCKLPS xmm  xmm k xmm
// 	VUNPCKLPS ymm  ymm k ymm
func VUNPCKLPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]),
		len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]),
		len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]),
		len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]),
		len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKLPS: bad operands")
}

// VUNPCKLPS_BCST: Unpack and Interleave Low Packed Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VUNPCKLPS.BCST m32 zmm k zmm
// 	VUNPCKLPS.BCST m32 zmm zmm
// 	VUNPCKLPS.BCST m32 xmm k xmm
// 	VUNPCKLPS.BCST m32 xmm xmm
// 	VUNPCKLPS.BCST m32 ymm k ymm
// 	VUNPCKLPS.BCST m32 ymm ymm
func VUNPCKLPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512F"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKLPS_BCST: bad operands")
}

// VUNPCKLPS_BCST_Z: Unpack and Interleave Low Packed Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VUNPCKLPS.BCST.Z m32 zmm k zmm
// 	VUNPCKLPS.BCST.Z m32 xmm k xmm
// 	VUNPCKLPS.BCST.Z m32 ymm k ymm
func VUNPCKLPS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKLPS_BCST_Z: bad operands")
}

// VUNPCKLPS_Z: Unpack and Interleave Low Packed Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VUNPCKLPS.Z m512 zmm k zmm
// 	VUNPCKLPS.Z zmm  zmm k zmm
// 	VUNPCKLPS.Z m128 xmm k xmm
// 	VUNPCKLPS.Z m256 ymm k ymm
// 	VUNPCKLPS.Z xmm  xmm k xmm
// 	VUNPCKLPS.Z ymm  ymm k ymm
func VUNPCKLPS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1),
		operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512F"},
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1),
		operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VUNPCKLPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512F"},
		}, nil
	}
	return nil, errors.New("VUNPCKLPS_Z: bad operands")
}

// VXORPD: Bitwise Logical XOR for Double-Precision Floating-Point Values.
//
// Forms:
//
// 	VXORPD m128 xmm xmm
// 	VXORPD m256 ymm ymm
// 	VXORPD xmm  xmm xmm
// 	VXORPD ymm  ymm ymm
// 	VXORPD m512 zmm k zmm
// 	VXORPD m512 zmm zmm
// 	VXORPD zmm  zmm k zmm
// 	VXORPD zmm  zmm zmm
// 	VXORPD m128 xmm k xmm
// 	VXORPD m256 ymm k ymm
// 	VXORPD xmm  xmm k xmm
// 	VXORPD ymm  ymm k ymm
func VXORPD(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VXORPD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VXORPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VXORPD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VXORPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VXORPD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VXORPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VXORPD",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VXORPD",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VXORPD: bad operands")
}

// VXORPD_BCST: Bitwise Logical XOR for Double-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VXORPD.BCST m64 zmm k zmm
// 	VXORPD.BCST m64 zmm zmm
// 	VXORPD.BCST m64 xmm k xmm
// 	VXORPD.BCST m64 xmm xmm
// 	VXORPD.BCST m64 ymm k ymm
// 	VXORPD.BCST m64 ymm ymm
func VXORPD_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VXORPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VXORPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VXORPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM64(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VXORPD",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VXORPD_BCST: bad operands")
}

// VXORPD_BCST_Z: Bitwise Logical XOR for Double-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VXORPD.BCST.Z m64 zmm k zmm
// 	VXORPD.BCST.Z m64 xmm k xmm
// 	VXORPD.BCST.Z m64 ymm k ymm
func VXORPD_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VXORPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM64(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM64(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VXORPD",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VXORPD_BCST_Z: bad operands")
}

// VXORPD_Z: Bitwise Logical XOR for Double-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VXORPD.Z m512 zmm k zmm
// 	VXORPD.Z zmm  zmm k zmm
// 	VXORPD.Z m128 xmm k xmm
// 	VXORPD.Z m256 ymm k ymm
// 	VXORPD.Z xmm  xmm k xmm
// 	VXORPD.Z ymm  ymm k ymm
func VXORPD_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VXORPD",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VXORPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VXORPD",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512VL", "AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VXORPD",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VXORPD_Z: bad operands")
}

// VXORPS: Bitwise Logical XOR for Single-Precision Floating-Point Values.
//
// Forms:
//
// 	VXORPS m128 xmm xmm
// 	VXORPS m256 ymm ymm
// 	VXORPS xmm  xmm xmm
// 	VXORPS ymm  ymm ymm
// 	VXORPS m512 zmm k zmm
// 	VXORPS m512 zmm zmm
// 	VXORPS zmm  zmm k zmm
// 	VXORPS zmm  zmm zmm
// 	VXORPS m128 xmm k xmm
// 	VXORPS m256 ymm k ymm
// 	VXORPS xmm  xmm k xmm
// 	VXORPS ymm  ymm k ymm
func VXORPS(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VXORPS",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VXORPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:           "VXORPS",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:          []operand.Op{ops[3]},
			ISA:              []string{"AVX512VL", "AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 4 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VXORPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsXMM(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsYMM(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VXORPS",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM128(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM256(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VXORPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX"},
		}, nil
	case len(ops) == 3 && operand.IsZMM(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:           "VXORPS",
			Operands:         ops,
			Inputs:           []operand.Op{ops[0], ops[1]},
			Outputs:          []operand.Op{ops[2]},
			ISA:              []string{"AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case len(ops) == 3 && operand.IsM512(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VXORPS",
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VXORPS: bad operands")
}

// VXORPS_BCST: Bitwise Logical XOR for Single-Precision Floating-Point Values (Broadcast).
//
// Forms:
//
// 	VXORPS.BCST m32 zmm k zmm
// 	VXORPS.BCST m32 zmm zmm
// 	VXORPS.BCST m32 xmm k xmm
// 	VXORPS.BCST m32 xmm xmm
// 	VXORPS.BCST m32 ymm k ymm
// 	VXORPS.BCST m32 ymm ymm
func VXORPS_BCST(ops ...operand.Op) (*intrep.Instruction, error) {
	switch {
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsK(ops[2]) && operand.IsZMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VXORPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsK(ops[2]) && operand.IsXMM(ops[3]),
		len(ops) == 4 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsK(ops[2]) && operand.IsYMM(ops[3]):
		return &intrep.Instruction{
			Opcode:   "VXORPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1], ops[2], ops[3]},
			Outputs:  []operand.Op{ops[3]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsZMM(ops[1]) && operand.IsZMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VXORPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsXMM(ops[1]) && operand.IsXMM(ops[2]),
		len(ops) == 3 && operand.IsM32(ops[0]) && operand.IsYMM(ops[1]) && operand.IsYMM(ops[2]):
		return &intrep.Instruction{
			Opcode:   "VXORPS",
			Suffixes: []string{"BCST"},
			Operands: ops,
			Inputs:   []operand.Op{ops[0], ops[1]},
			Outputs:  []operand.Op{ops[2]},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VXORPS_BCST: bad operands")
}

// VXORPS_BCST_Z: Bitwise Logical XOR for Single-Precision Floating-Point Values (Broadcast, Zeroing Masking).
//
// Forms:
//
// 	VXORPS.BCST.Z m32 zmm k zmm
// 	VXORPS.BCST.Z m32 xmm k xmm
// 	VXORPS.BCST.Z m32 ymm k ymm
func VXORPS_BCST_Z(m, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM32(m) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VXORPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsM32(m) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM32(m) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VXORPS",
			Suffixes: []string{"BCST", "Z"},
			Operands: []operand.Op{m, xyz, k, xyz1},
			Inputs:   []operand.Op{m, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VXORPS_BCST_Z: bad operands")
}

// VXORPS_Z: Bitwise Logical XOR for Single-Precision Floating-Point Values (Zeroing Masking).
//
// Forms:
//
// 	VXORPS.Z m512 zmm k zmm
// 	VXORPS.Z zmm  zmm k zmm
// 	VXORPS.Z m128 xmm k xmm
// 	VXORPS.Z m256 ymm k ymm
// 	VXORPS.Z xmm  xmm k xmm
// 	VXORPS.Z ymm  ymm k ymm
func VXORPS_Z(mxyz, xyz, k, xyz1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsZMM(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VXORPS",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case operand.IsM512(mxyz) && operand.IsZMM(xyz) && operand.IsK(k) && operand.IsZMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VXORPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512DQ"},
		}, nil
	case operand.IsXMM(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsYMM(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:           "VXORPS",
			Suffixes:         []string{"Z"},
			Operands:         []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:           []operand.Op{mxyz, xyz, k},
			Outputs:          []operand.Op{xyz1},
			ISA:              []string{"AVX512VL", "AVX512DQ"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mxyz) && operand.IsXMM(xyz) && operand.IsK(k) && operand.IsXMM(xyz1),
		operand.IsM256(mxyz) && operand.IsYMM(xyz) && operand.IsK(k) && operand.IsYMM(xyz1):
		return &intrep.Instruction{
			Opcode:   "VXORPS",
			Suffixes: []string{"Z"},
			Operands: []operand.Op{mxyz, xyz, k, xyz1},
			Inputs:   []operand.Op{mxyz, xyz, k},
			Outputs:  []operand.Op{xyz1},
			ISA:      []string{"AVX512VL", "AVX512DQ"},
		}, nil
	}
	return nil, errors.New("VXORPS_Z: bad operands")
}

// VZEROALL: Zero All YMM Registers.
//
// Forms:
//
// 	VZEROALL
func VZEROALL() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "VZEROALL",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{},
		ISA:      []string{"AVX"},
	}, nil
}

// VZEROUPPER: Zero Upper Bits of YMM Registers.
//
// Forms:
//
// 	VZEROUPPER
func VZEROUPPER() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "VZEROUPPER",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{},
		Outputs:  []operand.Op{},
		ISA:      []string{"AVX"},
	}, nil
}

// XADDB: Exchange and Add.
//
// Forms:
//
// 	XADDB r8 m8
// 	XADDB r8 r8
func XADDB(r, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR8(r) && operand.IsM8(mr),
		operand.IsR8(r) && operand.IsR8(mr):
		return &intrep.Instruction{
			Opcode:   "XADDB",
			Operands: []operand.Op{r, mr},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{r, mr},
		}, nil
	}
	return nil, errors.New("XADDB: bad operands")
}

// XADDL: Exchange and Add.
//
// Forms:
//
// 	XADDL r32 m32
// 	XADDL r32 r32
func XADDL(r, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR32(r) && operand.IsM32(mr),
		operand.IsR32(r) && operand.IsR32(mr):
		return &intrep.Instruction{
			Opcode:   "XADDL",
			Operands: []operand.Op{r, mr},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{r, mr},
		}, nil
	}
	return nil, errors.New("XADDL: bad operands")
}

// XADDQ: Exchange and Add.
//
// Forms:
//
// 	XADDQ r64 m64
// 	XADDQ r64 r64
func XADDQ(r, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(r) && operand.IsM64(mr),
		operand.IsR64(r) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "XADDQ",
			Operands: []operand.Op{r, mr},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{r, mr},
		}, nil
	}
	return nil, errors.New("XADDQ: bad operands")
}

// XADDW: Exchange and Add.
//
// Forms:
//
// 	XADDW r16 m16
// 	XADDW r16 r16
func XADDW(r, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR16(r) && operand.IsM16(mr),
		operand.IsR16(r) && operand.IsR16(mr):
		return &intrep.Instruction{
			Opcode:   "XADDW",
			Operands: []operand.Op{r, mr},
			Inputs:   []operand.Op{r, mr},
			Outputs:  []operand.Op{r, mr},
		}, nil
	}
	return nil, errors.New("XADDW: bad operands")
}

// XCHGB: Exchange Register/Memory with Register.
//
// Forms:
//
// 	XCHGB m8 r8
// 	XCHGB r8 m8
// 	XCHGB r8 r8
func XCHGB(mr, mr1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM8(mr) && operand.IsR8(mr1),
		operand.IsR8(mr) && operand.IsM8(mr1),
		operand.IsR8(mr) && operand.IsR8(mr1):
		return &intrep.Instruction{
			Opcode:   "XCHGB",
			Operands: []operand.Op{mr, mr1},
			Inputs:   []operand.Op{mr, mr1},
			Outputs:  []operand.Op{mr, mr1},
		}, nil
	}
	return nil, errors.New("XCHGB: bad operands")
}

// XCHGL: Exchange Register/Memory with Register.
//
// Forms:
//
// 	XCHGL eax r32
// 	XCHGL m32 r32
// 	XCHGL r32 eax
// 	XCHGL r32 m32
// 	XCHGL r32 r32
func XCHGL(emr, emr1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsEAX(emr) && operand.IsR32(emr1),
		operand.IsM32(emr) && operand.IsR32(emr1),
		operand.IsR32(emr) && operand.IsEAX(emr1),
		operand.IsR32(emr) && operand.IsM32(emr1),
		operand.IsR32(emr) && operand.IsR32(emr1):
		return &intrep.Instruction{
			Opcode:   "XCHGL",
			Operands: []operand.Op{emr, emr1},
			Inputs:   []operand.Op{emr, emr1},
			Outputs:  []operand.Op{emr, emr1},
		}, nil
	}
	return nil, errors.New("XCHGL: bad operands")
}

// XCHGQ: Exchange Register/Memory with Register.
//
// Forms:
//
// 	XCHGQ m64 r64
// 	XCHGQ r64 m64
// 	XCHGQ r64 r64
// 	XCHGQ r64 rax
// 	XCHGQ rax r64
func XCHGQ(mr, mr1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsM64(mr) && operand.IsR64(mr1),
		operand.IsR64(mr) && operand.IsM64(mr1),
		operand.IsR64(mr) && operand.IsR64(mr1),
		operand.IsR64(mr) && operand.IsRAX(mr1),
		operand.IsRAX(mr) && operand.IsR64(mr1):
		return &intrep.Instruction{
			Opcode:   "XCHGQ",
			Operands: []operand.Op{mr, mr1},
			Inputs:   []operand.Op{mr, mr1},
			Outputs:  []operand.Op{mr, mr1},
		}, nil
	}
	return nil, errors.New("XCHGQ: bad operands")
}

// XCHGW: Exchange Register/Memory with Register.
//
// Forms:
//
// 	XCHGW ax  r16
// 	XCHGW m16 r16
// 	XCHGW r16 ax
// 	XCHGW r16 m16
// 	XCHGW r16 r16
func XCHGW(amr, amr1 operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsAX(amr) && operand.IsR16(amr1),
		operand.IsM16(amr) && operand.IsR16(amr1),
		operand.IsR16(amr) && operand.IsAX(amr1),
		operand.IsR16(amr) && operand.IsM16(amr1),
		operand.IsR16(amr) && operand.IsR16(amr1):
		return &intrep.Instruction{
			Opcode:   "XCHGW",
			Operands: []operand.Op{amr, amr1},
			Inputs:   []operand.Op{amr, amr1},
			Outputs:  []operand.Op{amr, amr1},
		}, nil
	}
	return nil, errors.New("XCHGW: bad operands")
}

// XGETBV: Get Value of Extended Control Register.
//
// Forms:
//
// 	XGETBV
func XGETBV() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "XGETBV",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{reg.ECX},
		Outputs:  []operand.Op{reg.EAX, reg.EDX},
	}, nil
}

// XLAT: Table Look-up Translation.
//
// Forms:
//
// 	XLAT
func XLAT() (*intrep.Instruction, error) {
	return &intrep.Instruction{
		Opcode:   "XLAT",
		Operands: []operand.Op{},
		Inputs:   []operand.Op{reg.AL, reg.EBX},
		Outputs:  []operand.Op{reg.AL},
	}, nil
}

// XORB: Logical Exclusive OR.
//
// Forms:
//
// 	XORB imm8 al
// 	XORB imm8 m8
// 	XORB imm8 r8
// 	XORB m8   r8
// 	XORB r8   m8
// 	XORB r8   r8
func XORB(imr, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM8(imr) && operand.IsAL(amr),
		operand.IsIMM8(imr) && operand.IsM8(amr),
		operand.IsIMM8(imr) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:   "XORB",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{amr},
		}, nil
	case operand.IsR8(imr) && operand.IsR8(amr):
		return &intrep.Instruction{
			Opcode:           "XORB",
			Operands:         []operand.Op{imr, amr},
			Inputs:           []operand.Op{imr, amr},
			Outputs:          []operand.Op{amr},
			CancellingInputs: true,
		}, nil
	case operand.IsM8(imr) && operand.IsR8(amr),
		operand.IsR8(imr) && operand.IsM8(amr):
		return &intrep.Instruction{
			Opcode:   "XORB",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{imr, amr},
			Outputs:  []operand.Op{amr},
		}, nil
	}
	return nil, errors.New("XORB: bad operands")
}

// XORL: Logical Exclusive OR.
//
// Forms:
//
// 	XORL imm32 eax
// 	XORL imm32 m32
// 	XORL imm32 r32
// 	XORL imm8  m32
// 	XORL imm8  r32
// 	XORL m32   r32
// 	XORL r32   m32
// 	XORL r32   r32
func XORL(imr, emr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM32(imr) && operand.IsEAX(emr),
		operand.IsIMM32(imr) && operand.IsM32(emr),
		operand.IsIMM32(imr) && operand.IsR32(emr),
		operand.IsIMM8(imr) && operand.IsM32(emr),
		operand.IsIMM8(imr) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:   "XORL",
			Operands: []operand.Op{imr, emr},
			Inputs:   []operand.Op{emr},
			Outputs:  []operand.Op{emr},
		}, nil
	case operand.IsR32(imr) && operand.IsR32(emr):
		return &intrep.Instruction{
			Opcode:           "XORL",
			Operands:         []operand.Op{imr, emr},
			Inputs:           []operand.Op{imr, emr},
			Outputs:          []operand.Op{emr},
			CancellingInputs: true,
		}, nil
	case operand.IsM32(imr) && operand.IsR32(emr),
		operand.IsR32(imr) && operand.IsM32(emr):
		return &intrep.Instruction{
			Opcode:   "XORL",
			Operands: []operand.Op{imr, emr},
			Inputs:   []operand.Op{imr, emr},
			Outputs:  []operand.Op{emr},
		}, nil
	}
	return nil, errors.New("XORL: bad operands")
}

// XORPD: Bitwise Logical XOR for Double-Precision Floating-Point Values.
//
// Forms:
//
// 	XORPD m128 xmm
// 	XORPD xmm  xmm
func XORPD(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "XORPD",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE2"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "XORPD",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE2"},
		}, nil
	}
	return nil, errors.New("XORPD: bad operands")
}

// XORPS: Bitwise Logical XOR for Single-Precision Floating-Point Values.
//
// Forms:
//
// 	XORPS m128 xmm
// 	XORPS xmm  xmm
func XORPS(mx, x operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsXMM(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:           "XORPS",
			Operands:         []operand.Op{mx, x},
			Inputs:           []operand.Op{mx, x},
			Outputs:          []operand.Op{x},
			ISA:              []string{"SSE"},
			CancellingInputs: true,
		}, nil
	case operand.IsM128(mx) && operand.IsXMM(x):
		return &intrep.Instruction{
			Opcode:   "XORPS",
			Operands: []operand.Op{mx, x},
			Inputs:   []operand.Op{mx, x},
			Outputs:  []operand.Op{x},
			ISA:      []string{"SSE"},
		}, nil
	}
	return nil, errors.New("XORPS: bad operands")
}

// XORQ: Logical Exclusive OR.
//
// Forms:
//
// 	XORQ imm32 m64
// 	XORQ imm32 r64
// 	XORQ imm32 rax
// 	XORQ imm8  m64
// 	XORQ imm8  r64
// 	XORQ m64   r64
// 	XORQ r64   m64
// 	XORQ r64   r64
func XORQ(imr, mr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsR64(imr) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:           "XORQ",
			Operands:         []operand.Op{imr, mr},
			Inputs:           []operand.Op{imr, mr},
			Outputs:          []operand.Op{mr},
			CancellingInputs: true,
		}, nil
	case operand.IsM64(imr) && operand.IsR64(mr),
		operand.IsR64(imr) && operand.IsM64(mr):
		return &intrep.Instruction{
			Opcode:   "XORQ",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{imr, mr},
			Outputs:  []operand.Op{mr},
		}, nil
	case operand.IsIMM32(imr) && operand.IsM64(mr),
		operand.IsIMM32(imr) && operand.IsR64(mr),
		operand.IsIMM32(imr) && operand.IsRAX(mr),
		operand.IsIMM8(imr) && operand.IsM64(mr),
		operand.IsIMM8(imr) && operand.IsR64(mr):
		return &intrep.Instruction{
			Opcode:   "XORQ",
			Operands: []operand.Op{imr, mr},
			Inputs:   []operand.Op{mr},
			Outputs:  []operand.Op{mr},
		}, nil
	}
	return nil, errors.New("XORQ: bad operands")
}

// XORW: Logical Exclusive OR.
//
// Forms:
//
// 	XORW imm16 ax
// 	XORW imm16 m16
// 	XORW imm16 r16
// 	XORW imm8  m16
// 	XORW imm8  r16
// 	XORW m16   r16
// 	XORW r16   m16
// 	XORW r16   r16
func XORW(imr, amr operand.Op) (*intrep.Instruction, error) {
	switch {
	case operand.IsIMM16(imr) && operand.IsAX(amr),
		operand.IsIMM16(imr) && operand.IsM16(amr),
		operand.IsIMM16(imr) && operand.IsR16(amr),
		operand.IsIMM8(imr) && operand.IsM16(amr),
		operand.IsIMM8(imr) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:   "XORW",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{amr},
			Outputs:  []operand.Op{amr},
		}, nil
	case operand.IsR16(imr) && operand.IsR16(amr):
		return &intrep.Instruction{
			Opcode:           "XORW",
			Operands:         []operand.Op{imr, amr},
			Inputs:           []operand.Op{imr, amr},
			Outputs:          []operand.Op{amr},
			CancellingInputs: true,
		}, nil
	case operand.IsM16(imr) && operand.IsR16(amr),
		operand.IsR16(imr) && operand.IsM16(amr):
		return &intrep.Instruction{
			Opcode:   "XORW",
			Operands: []operand.Op{imr, amr},
			Inputs:   []operand.Op{imr, amr},
			Outputs:  []operand.Op{amr},
		}, nil
	}
	return nil, errors.New("XORW: bad operands")
}
